const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["./DD5dnlZh.js", "./error-404.aNCZ2L4y.css", "./R63OqrMl.js", "./error-500.JESWioAZ.css"]))) => i.map(i => d[i]);
var pd = Object.defineProperty; var dl = e => { throw TypeError(e) }; var hd = (e, t, n) => t in e ? pd(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var Nt = (e, t, n) => hd(e, typeof t != "symbol" ? t + "" : t, n), gd = (e, t, n) => t.has(e) || dl("Cannot " + n); var zn = (e, t, n) => (gd(e, t, "read from private field"), n ? n.call(e) : t.get(e)), pl = (e, t, n) => t.has(e) ? dl("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o); new MutationObserver(o => { for (const s of o) if (s.type === "childList") for (const i of s.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && r(i) }).observe(document, { childList: !0, subtree: !0 }); function n(o) { const s = {}; return o.integrity && (s.integrity = o.integrity), o.referrerPolicy && (s.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? s.credentials = "include" : o.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(o) { if (o.ep) return; o.ep = !0; const s = n(o); fetch(o.href, s) } })();/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function xi(e) { const t = Object.create(null); for (const n of e.split(",")) t[n] = 1; return n => n in t } const pe = {}, Tn = [], xt = () => { }, md = () => !1, Sr = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), _i = e => e.startsWith("onUpdate:"), Ie = Object.assign, Si = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, yd = Object.prototype.hasOwnProperty, ue = (e, t) => yd.call(e, t), Q = Array.isArray, An = e => Po(e) === "[object Map]", Za = e => Po(e) === "[object Set]", J = e => typeof e == "function", _e = e => typeof e == "string", Rt = e => typeof e == "symbol", be = e => e !== null && typeof e == "object", Qa = e => (be(e) || J(e)) && J(e.then) && J(e.catch), Ya = Object.prototype.toString, Po = e => Ya.call(e), bd = e => Po(e).slice(8, -1), Xa = e => Po(e) === "[object Object]", Ci = e => _e(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Pn = xi(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), $o = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, vd = /-(\w)/g, st = $o(e => e.replace(vd, (t, n) => n ? n.toUpperCase() : "")), wd = /\B([A-Z])/g, Qt = $o(e => e.replace(wd, "-$1").toLowerCase()), Oo = $o(e => e.charAt(0).toUpperCase() + e.slice(1)), es = $o(e => e ? `on${Oo(e)}` : ""), Gt = (e, t) => !Object.is(e, t), ts = (e, ...t) => { for (let n = 0; n < e.length; n++)e[n](...t) }, ec = (e, t, n, r = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: r, value: n }) }, xd = e => { const t = parseFloat(e); return isNaN(t) ? e : t }, tc = e => { const t = _e(e) ? Number(e) : NaN; return isNaN(t) ? e : t }; let hl; const Io = () => hl || (hl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Lo(e) { if (Q(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n], o = _e(r) ? kd(r) : Lo(r); if (o) for (const s in o) t[s] = o[s] } return t } else if (_e(e) || be(e)) return e } const _d = /;(?![^(]*\))/g, Sd = /:([^]+)/, Cd = /\/\*[^]*?\*\//g; function kd(e) { const t = {}; return e.replace(Cd, "").split(_d).forEach(n => { if (n) { const r = n.split(Sd); r.length > 1 && (t[r[0].trim()] = r[1].trim()) } }), t } function $e(e) { let t = ""; if (_e(e)) t = e; else if (Q(e)) for (let n = 0; n < e.length; n++) { const r = $e(e[n]); r && (t += r + " ") } else if (be(e)) for (const n in e) e[n] && (t += n + " "); return t.trim() } function ur(e) { if (!e) return null; let { class: t, style: n } = e; return t && !_e(t) && (e.class = $e(t)), n && (e.style = Lo(n)), e } const Ed = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Td = xi(Ed); function nc(e) { return !!e || e === "" } const rc = e => !!(e && e.__v_isRef === !0), Ot = e => _e(e) ? e : e == null ? "" : Q(e) || be(e) && (e.toString === Ya || !J(e.toString)) ? rc(e) ? Ot(e.value) : JSON.stringify(e, oc, 2) : String(e), oc = (e, t) => rc(t) ? oc(e, t.value) : An(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [r, o], s) => (n[ns(r, s) + " =>"] = o, n), {}) } : Za(t) ? { [`Set(${t.size})`]: [...t.values()].map(n => ns(n)) } : Rt(t) ? ns(t) : be(t) && !Q(t) && !Xa(t) ? String(t) : t, ns = (e, t = "") => { var n; return Rt(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e };/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Qe; class sc { constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Qe, !t && Qe && (this.index = (Qe.scopes || (Qe.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].pause(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].resume(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].resume() } } run(t) { if (this._active) { const n = Qe; try { return Qe = this, t() } finally { Qe = n } } } on() { Qe = this } off() { Qe = this.parent } stop(t) { if (this._active) { this._active = !1; let n, r; for (n = 0, r = this.effects.length; n < r; n++)this.effects[n].stop(); for (this.effects.length = 0, n = 0, r = this.cleanups.length; n < r; n++)this.cleanups[n](); if (this.cleanups.length = 0, this.scopes) { for (n = 0, r = this.scopes.length; n < r; n++)this.scopes[n].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { const o = this.parent.scopes.pop(); o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index) } this.parent = void 0 } } } function Ad(e) { return new sc(e) } function ic() { return Qe } let ye; const rs = new WeakSet; class lc { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Qe && Qe.active && Qe.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, rs.has(this) && (rs.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || cc(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, gl(this), uc(this); const t = ye, n = ct; ye = this, ct = !0; try { return this.fn() } finally { fc(this), ye = t, ct = n, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)Ti(t); this.deps = this.depsTail = void 0, gl(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? rs.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { Ts(this) && this.run() } get dirty() { return Ts(this) } } let ac = 0, or, sr; function cc(e, t = !1) { if (e.flags |= 8, t) { e.next = sr, sr = e; return } e.next = or, or = e } function ki() { ac++ } function Ei() { if (--ac > 0) return; if (sr) { let t = sr; for (sr = void 0; t;) { const n = t.next; t.next = void 0, t.flags &= -9, t = n } } let e; for (; or;) { let t = or; for (or = void 0; t;) { const n = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (r) { e || (e = r) } t = n } } if (e) throw e } function uc(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function fc(e) { let t, n = e.depsTail, r = n; for (; r;) { const o = r.prevDep; r.version === -1 ? (r === n && (n = o), Ti(r), Pd(r)) : t = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = o } e.deps = t, e.depsTail = n } function Ts(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (dc(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function dc(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === fr)) return; e.globalVersion = fr; const t = e.dep; if (e.flags |= 2, t.version > 0 && !e.isSSR && e.deps && !Ts(e)) { e.flags &= -3; return } const n = ye, r = ct; ye = e, ct = !0; try { uc(e); const o = e.fn(e._value); (t.version === 0 || Gt(o, e._value)) && (e._value = o, t.version++) } catch (o) { throw t.version++, o } finally { ye = n, ct = r, fc(e), e.flags &= -3 } } function Ti(e, t = !1) { const { dep: n, prevSub: r, nextSub: o } = e; if (r && (r.nextSub = o, e.prevSub = void 0), o && (o.prevSub = r, e.nextSub = void 0), n.subs === e && (n.subs = r, !r && n.computed)) { n.computed.flags &= -5; for (let s = n.computed.deps; s; s = s.nextDep)Ti(s, !0) } !t && !--n.sc && n.map && n.map.delete(n.key) } function Pd(e) { const { prevDep: t, nextDep: n } = e; t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0) } let ct = !0; const pc = []; function Yt() { pc.push(ct), ct = !1 } function Xt() { const e = pc.pop(); ct = e === void 0 ? !0 : e } function gl(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const n = ye; ye = void 0; try { t() } finally { ye = n } } } let fr = 0; class $d { constructor(t, n) { this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class Ai { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0 } track(t) { if (!ye || !ct || ye === this.computed) return; let n = this.activeLink; if (n === void 0 || n.sub !== ye) n = this.activeLink = new $d(ye, this), ye.deps ? (n.prevDep = ye.depsTail, ye.depsTail.nextDep = n, ye.depsTail = n) : ye.deps = ye.depsTail = n, hc(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) { const r = n.nextDep; r.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = r), n.prevDep = ye.depsTail, n.nextDep = void 0, ye.depsTail.nextDep = n, ye.depsTail = n, ye.deps === n && (ye.deps = r) } return n } trigger(t) { this.version++, fr++, this.notify(t) } notify(t) { ki(); try { for (let n = this.subs; n; n = n.prevSub)n.sub.notify() && n.sub.dep.notify() } finally { Ei() } } } function hc(e) { if (e.dep.sc++, e.sub.flags & 4) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let r = t.deps; r; r = r.nextDep)hc(r) } const n = e.dep.subs; n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e } } const ao = new WeakMap, fn = Symbol(""), As = Symbol(""), dr = Symbol(""); function je(e, t, n) { if (ct && ye) { let r = ao.get(e); r || ao.set(e, r = new Map); let o = r.get(n); o || (r.set(n, o = new Ai), o.map = r, o.key = n), o.track() } } function Pt(e, t, n, r, o, s) { const i = ao.get(e); if (!i) { fr++; return } const l = a => { a && a.trigger() }; if (ki(), t === "clear") i.forEach(l); else { const a = Q(e), u = a && Ci(n); if (a && n === "length") { const c = Number(r); i.forEach((f, d) => { (d === "length" || d === dr || !Rt(d) && d >= c) && l(f) }) } else switch ((n !== void 0 || i.has(void 0)) && l(i.get(n)), u && l(i.get(dr)), t) { case "add": a ? u && l(i.get("length")) : (l(i.get(fn)), An(e) && l(i.get(As))); break; case "delete": a || (l(i.get(fn)), An(e) && l(i.get(As))); break; case "set": An(e) && l(i.get(fn)); break } } Ei() } function Od(e, t) { const n = ao.get(e); return n && n.get(t) } function _n(e) { const t = ae(e); return t === e ? t : (je(t, "iterate", dr), rt(e) ? t : t.map(Ne)) } function Mo(e) { return je(e = ae(e), "iterate", dr), e } const Id = { __proto__: null, [Symbol.iterator]() { return os(this, Symbol.iterator, Ne) }, concat(...e) { return _n(this).concat(...e.map(t => Q(t) ? _n(t) : t)) }, entries() { return os(this, "entries", e => (e[1] = Ne(e[1]), e)) }, every(e, t) { return St(this, "every", e, t, void 0, arguments) }, filter(e, t) { return St(this, "filter", e, t, n => n.map(Ne), arguments) }, find(e, t) { return St(this, "find", e, t, Ne, arguments) }, findIndex(e, t) { return St(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return St(this, "findLast", e, t, Ne, arguments) }, findLastIndex(e, t) { return St(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return St(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return ss(this, "includes", e) }, indexOf(...e) { return ss(this, "indexOf", e) }, join(e) { return _n(this).join(e) }, lastIndexOf(...e) { return ss(this, "lastIndexOf", e) }, map(e, t) { return St(this, "map", e, t, void 0, arguments) }, pop() { return qn(this, "pop") }, push(...e) { return qn(this, "push", e) }, reduce(e, ...t) { return ml(this, "reduce", e, t) }, reduceRight(e, ...t) { return ml(this, "reduceRight", e, t) }, shift() { return qn(this, "shift") }, some(e, t) { return St(this, "some", e, t, void 0, arguments) }, splice(...e) { return qn(this, "splice", e) }, toReversed() { return _n(this).toReversed() }, toSorted(e) { return _n(this).toSorted(e) }, toSpliced(...e) { return _n(this).toSpliced(...e) }, unshift(...e) { return qn(this, "unshift", e) }, values() { return os(this, "values", Ne) } }; function os(e, t, n) { const r = Mo(e), o = r[t](); return r !== e && !rt(e) && (o._next = o.next, o.next = () => { const s = o._next(); return s.value && (s.value = n(s.value)), s }), o } const Ld = Array.prototype; function St(e, t, n, r, o, s) { const i = Mo(e), l = i !== e && !rt(e), a = i[t]; if (a !== Ld[t]) { const f = a.apply(e, s); return l ? Ne(f) : f } let u = n; i !== e && (l ? u = function (f, d) { return n.call(this, Ne(f), d, e) } : n.length > 2 && (u = function (f, d) { return n.call(this, f, d, e) })); const c = a.call(i, u, r); return l && o ? o(c) : c } function ml(e, t, n, r) { const o = Mo(e); let s = n; return o !== e && (rt(e) ? n.length > 3 && (s = function (i, l, a) { return n.call(this, i, l, a, e) }) : s = function (i, l, a) { return n.call(this, i, Ne(l), a, e) }), o[t](s, ...r) } function ss(e, t, n) { const r = ae(e); je(r, "iterate", dr); const o = r[t](...n); return (o === -1 || o === !1) && Oi(n[0]) ? (n[0] = ae(n[0]), r[t](...n)) : o } function qn(e, t, n = []) { Yt(), ki(); const r = ae(e)[t].apply(e, n); return Ei(), Xt(), r } const Md = xi("__proto__,__v_isRef,__isVue"), gc = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Rt)); function Rd(e) { Rt(e) || (e = String(e)); const t = ae(this); return je(t, "has", e), t.hasOwnProperty(e) } class mc { constructor(t = !1, n = !1) { this._isReadonly = t, this._isShallow = n } get(t, n, r) { if (n === "__v_skip") return t.__v_skip; const o = this._isReadonly, s = this._isShallow; if (n === "__v_isReactive") return !o; if (n === "__v_isReadonly") return o; if (n === "__v_isShallow") return s; if (n === "__v_raw") return r === (o ? s ? Wd : wc : s ? vc : bc).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(r) ? t : void 0; const i = Q(t); if (!o) { let a; if (i && (a = Id[n])) return a; if (n === "hasOwnProperty") return Rd } const l = Reflect.get(t, n, Ee(t) ? t : r); return (Rt(n) ? gc.has(n) : Md(n)) || (o || je(t, "get", n), s) ? l : Ee(l) ? i && Ci(n) ? l : l.value : be(l) ? o ? xc(l) : ut(l) : l } } class yc extends mc { constructor(t = !1) { super(!1, t) } set(t, n, r, o) { let s = t[n]; if (!this._isShallow) { const a = Kt(s); if (!rt(r) && !Kt(r) && (s = ae(s), r = ae(r)), !Q(t) && Ee(s) && !Ee(r)) return a ? !1 : (s.value = r, !0) } const i = Q(t) && Ci(n) ? Number(n) < t.length : ue(t, n), l = Reflect.set(t, n, r, Ee(t) ? t : o); return t === ae(o) && (i ? Gt(r, s) && Pt(t, "set", n, r) : Pt(t, "add", n, r)), l } deleteProperty(t, n) { const r = ue(t, n); t[n]; const o = Reflect.deleteProperty(t, n); return o && r && Pt(t, "delete", n, void 0), o } has(t, n) { const r = Reflect.has(t, n); return (!Rt(n) || !gc.has(n)) && je(t, "has", n), r } ownKeys(t) { return je(t, "iterate", Q(t) ? "length" : fn), Reflect.ownKeys(t) } } class jd extends mc { constructor(t = !1) { super(!0, t) } set(t, n) { return !0 } deleteProperty(t, n) { return !0 } } const Nd = new yc, Fd = new jd, Bd = new yc(!0); const Ps = e => e, Rr = e => Reflect.getPrototypeOf(e); function Hd(e, t, n) { return function (...r) { const o = this.__v_raw, s = ae(o), i = An(s), l = e === "entries" || e === Symbol.iterator && i, a = e === "keys" && i, u = o[e](...r), c = n ? Ps : t ? $s : Ne; return !t && je(s, "iterate", a ? As : fn), { next() { const { value: f, done: d } = u.next(); return d ? { value: f, done: d } : { value: l ? [c(f[0]), c(f[1])] : c(f), done: d } }, [Symbol.iterator]() { return this } } } } function jr(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function Dd(e, t) { const n = { get(o) { const s = this.__v_raw, i = ae(s), l = ae(o); e || (Gt(o, l) && je(i, "get", o), je(i, "get", l)); const { has: a } = Rr(i), u = t ? Ps : e ? $s : Ne; if (a.call(i, o)) return u(s.get(o)); if (a.call(i, l)) return u(s.get(l)); s !== i && s.get(o) }, get size() { const o = this.__v_raw; return !e && je(ae(o), "iterate", fn), Reflect.get(o, "size", o) }, has(o) { const s = this.__v_raw, i = ae(s), l = ae(o); return e || (Gt(o, l) && je(i, "has", o), je(i, "has", l)), o === l ? s.has(o) : s.has(o) || s.has(l) }, forEach(o, s) { const i = this, l = i.__v_raw, a = ae(l), u = t ? Ps : e ? $s : Ne; return !e && je(a, "iterate", fn), l.forEach((c, f) => o.call(s, u(c), u(f), i)) } }; return Ie(n, e ? { add: jr("add"), set: jr("set"), delete: jr("delete"), clear: jr("clear") } : { add(o) { !t && !rt(o) && !Kt(o) && (o = ae(o)); const s = ae(this); return Rr(s).has.call(s, o) || (s.add(o), Pt(s, "add", o, o)), this }, set(o, s) { !t && !rt(s) && !Kt(s) && (s = ae(s)); const i = ae(this), { has: l, get: a } = Rr(i); let u = l.call(i, o); u || (o = ae(o), u = l.call(i, o)); const c = a.call(i, o); return i.set(o, s), u ? Gt(s, c) && Pt(i, "set", o, s) : Pt(i, "add", o, s), this }, delete(o) { const s = ae(this), { has: i, get: l } = Rr(s); let a = i.call(s, o); a || (o = ae(o), a = i.call(s, o)), l && l.call(s, o); const u = s.delete(o); return a && Pt(s, "delete", o, void 0), u }, clear() { const o = ae(this), s = o.size !== 0, i = o.clear(); return s && Pt(o, "clear", void 0, void 0), i } }), ["keys", "values", "entries", Symbol.iterator].forEach(o => { n[o] = Hd(o, e, t) }), n } function Pi(e, t) { const n = Dd(e, t); return (r, o, s) => o === "__v_isReactive" ? !e : o === "__v_isReadonly" ? e : o === "__v_raw" ? r : Reflect.get(ue(n, o) && o in r ? n : r, o, s) } const Ud = { get: Pi(!1, !1) }, zd = { get: Pi(!1, !0) }, qd = { get: Pi(!0, !1) }; const bc = new WeakMap, vc = new WeakMap, wc = new WeakMap, Wd = new WeakMap; function Vd(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function Gd(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : Vd(bd(e)) } function ut(e) { return Kt(e) ? e : $i(e, !1, Nd, Ud, bc) } function kn(e) { return $i(e, !1, Bd, zd, vc) } function xc(e) { return $i(e, !0, Fd, qd, wc) } function $i(e, t, n, r, o) { if (!be(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const s = o.get(e); if (s) return s; const i = Gd(e); if (i === 0) return e; const l = new Proxy(e, i === 2 ? r : n); return o.set(e, l), l } function dn(e) { return Kt(e) ? dn(e.__v_raw) : !!(e && e.__v_isReactive) } function Kt(e) { return !!(e && e.__v_isReadonly) } function rt(e) { return !!(e && e.__v_isShallow) } function Oi(e) { return e ? !!e.__v_raw : !1 } function ae(e) { const t = e && e.__v_raw; return t ? ae(t) : e } function Kd(e) { return !ue(e, "__v_skip") && Object.isExtensible(e) && ec(e, "__v_skip", !0), e } const Ne = e => be(e) ? ut(e) : e, $s = e => be(e) ? xc(e) : e; function Ee(e) { return e ? e.__v_isRef === !0 : !1 } function G(e) { return _c(e, !1) } function pr(e) { return _c(e, !0) } function _c(e, t) { return Ee(e) ? e : new Jd(e, t) } class Jd { constructor(t, n) { this.dep = new Ai, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : ae(t), this._value = n ? t : Ne(t), this.__v_isShallow = n } get value() { return this.dep.track(), this._value } set value(t) { const n = this._rawValue, r = this.__v_isShallow || rt(t) || Kt(t); t = r ? t : ae(t), Gt(t, n) && (this._rawValue = t, this._value = r ? t : Ne(t), this.dep.trigger()) } } function we(e) { return Ee(e) ? e.value : e } function Jr(e) { return J(e) ? e() : we(e) } const Zd = { get: (e, t, n) => t === "__v_raw" ? e : we(Reflect.get(e, t, n)), set: (e, t, n, r) => { const o = e[t]; return Ee(o) && !Ee(n) ? (o.value = n, !0) : Reflect.set(e, t, n, r) } }; function Sc(e) { return dn(e) ? e : new Proxy(e, Zd) } class Qd { constructor(t, n, r) { this._object = t, this._key = n, this._defaultValue = r, this.__v_isRef = !0, this._value = void 0 } get value() { const t = this._object[this._key]; return this._value = t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } get dep() { return Od(ae(this._object), this._key) } } class Yd { constructor(t) { this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0 } get value() { return this._value = this._getter() } } function yn(e, t, n) { return Ee(e) ? e : J(e) ? new Yd(e) : be(e) && arguments.length > 1 ? Xd(e, t, n) : G(e) } function Xd(e, t, n) { const r = e[t]; return Ee(r) ? r : new Qd(e, t, n) } class ep { constructor(t, n, r) { this.fn = t, this.setter = n, this._value = void 0, this.dep = new Ai(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = fr - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = r } notify() { if (this.flags |= 16, !(this.flags & 8) && ye !== this) return cc(this, !0), !0 } get value() { const t = this.dep.track(); return dc(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } } function tp(e, t, n = !1) { let r, o; return J(e) ? r = e : (r = e.get, o = e.set), new ep(r, o, n) } const Nr = {}, co = new WeakMap; let ln; function np(e, t = !1, n = ln) { if (n) { let r = co.get(n); r || co.set(n, r = []), r.push(e) } } function rp(e, t, n = pe) { const { immediate: r, deep: o, once: s, scheduler: i, augmentJob: l, call: a } = n, u = w => o ? w : rt(w) || o === !1 || o === 0 ? $t(w, 1) : $t(w); let c, f, d, h, g = !1, p = !1; if (Ee(e) ? (f = () => e.value, g = rt(e)) : dn(e) ? (f = () => u(e), g = !0) : Q(e) ? (p = !0, g = e.some(w => dn(w) || rt(w)), f = () => e.map(w => { if (Ee(w)) return w.value; if (dn(w)) return u(w); if (J(w)) return a ? a(w, 2) : w() })) : J(e) ? t ? f = a ? () => a(e, 2) : e : f = () => { if (d) { Yt(); try { d() } finally { Xt() } } const w = ln; ln = c; try { return a ? a(e, 3, [h]) : e(h) } finally { ln = w } } : f = xt, t && o) { const w = f, S = o === !0 ? 1 / 0 : o; f = () => $t(w(), S) } const b = ic(), _ = () => { c.stop(), b && b.active && Si(b.effects, c) }; if (s && t) { const w = t; t = (...S) => { w(...S), _() } } let C = p ? new Array(e.length).fill(Nr) : Nr; const y = w => { if (!(!(c.flags & 1) || !c.dirty && !w)) if (t) { const S = c.run(); if (o || g || (p ? S.some((k, M) => Gt(k, C[M])) : Gt(S, C))) { d && d(); const k = ln; ln = c; try { const M = [S, C === Nr ? void 0 : p && C[0] === Nr ? [] : C, h]; a ? a(t, 3, M) : t(...M), C = S } finally { ln = k } } } else c.run() }; return l && l(y), c = new lc(f), c.scheduler = i ? () => i(y, !1) : y, h = w => np(w, !1, c), d = c.onStop = () => { const w = co.get(c); if (w) { if (a) a(w, 4); else for (const S of w) S(); co.delete(c) } }, t ? r ? y(!0) : C = c.run() : i ? i(y.bind(null, !0), !0) : c.run(), _.pause = c.pause.bind(c), _.resume = c.resume.bind(c), _.stop = _, _ } function $t(e, t = 1 / 0, n) { if (t <= 0 || !be(e) || e.__v_skip || (n = n || new Set, n.has(e))) return e; if (n.add(e), t--, Ee(e)) $t(e.value, t, n); else if (Q(e)) for (let r = 0; r < e.length; r++)$t(e[r], t, n); else if (Za(e) || An(e)) e.forEach(r => { $t(r, t, n) }); else if (Xa(e)) { for (const r in e) $t(e[r], t, n); for (const r of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, r) && $t(e[r], t, n) } return e }/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Cr(e, t, n, r) { try { return r ? e(...r) : e() } catch (o) { Nn(o, t, n) } } function ft(e, t, n, r) { if (J(e)) { const o = Cr(e, t, n, r); return o && Qa(o) && o.catch(s => { Nn(s, t, n) }), o } if (Q(e)) { const o = []; for (let s = 0; s < e.length; s++)o.push(ft(e[s], t, n, r)); return o } } function Nn(e, t, n, r = !0) { const o = t ? t.vnode : null, { errorHandler: s, throwUnhandledErrorInProduction: i } = t && t.appContext.config || pe; if (t) { let l = t.parent; const a = t.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`; for (; l;) { const c = l.ec; if (c) { for (let f = 0; f < c.length; f++)if (c[f](e, a, u) === !1) return } l = l.parent } if (s) { Yt(), Cr(s, null, 10, [e, a, u]), Xt(); return } } op(e, n, o, r, i) } function op(e, t, n, r = !0, o = !1) { if (o) throw e; console.error(e) } const Ue = []; let yt = -1; const $n = []; let Dt = null, Cn = 0; const Cc = Promise.resolve(); let uo = null; function Ii(e) { const t = uo || Cc; return e ? t.then(this ? e.bind(this) : e) : t } function sp(e) { let t = yt + 1, n = Ue.length; for (; t < n;) { const r = t + n >>> 1, o = Ue[r], s = hr(o); s < e || s === e && o.flags & 2 ? t = r + 1 : n = r } return t } function Li(e) { if (!(e.flags & 1)) { const t = hr(e), n = Ue[Ue.length - 1]; !n || !(e.flags & 2) && t >= hr(n) ? Ue.push(e) : Ue.splice(sp(t), 0, e), e.flags |= 1, kc() } } function kc() { uo || (uo = Cc.then(Ec)) } function Os(e) { Q(e) ? $n.push(...e) : Dt && e.id === -1 ? Dt.splice(Cn + 1, 0, e) : e.flags & 1 || ($n.push(e), e.flags |= 1), kc() } function yl(e, t, n = yt + 1) { for (; n < Ue.length; n++) { const r = Ue[n]; if (r && r.flags & 2) { if (e && r.id !== e.uid) continue; Ue.splice(n, 1), n--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2) } } } function fo(e) { if ($n.length) { const t = [...new Set($n)].sort((n, r) => hr(n) - hr(r)); if ($n.length = 0, Dt) { Dt.push(...t); return } for (Dt = t, Cn = 0; Cn < Dt.length; Cn++) { const n = Dt[Cn]; n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2 } Dt = null, Cn = 0 } } const hr = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function Ec(e) { try { for (yt = 0; yt < Ue.length; yt++) { const t = Ue[yt]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), Cr(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2)) } } finally { for (; yt < Ue.length; yt++) { const t = Ue[yt]; t && (t.flags &= -2) } yt = -1, Ue.length = 0, fo(), uo = null, (Ue.length || $n.length) && Ec() } } let Pe = null, Tc = null; function po(e) { const t = Pe; return Pe = e, Tc = e && e.type.__scopeId || null, t } function X(e, t = Pe, n) { if (!t || e._n) return e; const r = (...o) => { r._d && Ll(-1); const s = po(t); let i; try { i = e(...o) } finally { po(s), r._d && Ll(1) } return i }; return r._n = !0, r._c = !0, r._d = !0, r } function ip(e, t) { if (Pe === null) return e; const n = Ho(Pe), r = e.dirs || (e.dirs = []); for (let o = 0; o < t.length; o++) { let [s, i, l, a = pe] = t[o]; s && (J(s) && (s = { mounted: s, updated: s }), s.deep && $t(i), r.push({ dir: s, instance: n, value: i, oldValue: void 0, arg: l, modifiers: a })) } return e } function bt(e, t, n, r) { const o = e.dirs, s = t && t.dirs; for (let i = 0; i < o.length; i++) { const l = o[i]; s && (l.oldValue = s[i].value); let a = l.dir[r]; a && (Yt(), ft(a, n, 8, [e.el, l, e, t]), Xt()) } } const Ac = Symbol("_vte"), Pc = e => e.__isTeleport, ir = e => e && (e.disabled || e.disabled === ""), bl = e => e && (e.defer || e.defer === ""), vl = e => typeof SVGElement < "u" && e instanceof SVGElement, wl = e => typeof MathMLElement == "function" && e instanceof MathMLElement, Is = (e, t) => { const n = e && e.to; return _e(n) ? t ? t(n) : null : n }, $c = { name: "Teleport", __isTeleport: !0, process(e, t, n, r, o, s, i, l, a, u) { const { mc: c, pc: f, pbc: d, o: { insert: h, querySelector: g, createText: p, createComment: b } } = u, _ = ir(t.props); let { shapeFlag: C, children: y, dynamicChildren: w } = t; if (e == null) { const S = t.el = p(""), k = t.anchor = p(""); h(S, n, r), h(k, n, r); const M = (A, P) => { C & 16 && (o && o.isCE && (o.ce._teleportTarget = A), c(y, A, P, o, s, i, l, a)) }, D = () => { const A = t.target = Is(t.props, g), P = Oc(A, t, p, h); A && (i !== "svg" && vl(A) ? i = "svg" : i !== "mathml" && wl(A) && (i = "mathml"), _ || (M(A, P), Zr(t, !1))) }; _ && (M(n, k), Zr(t, !0)), bl(t.props) ? De(() => { D(), t.el.__isMounted = !0 }, s) : D() } else { if (bl(t.props) && !e.el.__isMounted) { De(() => { $c.process(e, t, n, r, o, s, i, l, a, u), delete e.el.__isMounted }, s); return } t.el = e.el, t.targetStart = e.targetStart; const S = t.anchor = e.anchor, k = t.target = e.target, M = t.targetAnchor = e.targetAnchor, D = ir(e.props), A = D ? n : k, P = D ? S : M; if (i === "svg" || vl(k) ? i = "svg" : (i === "mathml" || wl(k)) && (i = "mathml"), w ? (d(e.dynamicChildren, w, A, o, s, i, l), Ni(e, t, !0)) : a || f(e, t, A, P, o, s, i, l, !1), _) D ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Fr(t, n, S, u, 1); else if ((t.props && t.props.to) !== (e.props && e.props.to)) { const W = t.target = Is(t.props, g); W && Fr(t, W, null, u, 0) } else D && Fr(t, k, M, u, 1); Zr(t, _) } }, remove(e, t, n, { um: r, o: { remove: o } }, s) { const { shapeFlag: i, children: l, anchor: a, targetStart: u, targetAnchor: c, target: f, props: d } = e; if (f && (o(u), o(c)), s && o(a), i & 16) { const h = s || !ir(d); for (let g = 0; g < l.length; g++) { const p = l[g]; r(p, t, n, h, !!p.dynamicChildren) } } }, move: Fr, hydrate: lp }; function Fr(e, t, n, { o: { insert: r }, m: o }, s = 2) { s === 0 && r(e.targetAnchor, t, n); const { el: i, anchor: l, shapeFlag: a, children: u, props: c } = e, f = s === 2; if (f && r(i, t, n), (!f || ir(c)) && a & 16) for (let d = 0; d < u.length; d++)o(u[d], t, n, 2); f && r(l, t, n) } function lp(e, t, n, r, o, s, { o: { nextSibling: i, parentNode: l, querySelector: a, insert: u, createText: c } }, f) { const d = t.target = Is(t.props, a); if (d) { const h = ir(t.props), g = d._lpa || d.firstChild; if (t.shapeFlag & 16) if (h) t.anchor = f(i(e), t, l(e), n, r, o, s), t.targetStart = g, t.targetAnchor = g && i(g); else { t.anchor = i(e); let p = g; for (; p;) { if (p && p.nodeType === 8) { if (p.data === "teleport start anchor") t.targetStart = p; else if (p.data === "teleport anchor") { t.targetAnchor = p, d._lpa = t.targetAnchor && i(t.targetAnchor); break } } p = i(p) } t.targetAnchor || Oc(d, t, c, u), f(g && i(g), t, d, n, r, o, s) } Zr(t, h) } return t.anchor && i(t.anchor) } const ap = $c; function Zr(e, t) { const n = e.ctx; if (n && n.ut) { let r, o; for (t ? (r = e.el, o = e.anchor) : (r = e.targetStart, o = e.targetAnchor); r && r !== o;)r.nodeType === 1 && r.setAttribute("data-v-owner", n.uid), r = r.nextSibling; n.ut() } } function Oc(e, t, n, r) { const o = t.targetStart = n(""), s = t.targetAnchor = n(""); return o[Ac] = s, e && (r(o, e), r(s, e)), s } const Ut = Symbol("_leaveCb"), Br = Symbol("_enterCb"); function cp() { const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return Te(() => { e.isMounted = !0 }), jo(() => { e.isUnmounting = !0 }), e } const tt = [Function, Array], Ic = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: tt, onEnter: tt, onAfterEnter: tt, onEnterCancelled: tt, onBeforeLeave: tt, onLeave: tt, onAfterLeave: tt, onLeaveCancelled: tt, onBeforeAppear: tt, onAppear: tt, onAfterAppear: tt, onAppearCancelled: tt }, Lc = e => { const t = e.subTree; return t.component ? Lc(t.component) : t }, up = { name: "BaseTransition", props: Ic, setup(e, { slots: t }) { const n = vn(), r = cp(); return () => { const o = t.default && jc(t.default(), !0); if (!o || !o.length) return; const s = Mc(o), i = ae(e), { mode: l } = i; if (r.isLeaving) return is(s); const a = xl(s); if (!a) return is(s); let u = Ls(a, i, r, n, f => u = f); a.type !== Oe && gr(a, u); let c = n.subTree && xl(n.subTree); if (c && c.type !== Oe && !vt(a, c) && Lc(n).type !== Oe) { let f = Ls(c, i, r, n); if (gr(c, f), l === "out-in" && a.type !== Oe) return r.isLeaving = !0, f.afterLeave = () => { r.isLeaving = !1, n.job.flags & 8 || n.update(), delete f.afterLeave, c = void 0 }, is(s); l === "in-out" && a.type !== Oe ? f.delayLeave = (d, h, g) => { const p = Rc(r, c); p[String(c.key)] = c, d[Ut] = () => { h(), d[Ut] = void 0, delete u.delayedLeave, c = void 0 }, u.delayedLeave = () => { g(), delete u.delayedLeave, c = void 0 } } : c = void 0 } else c && (c = void 0); return s } } }; function Mc(e) { let t = e[0]; if (e.length > 1) { for (const n of e) if (n.type !== Oe) { t = n; break } } return t } const fp = up; function Rc(e, t) { const { leavingVNodes: n } = e; let r = n.get(t.type); return r || (r = Object.create(null), n.set(t.type, r)), r } function Ls(e, t, n, r, o) { const { appear: s, mode: i, persisted: l = !1, onBeforeEnter: a, onEnter: u, onAfterEnter: c, onEnterCancelled: f, onBeforeLeave: d, onLeave: h, onAfterLeave: g, onLeaveCancelled: p, onBeforeAppear: b, onAppear: _, onAfterAppear: C, onAppearCancelled: y } = t, w = String(e.key), S = Rc(n, e), k = (A, P) => { A && ft(A, r, 9, P) }, M = (A, P) => { const W = P[1]; k(A, P), Q(A) ? A.every(T => T.length <= 1) && W() : A.length <= 1 && W() }, D = { mode: i, persisted: l, beforeEnter(A) { let P = a; if (!n.isMounted) if (s) P = b || a; else return; A[Ut] && A[Ut](!0); const W = S[w]; W && vt(e, W) && W.el[Ut] && W.el[Ut](), k(P, [A]) }, enter(A) { let P = u, W = c, T = f; if (!n.isMounted) if (s) P = _ || u, W = C || c, T = y || f; else return; let U = !1; const te = A[Br] = oe => { U || (U = !0, oe ? k(T, [A]) : k(W, [A]), D.delayedLeave && D.delayedLeave(), A[Br] = void 0) }; P ? M(P, [A, te]) : te() }, leave(A, P) { const W = String(e.key); if (A[Br] && A[Br](!0), n.isUnmounting) return P(); k(d, [A]); let T = !1; const U = A[Ut] = te => { T || (T = !0, P(), te ? k(p, [A]) : k(g, [A]), A[Ut] = void 0, S[W] === e && delete S[W]) }; S[W] = e, h ? M(h, [A, U]) : U() }, clone(A) { const P = Ls(A, t, n, r, o); return o && o(P), P } }; return D } function is(e) { if (kr(e)) return e = Mt(e), e.children = null, e } function xl(e) { if (!kr(e)) return Pc(e.type) && e.children ? Mc(e.children) : e; const { shapeFlag: t, children: n } = e; if (n) { if (t & 16) return n[0]; if (t & 32 && J(n.default)) return n.default() } } function gr(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, gr(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function jc(e, t = !1, n) { let r = [], o = 0; for (let s = 0; s < e.length; s++) { let i = e[s]; const l = n == null ? i.key : String(n) + String(i.key != null ? i.key : s); i.type === ke ? (i.patchFlag & 128 && o++, r = r.concat(jc(i.children, t, l))) : (t || i.type !== Oe) && r.push(l != null ? Mt(i, { key: l }) : i) } if (o > 1) for (let s = 0; s < r.length; s++)r[s].patchFlag = -2; return r }/*! #__NO_SIDE_EFFECTS__ */function ce(e, t) { return J(e) ? Ie({ name: e.name }, t, { setup: e }) : e } function Mi() { const e = vn(); return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : "" } function Ri(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function mr(e, t, n, r, o = !1) { if (Q(e)) { e.forEach((g, p) => mr(g, t && (Q(t) ? t[p] : t), n, r, o)); return } if (pn(r) && !o) { r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && mr(e, t, n, r.component.subTree); return } const s = r.shapeFlag & 4 ? Ho(r.component) : r.el, i = o ? null : s, { i: l, r: a } = e, u = t && t.r, c = l.refs === pe ? l.refs = {} : l.refs, f = l.setupState, d = ae(f), h = f === pe ? () => !1 : g => ue(d, g); if (u != null && u !== a && (_e(u) ? (c[u] = null, h(u) && (f[u] = null)) : Ee(u) && (u.value = null)), J(a)) Cr(a, l, 12, [i, c]); else { const g = _e(a), p = Ee(a); if (g || p) { const b = () => { if (e.f) { const _ = g ? h(a) ? f[a] : c[a] : a.value; o ? Q(_) && Si(_, s) : Q(_) ? _.includes(s) || _.push(s) : g ? (c[a] = [s], h(a) && (f[a] = c[a])) : (a.value = [s], e.k && (c[e.k] = a.value)) } else g ? (c[a] = i, h(a) && (f[a] = i)) : p && (a.value = i, e.k && (c[e.k] = i)) }; i ? (b.id = -1, De(b, n)) : b() } } } let _l = !1; const Sn = () => { _l || (console.error("Hydration completed but contains mismatches."), _l = !0) }, dp = e => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject", pp = e => e.namespaceURI.includes("MathML"), Hr = e => { if (e.nodeType === 1) { if (dp(e)) return "svg"; if (pp(e)) return "mathml" } }, En = e => e.nodeType === 8; function hp(e) {
  const { mt: t, p: n, o: { patchProp: r, createText: o, nextSibling: s, parentNode: i, remove: l, insert: a, createComment: u } } = e, c = (y, w) => { if (!w.hasChildNodes()) { n(null, y, w), fo(), w._vnode = y; return } f(w.firstChild, y, null, null, null), fo(), w._vnode = y }, f = (y, w, S, k, M, D = !1) => { D = D || !!w.dynamicChildren; const A = En(y) && y.data === "[", P = () => p(y, w, S, k, M, A), { type: W, ref: T, shapeFlag: U, patchFlag: te } = w; let oe = y.nodeType; w.el = y, te === -2 && (D = !1, w.dynamicChildren = null); let F = null; switch (W) { case gn: oe !== 3 ? w.children === "" ? (a(w.el = o(""), i(y), y), F = y) : F = P() : (y.data !== w.children && (Sn(), y.data = w.children), F = s(y)); break; case Oe: C(y) ? (F = s(y), _(w.el = y.content.firstChild, y, S)) : oe !== 8 || A ? F = P() : F = s(y); break; case Qr: if (A && (y = s(y), oe = y.nodeType), oe === 1 || oe === 3) { F = y; const Z = !w.children.length; for (let q = 0; q < w.staticCount; q++)Z && (w.children += F.nodeType === 1 ? F.outerHTML : F.data), q === w.staticCount - 1 && (w.anchor = F), F = s(F); return A ? s(F) : F } else P(); break; case ke: A ? F = g(y, w, S, k, M, D) : F = P(); break; default: if (U & 1) (oe !== 1 || w.type.toLowerCase() !== y.tagName.toLowerCase()) && !C(y) ? F = P() : F = d(y, w, S, k, M, D); else if (U & 6) { w.slotScopeIds = M; const Z = i(y); if (A ? F = b(y) : En(y) && y.data === "teleport start" ? F = b(y, y.data, "teleport end") : F = s(y), t(w, Z, null, S, k, Hr(Z), D), pn(w) && !w.type.__asyncResolved) { let q; A ? (q = z(ke), q.anchor = F ? F.previousSibling : Z.lastChild) : q = y.nodeType === 3 ? ne("") : z("div"), q.el = y, w.component.subTree = q } } else U & 64 ? oe !== 8 ? F = P() : F = w.type.hydrate(y, w, S, k, M, D, e, h) : U & 128 && (F = w.type.hydrate(y, w, S, k, Hr(i(y)), M, D, e, f)) }return T != null && mr(T, null, k, w), F }, d = (y, w, S, k, M, D) => {
    D = D || !!w.dynamicChildren; const { type: A, props: P, patchFlag: W, shapeFlag: T, dirs: U, transition: te } = w, oe = A === "input" || A === "option"; if (oe || W !== -1) {
      U && bt(w, null, S, "created"); let F = !1; if (C(y)) { F = iu(null, te) && S && S.vnode.props && S.vnode.props.appear; const q = y.content.firstChild; F && te.beforeEnter(q), _(q, y, S), w.el = y = q } if (T & 16 && !(P && (P.innerHTML || P.textContent))) { let q = h(y.firstChild, w, y, S, k, M, D); for (; q;) { Dr(y, 1) || Sn(); const ge = q; q = q.nextSibling, l(ge) } } else if (T & 8) {
        let q = w.children; q[0] === `
`&& (y.tagName === "PRE" || y.tagName === "TEXTAREA") && (q = q.slice(1)), y.textContent !== q && (Dr(y, 0) || Sn(), y.textContent = w.children)
      } if (P) { if (oe || !D || W & 48) { const q = y.tagName.includes("-"); for (const ge in P) (oe && (ge.endsWith("value") || ge === "indeterminate") || Sr(ge) && !Pn(ge) || ge[0] === "." || q) && r(y, ge, null, P[ge], void 0, S) } else if (P.onClick) r(y, "onClick", null, P.onClick, void 0, S); else if (W & 4 && dn(P.style)) for (const q in P.style) P.style[q] } let Z; (Z = P && P.onVnodeBeforeMount) && nt(Z, S, w), U && bt(w, null, S, "beforeMount"), ((Z = P && P.onVnodeMounted) || U || F) && du(() => { Z && nt(Z, S, w), F && te.enter(y), U && bt(w, null, S, "mounted") }, k)
    } return y.nextSibling
  }, h = (y, w, S, k, M, D, A) => { A = A || !!w.dynamicChildren; const P = w.children, W = P.length; for (let T = 0; T < W; T++) { const U = A ? P[T] : P[T] = Ye(P[T]), te = U.type === gn; y ? (te && !A && T + 1 < W && Ye(P[T + 1]).type === gn && (a(o(y.data.slice(U.children.length)), S, s(y)), y.data = U.children), y = f(y, U, k, M, D, A)) : te && !U.children ? a(U.el = o(""), S) : (Dr(S, 1) || Sn(), n(null, U, S, null, k, M, Hr(S), D)) } return y }, g = (y, w, S, k, M, D) => { const { slotScopeIds: A } = w; A && (M = M ? M.concat(A) : A); const P = i(y), W = h(s(y), w, P, S, k, M, D); return W && En(W) && W.data === "]" ? s(w.anchor = W) : (Sn(), a(w.anchor = u("]"), P, W), W) }, p = (y, w, S, k, M, D) => { if (Dr(y.parentElement, 1) || Sn(), w.el = null, D) { const W = b(y); for (; ;) { const T = s(y); if (T && T !== W) l(T); else break } } const A = s(y), P = i(y); return l(y), n(null, w, P, A, S, k, Hr(P), M), S && (S.vnode.el = w.el, Bo(S, w.el)), A }, b = (y, w = "[", S = "]") => { let k = 0; for (; y;)if (y = s(y), y && En(y) && (y.data === w && k++, y.data === S)) { if (k === 0) return s(y); k-- } return y }, _ = (y, w, S) => { const k = w.parentNode; k && k.replaceChild(y, w); let M = S; for (; M;)M.vnode.el === w && (M.vnode.el = M.subTree.el = y), M = M.parent }, C = y => y.nodeType === 1 && y.tagName === "TEMPLATE"; return [c, f]
} const Sl = "data-allow-mismatch", gp = { 0: "text", 1: "children", 2: "class", 3: "style", 4: "attribute" }; function Dr(e, t) { if (t === 0 || t === 1) for (; e && !e.hasAttribute(Sl);)e = e.parentElement; const n = e && e.getAttribute(Sl); if (n == null) return !1; if (n === "") return !0; { const r = n.split(","); return t === 0 && r.includes("children") ? !0 : n.split(",").includes(gp[t]) } } Io().requestIdleCallback; Io().cancelIdleCallback; function mp(e, t) { if (En(e) && e.data === "[") { let n = 1, r = e.nextSibling; for (; r;) { if (r.nodeType === 1) { if (t(r) === !1) break } else if (En(r)) if (r.data === "]") { if (--n === 0) break } else r.data === "[" && n++; r = r.nextSibling } } else t(e) } const pn = e => !!e.type.__asyncLoader;/*! #__NO_SIDE_EFFECTS__ */function Ms(e) { J(e) && (e = { loader: e }); const { loader: t, loadingComponent: n, errorComponent: r, delay: o = 200, hydrate: s, timeout: i, suspensible: l = !0, onError: a } = e; let u = null, c, f = 0; const d = () => (f++, u = null, h()), h = () => { let g; return u || (g = u = t().catch(p => { if (p = p instanceof Error ? p : new Error(String(p)), a) return new Promise((b, _) => { a(p, () => b(d()), () => _(p), f + 1) }); throw p }).then(p => g !== u && u ? u : (p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), c = p, p))) }; return ce({ name: "AsyncComponentWrapper", __asyncLoader: h, __asyncHydrate(g, p, b) { const _ = s ? () => { const C = s(b, y => mp(g, y)); C && (p.bum || (p.bum = [])).push(C) } : b; c ? _() : h().then(() => !p.isUnmounted && _()) }, get __asyncResolved() { return c }, setup() { const g = Ae; if (Ri(g), c) return () => ls(c, g); const p = y => { u = null, Nn(y, g, 13, !r) }; if (l && g.suspense || Rn) return h().then(y => () => ls(y, g)).catch(y => (p(y), () => r ? z(r, { error: y }) : null)); const b = G(!1), _ = G(), C = G(!!o); return o && setTimeout(() => { C.value = !1 }, o), i != null && setTimeout(() => { if (!b.value && !_.value) { const y = new Error(`Async component timed out after ${i}ms.`); p(y), _.value = y } }, i), h().then(() => { b.value = !0, g.parent && kr(g.parent.vnode) && g.parent.update() }).catch(y => { p(y), _.value = y }), () => { if (b.value && c) return ls(c, g); if (_.value && r) return z(r, { error: _.value }); if (n && !C.value) return z(n) } } }) } function ls(e, t) { const { ref: n, props: r, children: o, ce: s } = t.vnode, i = z(e, r, o); return i.ref = n, i.ce = s, delete t.vnode.ce, i } const kr = e => e.type.__isKeepAlive; function Nc(e, t) { Bc(e, "a", t) } function Fc(e, t) { Bc(e, "da", t) } function Bc(e, t, n = Ae) { const r = e.__wdc || (e.__wdc = () => { let o = n; for (; o;) { if (o.isDeactivated) return; o = o.parent } return e() }); if (Ro(t, r, n), n) { let o = n.parent; for (; o && o.parent;)kr(o.parent.vnode) && yp(r, t, n, o), o = o.parent } } function yp(e, t, n, r) { const o = Ro(t, e, r, !0); Ve(() => { Si(r[t], o) }, n) } function Ro(e, t, n = Ae, r = !1) { if (n) { const o = n[e] || (n[e] = []), s = t.__weh || (t.__weh = (...i) => { Yt(); const l = Er(n), a = ft(t, n, e, i); return l(), Xt(), a }); return r ? o.unshift(s) : o.push(s), s } } const jt = e => (t, n = Ae) => { (!Rn || e === "sp") && Ro(e, (...r) => t(...r), n) }, bp = jt("bm"), Te = jt("m"), vp = jt("bu"), wp = jt("u"), jo = jt("bum"), Ve = jt("um"), xp = jt("sp"), _p = jt("rtg"), Sp = jt("rtc"); function Hc(e, t = Ae) { Ro("ec", e, t) } const Dc = "components"; function It(e, t) { return qc(Dc, e, !0, t) || e } const Uc = Symbol.for("v-ndc"); function zc(e) { return _e(e) ? qc(Dc, e, !1) || e : e || Uc } function qc(e, t, n = !0, r = !1) { const o = Pe || Ae; if (o) { const s = o.type; { const l = fh(s, !1); if (l && (l === t || l === st(t) || l === Oo(st(t)))) return s } const i = Cl(o[e] || s[e], t) || Cl(o.appContext[e], t); return !i && r ? s : i } } function Cl(e, t) { return e && (e[t] || e[st(t)] || e[Oo(st(t))]) } function ho(e, t, n, r) { let o; const s = n, i = Q(e); if (i || _e(e)) { const l = i && dn(e); let a = !1; l && (a = !rt(e), e = Mo(e)), o = new Array(e.length); for (let u = 0, c = e.length; u < c; u++)o[u] = t(a ? Ne(e[u]) : e[u], u, void 0, s) } else if (typeof e == "number") { o = new Array(e); for (let l = 0; l < e; l++)o[l] = t(l + 1, l, void 0, s) } else if (be(e)) if (e[Symbol.iterator]) o = Array.from(e, (l, a) => t(l, a, void 0, s)); else { const l = Object.keys(e); o = new Array(l.length); for (let a = 0, u = l.length; a < u; a++) { const c = l[a]; o[a] = t(e[c], c, a, s) } } else o = []; return o } function Xe(e, t, n = {}, r, o) { if (Pe.ce || Pe.parent && pn(Pe.parent) && Pe.parent.ce) return t !== "default" && (n.name = t), se(), Ce(ke, null, [z("slot", n, r && r())], 64); let s = e[t]; s && s._c && (s._d = !1), se(); const i = s && Wc(s(n)), l = n.key || i && i.key, a = Ce(ke, { key: (l && !Rt(l) ? l : `_${t}`) + (!i && r ? "_fb" : "") }, i || (r ? r() : []), i && e._ === 1 ? 64 : -2); return a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a } function Wc(e) { return e.some(t => Mn(t) ? !(t.type === Oe || t.type === ke && !Wc(t.children)) : !0) ? e : null } const Rs = e => e ? mu(e) ? Ho(e) : Rs(e.parent) : null, lr = Ie(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => Rs(e.parent), $root: e => Rs(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => Kc(e), $forceUpdate: e => e.f || (e.f = () => { Li(e.update) }), $nextTick: e => e.n || (e.n = Ii.bind(e.proxy)), $watch: e => qp.bind(e) }), as = (e, t) => e !== pe && !e.__isScriptSetup && ue(e, t), Cp = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: n, setupState: r, data: o, props: s, accessCache: i, type: l, appContext: a } = e; let u; if (t[0] !== "$") { const h = i[t]; if (h !== void 0) switch (h) { case 1: return r[t]; case 2: return o[t]; case 4: return n[t]; case 3: return s[t] } else { if (as(r, t)) return i[t] = 1, r[t]; if (o !== pe && ue(o, t)) return i[t] = 2, o[t]; if ((u = e.propsOptions[0]) && ue(u, t)) return i[t] = 3, s[t]; if (n !== pe && ue(n, t)) return i[t] = 4, n[t]; js && (i[t] = 0) } } const c = lr[t]; let f, d; if (c) return t === "$attrs" && je(e.attrs, "get", ""), c(e); if ((f = l.__cssModules) && (f = f[t])) return f; if (n !== pe && ue(n, t)) return i[t] = 4, n[t]; if (d = a.config.globalProperties, ue(d, t)) return d[t] }, set({ _: e }, t, n) { const { data: r, setupState: o, ctx: s } = e; return as(o, t) ? (o[t] = n, !0) : r !== pe && ue(r, t) ? (r[t] = n, !0) : ue(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (s[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: r, appContext: o, propsOptions: s } }, i) { let l; return !!n[i] || e !== pe && ue(e, i) || as(t, i) || (l = s[0]) && ue(l, i) || ue(r, i) || ue(lr, i) || ue(o.config.globalProperties, i) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : ue(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; function Vc() { return kp().attrs } function kp() { const e = vn(); return e.setupContext || (e.setupContext = bu(e)) } function kl(e) { return Q(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e } let js = !0; function Ep(e) { const t = Kc(e), n = e.proxy, r = e.ctx; js = !1, t.beforeCreate && El(t.beforeCreate, e, "bc"); const { data: o, computed: s, methods: i, watch: l, provide: a, inject: u, created: c, beforeMount: f, mounted: d, beforeUpdate: h, updated: g, activated: p, deactivated: b, beforeDestroy: _, beforeUnmount: C, destroyed: y, unmounted: w, render: S, renderTracked: k, renderTriggered: M, errorCaptured: D, serverPrefetch: A, expose: P, inheritAttrs: W, components: T, directives: U, filters: te } = t; if (u && Tp(u, r, null), i) for (const Z in i) { const q = i[Z]; J(q) && (r[Z] = q.bind(n)) } if (o) { const Z = o.call(n, n); be(Z) && (e.data = ut(Z)) } if (js = !0, s) for (const Z in s) { const q = s[Z], ge = J(q) ? q.bind(n, n) : J(q.get) ? q.get.bind(n, n) : xt, ht = !J(q) && J(q.set) ? q.set.bind(n) : xt, ee = R({ get: ge, set: ht }); Object.defineProperty(r, Z, { enumerable: !0, configurable: !0, get: () => ee.value, set: le => ee.value = le }) } if (l) for (const Z in l) Gc(l[Z], r, n, Z); if (a) { const Z = J(a) ? a.call(n) : a; Reflect.ownKeys(Z).forEach(q => { Me(q, Z[q]) }) } c && El(c, e, "c"); function F(Z, q) { Q(q) ? q.forEach(ge => Z(ge.bind(n))) : q && Z(q.bind(n)) } if (F(bp, f), F(Te, d), F(vp, h), F(wp, g), F(Nc, p), F(Fc, b), F(Hc, D), F(Sp, k), F(_p, M), F(jo, C), F(Ve, w), F(xp, A), Q(P)) if (P.length) { const Z = e.exposed || (e.exposed = {}); P.forEach(q => { Object.defineProperty(Z, q, { get: () => n[q], set: ge => n[q] = ge }) }) } else e.exposed || (e.exposed = {}); S && e.render === xt && (e.render = S), W != null && (e.inheritAttrs = W), T && (e.components = T), U && (e.directives = U), A && Ri(e) } function Tp(e, t, n = xt) { Q(e) && (e = Ns(e)); for (const r in e) { const o = e[r]; let s; be(o) ? "default" in o ? s = Se(o.from || r, o.default, !0) : s = Se(o.from || r) : s = Se(o), Ee(s) ? Object.defineProperty(t, r, { enumerable: !0, configurable: !0, get: () => s.value, set: i => s.value = i }) : t[r] = s } } function El(e, t, n) { ft(Q(e) ? e.map(r => r.bind(t.proxy)) : e.bind(t.proxy), t, n) } function Gc(e, t, n, r) { let o = r.includes(".") ? au(n, r) : () => n[r]; if (_e(e)) { const s = t[e]; J(s) && We(o, s) } else if (J(e)) We(o, e.bind(n)); else if (be(e)) if (Q(e)) e.forEach(s => Gc(s, t, n, r)); else { const s = J(e.handler) ? e.handler.bind(n) : t[e.handler]; J(s) && We(o, s, e) } } function Kc(e) { const t = e.type, { mixins: n, extends: r } = t, { mixins: o, optionsCache: s, config: { optionMergeStrategies: i } } = e.appContext, l = s.get(t); let a; return l ? a = l : !o.length && !n && !r ? a = t : (a = {}, o.length && o.forEach(u => go(a, u, i, !0)), go(a, t, i)), be(t) && s.set(t, a), a } function go(e, t, n, r = !1) { const { mixins: o, extends: s } = t; s && go(e, s, n, !0), o && o.forEach(i => go(e, i, n, !0)); for (const i in t) if (!(r && i === "expose")) { const l = Ap[i] || n && n[i]; e[i] = l ? l(e[i], t[i]) : t[i] } return e } const Ap = { data: Tl, props: Al, emits: Al, methods: tr, computed: tr, beforeCreate: He, created: He, beforeMount: He, mounted: He, beforeUpdate: He, updated: He, beforeDestroy: He, beforeUnmount: He, destroyed: He, unmounted: He, activated: He, deactivated: He, errorCaptured: He, serverPrefetch: He, components: tr, directives: tr, watch: $p, provide: Tl, inject: Pp }; function Tl(e, t) { return t ? e ? function () { return Ie(J(e) ? e.call(this, this) : e, J(t) ? t.call(this, this) : t) } : t : e } function Pp(e, t) { return tr(Ns(e), Ns(t)) } function Ns(e) { if (Q(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function He(e, t) { return e ? [...new Set([].concat(e, t))] : t } function tr(e, t) { return e ? Ie(Object.create(null), e, t) : t } function Al(e, t) { return e ? Q(e) && Q(t) ? [...new Set([...e, ...t])] : Ie(Object.create(null), kl(e), kl(t ?? {})) : t } function $p(e, t) { if (!e) return t; if (!t) return e; const n = Ie(Object.create(null), e); for (const r in t) n[r] = He(e[r], t[r]); return n } function Jc() { return { app: null, config: { isNativeTag: md, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let Op = 0; function Ip(e, t) { return function (r, o = null) { J(r) || (r = Ie({}, r)), o != null && !be(o) && (o = null); const s = Jc(), i = new WeakSet, l = []; let a = !1; const u = s.app = { _uid: Op++, _component: r, _props: o, _container: null, _context: s, _instance: null, version: ph, get config() { return s.config }, set config(c) { }, use(c, ...f) { return i.has(c) || (c && J(c.install) ? (i.add(c), c.install(u, ...f)) : J(c) && (i.add(c), c(u, ...f))), u }, mixin(c) { return s.mixins.includes(c) || s.mixins.push(c), u }, component(c, f) { return f ? (s.components[c] = f, u) : s.components[c] }, directive(c, f) { return f ? (s.directives[c] = f, u) : s.directives[c] }, mount(c, f, d) { if (!a) { const h = u._ceVNode || z(r, o); return h.appContext = s, d === !0 ? d = "svg" : d === !1 && (d = void 0), f && t ? t(h, c) : e(h, c, d), a = !0, u._container = c, c.__vue_app__ = u, Ho(h.component) } }, onUnmount(c) { l.push(c) }, unmount() { a && (ft(l, u._instance, 16), e(null, u._container), delete u._container.__vue_app__) }, provide(c, f) { return s.provides[c] = f, u }, runWithContext(c) { const f = hn; hn = u; try { return c() } finally { hn = f } } }; return u } } let hn = null; function Me(e, t) { if (Ae) { let n = Ae.provides; const r = Ae.parent && Ae.parent.provides; r === n && (n = Ae.provides = Object.create(r)), n[e] = t } } function Se(e, t, n = !1) { const r = Ae || Pe; if (r || hn) { const o = hn ? hn._context.provides : r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0; if (o && e in o) return o[e]; if (arguments.length > 1) return n && J(t) ? t.call(r && r.proxy) : t } } function No() { return !!(Ae || Pe || hn) } const Zc = {}, Qc = () => Object.create(Zc), Yc = e => Object.getPrototypeOf(e) === Zc; function Lp(e, t, n, r = !1) { const o = {}, s = Qc(); e.propsDefaults = Object.create(null), Xc(e, t, o, s); for (const i in e.propsOptions[0]) i in o || (o[i] = void 0); n ? e.props = r ? o : kn(o) : e.type.props ? e.props = o : e.props = s, e.attrs = s } function Mp(e, t, n, r) { const { props: o, attrs: s, vnode: { patchFlag: i } } = e, l = ae(o), [a] = e.propsOptions; let u = !1; if ((r || i > 0) && !(i & 16)) { if (i & 8) { const c = e.vnode.dynamicProps; for (let f = 0; f < c.length; f++) { let d = c[f]; if (Fo(e.emitsOptions, d)) continue; const h = t[d]; if (a) if (ue(s, d)) h !== s[d] && (s[d] = h, u = !0); else { const g = st(d); o[g] = Fs(a, l, g, h, e, !1) } else h !== s[d] && (s[d] = h, u = !0) } } } else { Xc(e, t, o, s) && (u = !0); let c; for (const f in l) (!t || !ue(t, f) && ((c = Qt(f)) === f || !ue(t, c))) && (a ? n && (n[f] !== void 0 || n[c] !== void 0) && (o[f] = Fs(a, l, f, void 0, e, !0)) : delete o[f]); if (s !== l) for (const f in s) (!t || !ue(t, f)) && (delete s[f], u = !0) } u && Pt(e.attrs, "set", "") } function Xc(e, t, n, r) { const [o, s] = e.propsOptions; let i = !1, l; if (t) for (let a in t) { if (Pn(a)) continue; const u = t[a]; let c; o && ue(o, c = st(a)) ? !s || !s.includes(c) ? n[c] = u : (l || (l = {}))[c] = u : Fo(e.emitsOptions, a) || (!(a in r) || u !== r[a]) && (r[a] = u, i = !0) } if (s) { const a = ae(n), u = l || pe; for (let c = 0; c < s.length; c++) { const f = s[c]; n[f] = Fs(o, a, f, u[f], e, !ue(u, f)) } } return i } function Fs(e, t, n, r, o, s) { const i = e[n]; if (i != null) { const l = ue(i, "default"); if (l && r === void 0) { const a = i.default; if (i.type !== Function && !i.skipFactory && J(a)) { const { propsDefaults: u } = o; if (n in u) r = u[n]; else { const c = Er(o); r = u[n] = a.call(null, t), c() } } else r = a; o.ce && o.ce._setProp(n, r) } i[0] && (s && !l ? r = !1 : i[1] && (r === "" || r === Qt(n)) && (r = !0)) } return r } const Rp = new WeakMap; function eu(e, t, n = !1) { const r = n ? Rp : t.propsCache, o = r.get(e); if (o) return o; const s = e.props, i = {}, l = []; let a = !1; if (!J(e)) { const c = f => { a = !0; const [d, h] = eu(f, t, !0); Ie(i, d), h && l.push(...h) }; !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c) } if (!s && !a) return be(e) && r.set(e, Tn), Tn; if (Q(s)) for (let c = 0; c < s.length; c++) { const f = st(s[c]); Pl(f) && (i[f] = pe) } else if (s) for (const c in s) { const f = st(c); if (Pl(f)) { const d = s[c], h = i[f] = Q(d) || J(d) ? { type: d } : Ie({}, d), g = h.type; let p = !1, b = !0; if (Q(g)) for (let _ = 0; _ < g.length; ++_) { const C = g[_], y = J(C) && C.name; if (y === "Boolean") { p = !0; break } else y === "String" && (b = !1) } else p = J(g) && g.name === "Boolean"; h[0] = p, h[1] = b, (p || ue(h, "default")) && l.push(f) } } const u = [i, l]; return be(e) && r.set(e, u), u } function Pl(e) { return e[0] !== "$" && !Pn(e) } const tu = e => e[0] === "_" || e === "$stable", ji = e => Q(e) ? e.map(Ye) : [Ye(e)], jp = (e, t, n) => { if (t._n) return t; const r = X((...o) => ji(t(...o)), n); return r._c = !1, r }, nu = (e, t, n) => { const r = e._ctx; for (const o in e) { if (tu(o)) continue; const s = e[o]; if (J(s)) t[o] = jp(o, s, r); else if (s != null) { const i = ji(s); t[o] = () => i } } }, ru = (e, t) => { const n = ji(t); e.slots.default = () => n }, ou = (e, t, n) => { for (const r in t) (n || r !== "_") && (e[r] = t[r]) }, Np = (e, t, n) => { const r = e.slots = Qc(); if (e.vnode.shapeFlag & 32) { const o = t._; o ? (ou(r, t, n), n && ec(r, "_", o, !0)) : nu(t, r) } else t && ru(e, t) }, Fp = (e, t, n) => { const { vnode: r, slots: o } = e; let s = !0, i = pe; if (r.shapeFlag & 32) { const l = t._; l ? n && l === 1 ? s = !1 : ou(o, t, n) : (s = !t.$stable, nu(t, o)), i = t } else t && (ru(e, t), i = { default: 1 }); if (s) for (const l in o) !tu(l) && i[l] == null && delete o[l] }, De = du; function Bp(e) { return su(e) } function Hp(e) { return su(e, hp) } function su(e, t) { const n = Io(); n.__VUE__ = !0; const { insert: r, remove: o, patchProp: s, createElement: i, createText: l, createComment: a, setText: u, setElementText: c, parentNode: f, nextSibling: d, setScopeId: h = xt, insertStaticContent: g } = e, p = (v, x, E, I = null, $ = null, O = null, B = void 0, N = null, j = !!x.dynamicChildren) => { if (v === x) return; v && !vt(v, x) && (I = Mr(v), le(v, $, O, !0), v = null), x.patchFlag === -2 && (j = !1, x.dynamicChildren = null); const { type: L, ref: K, shapeFlag: H } = x; switch (L) { case gn: b(v, x, E, I); break; case Oe: _(v, x, E, I); break; case Qr: v == null && C(x, E, I, B); break; case ke: T(v, x, E, I, $, O, B, N, j); break; default: H & 1 ? S(v, x, E, I, $, O, B, N, j) : H & 6 ? U(v, x, E, I, $, O, B, N, j) : (H & 64 || H & 128) && L.process(v, x, E, I, $, O, B, N, j, xn) }K != null && $ && mr(K, v && v.ref, O, x || v, !x) }, b = (v, x, E, I) => { if (v == null) r(x.el = l(x.children), E, I); else { const $ = x.el = v.el; x.children !== v.children && u($, x.children) } }, _ = (v, x, E, I) => { v == null ? r(x.el = a(x.children || ""), E, I) : x.el = v.el }, C = (v, x, E, I) => { [v.el, v.anchor] = g(v.children, x, E, I, v.el, v.anchor) }, y = ({ el: v, anchor: x }, E, I) => { let $; for (; v && v !== x;)$ = d(v), r(v, E, I), v = $; r(x, E, I) }, w = ({ el: v, anchor: x }) => { let E; for (; v && v !== x;)E = d(v), o(v), v = E; o(x) }, S = (v, x, E, I, $, O, B, N, j) => { x.type === "svg" ? B = "svg" : x.type === "math" && (B = "mathml"), v == null ? k(x, E, I, $, O, B, N, j) : A(v, x, $, O, B, N, j) }, k = (v, x, E, I, $, O, B, N) => { let j, L; const { props: K, shapeFlag: H, transition: V, dirs: Y } = v; if (j = v.el = i(v.type, O, K && K.is, K), H & 8 ? c(j, v.children) : H & 16 && D(v.children, j, null, I, $, cs(v, O), B, N), Y && bt(v, null, I, "created"), M(j, v, v.scopeId, B, I), K) { for (const me in K) me !== "value" && !Pn(me) && s(j, me, null, K[me], O, I); "value" in K && s(j, "value", null, K.value, O), (L = K.onVnodeBeforeMount) && nt(L, I, v) } Y && bt(v, null, I, "beforeMount"); const ie = iu($, V); ie && V.beforeEnter(j), r(j, x, E), ((L = K && K.onVnodeMounted) || ie || Y) && De(() => { L && nt(L, I, v), ie && V.enter(j), Y && bt(v, null, I, "mounted") }, $) }, M = (v, x, E, I, $) => { if (E && h(v, E), I) for (let O = 0; O < I.length; O++)h(v, I[O]); if ($) { let O = $.subTree; if (x === O || uu(O.type) && (O.ssContent === x || O.ssFallback === x)) { const B = $.vnode; M(v, B, B.scopeId, B.slotScopeIds, $.parent) } } }, D = (v, x, E, I, $, O, B, N, j = 0) => { for (let L = j; L < v.length; L++) { const K = v[L] = N ? zt(v[L]) : Ye(v[L]); p(null, K, x, E, I, $, O, B, N) } }, A = (v, x, E, I, $, O, B) => { const N = x.el = v.el; let { patchFlag: j, dynamicChildren: L, dirs: K } = x; j |= v.patchFlag & 16; const H = v.props || pe, V = x.props || pe; let Y; if (E && tn(E, !1), (Y = V.onVnodeBeforeUpdate) && nt(Y, E, x, v), K && bt(x, v, E, "beforeUpdate"), E && tn(E, !0), (H.innerHTML && V.innerHTML == null || H.textContent && V.textContent == null) && c(N, ""), L ? P(v.dynamicChildren, L, N, E, I, cs(x, $), O) : B || q(v, x, N, null, E, I, cs(x, $), O, !1), j > 0) { if (j & 16) W(N, H, V, E, $); else if (j & 2 && H.class !== V.class && s(N, "class", null, V.class, $), j & 4 && s(N, "style", H.style, V.style, $), j & 8) { const ie = x.dynamicProps; for (let me = 0; me < ie.length; me++) { const fe = ie[me], Ke = H[fe], Re = V[fe]; (Re !== Ke || fe === "value") && s(N, fe, Ke, Re, $, E) } } j & 1 && v.children !== x.children && c(N, x.children) } else !B && L == null && W(N, H, V, E, $); ((Y = V.onVnodeUpdated) || K) && De(() => { Y && nt(Y, E, x, v), K && bt(x, v, E, "updated") }, I) }, P = (v, x, E, I, $, O, B) => { for (let N = 0; N < x.length; N++) { const j = v[N], L = x[N], K = j.el && (j.type === ke || !vt(j, L) || j.shapeFlag & 70) ? f(j.el) : E; p(j, L, K, null, I, $, O, B, !0) } }, W = (v, x, E, I, $) => { if (x !== E) { if (x !== pe) for (const O in x) !Pn(O) && !(O in E) && s(v, O, x[O], null, $, I); for (const O in E) { if (Pn(O)) continue; const B = E[O], N = x[O]; B !== N && O !== "value" && s(v, O, N, B, $, I) } "value" in E && s(v, "value", x.value, E.value, $) } }, T = (v, x, E, I, $, O, B, N, j) => { const L = x.el = v ? v.el : l(""), K = x.anchor = v ? v.anchor : l(""); let { patchFlag: H, dynamicChildren: V, slotScopeIds: Y } = x; Y && (N = N ? N.concat(Y) : Y), v == null ? (r(L, E, I), r(K, E, I), D(x.children || [], E, K, $, O, B, N, j)) : H > 0 && H & 64 && V && v.dynamicChildren ? (P(v.dynamicChildren, V, E, $, O, B, N), (x.key != null || $ && x === $.subTree) && Ni(v, x, !0)) : q(v, x, E, K, $, O, B, N, j) }, U = (v, x, E, I, $, O, B, N, j) => { x.slotScopeIds = N, v == null ? x.shapeFlag & 512 ? $.ctx.activate(x, E, I, B, j) : te(x, E, I, $, O, B, j) : oe(v, x, j) }, te = (v, x, E, I, $, O, B) => { const N = v.component = lh(v, I, $); if (kr(v) && (N.ctx.renderer = xn), ah(N, !1, B), N.asyncDep) { if ($ && $.registerDep(N, F, B), !v.el) { const j = N.subTree = z(Oe); _(null, j, x, E) } } else F(N, v, x, E, $, O, B) }, oe = (v, x, E) => { const I = x.component = v.component; if (Zp(v, x, E)) if (I.asyncDep && !I.asyncResolved) { Z(I, x, E); return } else I.next = x, I.update(); else x.el = v.el, I.vnode = x }, F = (v, x, E, I, $, O, B) => { const N = () => { if (v.isMounted) { let { next: H, bu: V, u: Y, parent: ie, vnode: me } = v; { const Je = lu(v); if (Je) { H && (H.el = me.el, Z(v, H, B)), Je.asyncDep.then(() => { v.isUnmounted || N() }); return } } let fe = H, Ke; tn(v, !1), H ? (H.el = me.el, Z(v, H, B)) : H = me, V && ts(V), (Ke = H.props && H.props.onVnodeBeforeUpdate) && nt(Ke, ie, H, me), tn(v, !0); const Re = us(v), at = v.subTree; v.subTree = Re, p(at, Re, f(at.el), Mr(at), v, $, O), H.el = Re.el, fe === null && Bo(v, Re.el), Y && De(Y, $), (Ke = H.props && H.props.onVnodeUpdated) && De(() => nt(Ke, ie, H, me), $) } else { let H; const { el: V, props: Y } = x, { bm: ie, m: me, parent: fe, root: Ke, type: Re } = v, at = pn(x); if (tn(v, !1), ie && ts(ie), !at && (H = Y && Y.onVnodeBeforeMount) && nt(H, fe, x), tn(v, !0), V && Xo) { const Je = () => { v.subTree = us(v), Xo(V, v.subTree, v, $, null) }; at && Re.__asyncHydrate ? Re.__asyncHydrate(V, v, Je) : Je() } else { Ke.ce && Ke.ce._injectChildStyle(Re); const Je = v.subTree = us(v); p(null, Je, E, I, v, $, O), x.el = Je.el } if (me && De(me, $), !at && (H = Y && Y.onVnodeMounted)) { const Je = x; De(() => nt(H, fe, Je), $) } (x.shapeFlag & 256 || fe && pn(fe.vnode) && fe.vnode.shapeFlag & 256) && v.a && De(v.a, $), v.isMounted = !0, x = E = I = null } }; v.scope.on(); const j = v.effect = new lc(N); v.scope.off(); const L = v.update = j.run.bind(j), K = v.job = j.runIfDirty.bind(j); K.i = v, K.id = v.uid, j.scheduler = () => Li(K), tn(v, !0), L() }, Z = (v, x, E) => { x.component = v; const I = v.vnode.props; v.vnode = x, v.next = null, Mp(v, x.props, I, E), Fp(v, x.children, E), Yt(), yl(v), Xt() }, q = (v, x, E, I, $, O, B, N, j = !1) => { const L = v && v.children, K = v ? v.shapeFlag : 0, H = x.children, { patchFlag: V, shapeFlag: Y } = x; if (V > 0) { if (V & 128) { ht(L, H, E, I, $, O, B, N, j); return } else if (V & 256) { ge(L, H, E, I, $, O, B, N, j); return } } Y & 8 ? (K & 16 && gt(L, $, O), H !== L && c(E, H)) : K & 16 ? Y & 16 ? ht(L, H, E, I, $, O, B, N, j) : gt(L, $, O, !0) : (K & 8 && c(E, ""), Y & 16 && D(H, E, I, $, O, B, N, j)) }, ge = (v, x, E, I, $, O, B, N, j) => { v = v || Tn, x = x || Tn; const L = v.length, K = x.length, H = Math.min(L, K); let V; for (V = 0; V < H; V++) { const Y = x[V] = j ? zt(x[V]) : Ye(x[V]); p(v[V], Y, E, null, $, O, B, N, j) } L > K ? gt(v, $, O, !0, !1, H) : D(x, E, I, $, O, B, N, j, H) }, ht = (v, x, E, I, $, O, B, N, j) => { let L = 0; const K = x.length; let H = v.length - 1, V = K - 1; for (; L <= H && L <= V;) { const Y = v[L], ie = x[L] = j ? zt(x[L]) : Ye(x[L]); if (vt(Y, ie)) p(Y, ie, E, null, $, O, B, N, j); else break; L++ } for (; L <= H && L <= V;) { const Y = v[H], ie = x[V] = j ? zt(x[V]) : Ye(x[V]); if (vt(Y, ie)) p(Y, ie, E, null, $, O, B, N, j); else break; H--, V-- } if (L > H) { if (L <= V) { const Y = V + 1, ie = Y < K ? x[Y].el : I; for (; L <= V;)p(null, x[L] = j ? zt(x[L]) : Ye(x[L]), E, ie, $, O, B, N, j), L++ } } else if (L > V) for (; L <= H;)le(v[L], $, O, !0), L++; else { const Y = L, ie = L, me = new Map; for (L = ie; L <= V; L++) { const Ze = x[L] = j ? zt(x[L]) : Ye(x[L]); Ze.key != null && me.set(Ze.key, L) } let fe, Ke = 0; const Re = V - ie + 1; let at = !1, Je = 0; const Un = new Array(Re); for (L = 0; L < Re; L++)Un[L] = 0; for (L = Y; L <= H; L++) { const Ze = v[L]; if (Ke >= Re) { le(Ze, $, O, !0); continue } let mt; if (Ze.key != null) mt = me.get(Ze.key); else for (fe = ie; fe <= V; fe++)if (Un[fe - ie] === 0 && vt(Ze, x[fe])) { mt = fe; break } mt === void 0 ? le(Ze, $, O, !0) : (Un[mt - ie] = L + 1, mt >= Je ? Je = mt : at = !0, p(Ze, x[mt], E, null, $, O, B, N, j), Ke++) } const ul = at ? Dp(Un) : Tn; for (fe = ul.length - 1, L = Re - 1; L >= 0; L--) { const Ze = ie + L, mt = x[Ze], fl = Ze + 1 < K ? x[Ze + 1].el : I; Un[L] === 0 ? p(null, mt, E, fl, $, O, B, N, j) : at && (fe < 0 || L !== ul[fe] ? ee(mt, E, fl, 2) : fe--) } } }, ee = (v, x, E, I, $ = null) => { const { el: O, type: B, transition: N, children: j, shapeFlag: L } = v; if (L & 6) { ee(v.component.subTree, x, E, I); return } if (L & 128) { v.suspense.move(x, E, I); return } if (L & 64) { B.move(v, x, E, xn); return } if (B === ke) { r(O, x, E); for (let H = 0; H < j.length; H++)ee(j[H], x, E, I); r(v.anchor, x, E); return } if (B === Qr) { y(v, x, E); return } if (I !== 2 && L & 1 && N) if (I === 0) N.beforeEnter(O), r(O, x, E), De(() => N.enter(O), $); else { const { leave: H, delayLeave: V, afterLeave: Y } = N, ie = () => r(O, x, E), me = () => { H(O, () => { ie(), Y && Y() }) }; V ? V(O, ie, me) : me() } else r(O, x, E) }, le = (v, x, E, I = !1, $ = !1) => { const { type: O, props: B, ref: N, children: j, dynamicChildren: L, shapeFlag: K, patchFlag: H, dirs: V, cacheIndex: Y } = v; if (H === -2 && ($ = !1), N != null && mr(N, null, E, v, !0), Y != null && (x.renderCache[Y] = void 0), K & 256) { x.ctx.deactivate(v); return } const ie = K & 1 && V, me = !pn(v); let fe; if (me && (fe = B && B.onVnodeBeforeUnmount) && nt(fe, x, v), K & 6) Dn(v.component, E, I); else { if (K & 128) { v.suspense.unmount(E, I); return } ie && bt(v, null, x, "beforeUnmount"), K & 64 ? v.type.remove(v, x, E, xn, I) : L && !L.hasOnce && (O !== ke || H > 0 && H & 64) ? gt(L, x, E, !1, !0) : (O === ke && H & 384 || !$ && K & 16) && gt(j, x, E), I && Be(v) } (me && (fe = B && B.onVnodeUnmounted) || ie) && De(() => { fe && nt(fe, x, v), ie && bt(v, null, x, "unmounted") }, E) }, Be = v => { const { type: x, el: E, anchor: I, transition: $ } = v; if (x === ke) { ze(E, I); return } if (x === Qr) { w(v); return } const O = () => { o(E), $ && !$.persisted && $.afterLeave && $.afterLeave() }; if (v.shapeFlag & 1 && $ && !$.persisted) { const { leave: B, delayLeave: N } = $, j = () => B(E, O); N ? N(v.el, O, j) : j() } else O() }, ze = (v, x) => { let E; for (; v !== x;)E = d(v), o(v), v = E; o(x) }, Dn = (v, x, E) => { const { bum: I, scope: $, job: O, subTree: B, um: N, m: j, a: L } = v; $l(j), $l(L), I && ts(I), $.stop(), O && (O.flags |= 8, le(B, v, x, E)), N && De(N, x), De(() => { v.isUnmounted = !0 }, x), x && x.pendingBranch && !x.isUnmounted && v.asyncDep && !v.asyncResolved && v.suspenseId === x.pendingId && (x.deps--, x.deps === 0 && x.resolve()) }, gt = (v, x, E, I = !1, $ = !1, O = 0) => { for (let B = O; B < v.length; B++)le(v[B], x, E, I, $) }, Mr = v => { if (v.shapeFlag & 6) return Mr(v.component.subTree); if (v.shapeFlag & 128) return v.suspense.next(); const x = d(v.anchor || v.el), E = x && x[Ac]; return E ? d(E) : x }; let Qo = !1; const cl = (v, x, E) => { v == null ? x._vnode && le(x._vnode, null, null, !0) : p(x._vnode || null, v, x, null, null, null, E), x._vnode = v, Qo || (Qo = !0, yl(), fo(), Qo = !1) }, xn = { p, um: le, m: ee, r: Be, mt: te, mc: D, pc: q, pbc: P, n: Mr, o: e }; let Yo, Xo; return t && ([Yo, Xo] = t(xn)), { render: cl, hydrate: Yo, createApp: Ip(cl, Yo) } } function cs({ type: e, props: t }, n) { return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n } function tn({ effect: e, job: t }, n) { n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function iu(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function Ni(e, t, n = !1) { const r = e.children, o = t.children; if (Q(r) && Q(o)) for (let s = 0; s < r.length; s++) { const i = r[s]; let l = o[s]; l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = o[s] = zt(o[s]), l.el = i.el), !n && l.patchFlag !== -2 && Ni(i, l)), l.type === gn && (l.el = i.el) } } function Dp(e) { const t = e.slice(), n = [0]; let r, o, s, i, l; const a = e.length; for (r = 0; r < a; r++) { const u = e[r]; if (u !== 0) { if (o = n[n.length - 1], e[o] < u) { t[r] = o, n.push(r); continue } for (s = 0, i = n.length - 1; s < i;)l = s + i >> 1, e[n[l]] < u ? s = l + 1 : i = l; u < e[n[s]] && (s > 0 && (t[r] = n[s - 1]), n[s] = r) } } for (s = n.length, i = n[s - 1]; s-- > 0;)n[s] = i, i = t[i]; return n } function lu(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : lu(t) } function $l(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } const Up = Symbol.for("v-scx"), zp = () => Se(Up); function Ge(e, t) { return Fi(e, null, t) } function We(e, t, n) { return Fi(e, t, n) } function Fi(e, t, n = pe) { const { immediate: r, deep: o, flush: s, once: i } = n, l = Ie({}, n), a = t && r || !t && s !== "post"; let u; if (Rn) { if (s === "sync") { const h = zp(); u = h.__watcherHandles || (h.__watcherHandles = []) } else if (!a) { const h = () => { }; return h.stop = xt, h.resume = xt, h.pause = xt, h } } const c = Ae; l.call = (h, g, p) => ft(h, c, g, p); let f = !1; s === "post" ? l.scheduler = h => { De(h, c && c.suspense) } : s !== "sync" && (f = !0, l.scheduler = (h, g) => { g ? h() : Li(h) }), l.augmentJob = h => { t && (h.flags |= 4), f && (h.flags |= 2, c && (h.id = c.uid, h.i = c)) }; const d = rp(e, t, l); return Rn && (u ? u.push(d) : a && d()), d } function qp(e, t, n) { const r = this.proxy, o = _e(e) ? e.includes(".") ? au(r, e) : () => r[e] : e.bind(r, r); let s; J(t) ? s = t : (s = t.handler, n = t); const i = Er(this), l = Fi(o, s.bind(r), n); return i(), l } function au(e, t) { const n = t.split("."); return () => { let r = e; for (let o = 0; o < n.length && r; o++)r = r[n[o]]; return r } } const Wp = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${st(t)}Modifiers`] || e[`${Qt(t)}Modifiers`]; function Vp(e, t, ...n) { if (e.isUnmounted) return; const r = e.vnode.props || pe; let o = n; const s = t.startsWith("update:"), i = s && Wp(r, t.slice(7)); i && (i.trim && (o = n.map(c => _e(c) ? c.trim() : c)), i.number && (o = n.map(xd))); let l, a = r[l = es(t)] || r[l = es(st(t))]; !a && s && (a = r[l = es(Qt(t))]), a && ft(a, e, 6, o); const u = r[l + "Once"]; if (u) { if (!e.emitted) e.emitted = {}; else if (e.emitted[l]) return; e.emitted[l] = !0, ft(u, e, 6, o) } } function cu(e, t, n = !1) { const r = t.emitsCache, o = r.get(e); if (o !== void 0) return o; const s = e.emits; let i = {}, l = !1; if (!J(e)) { const a = u => { const c = cu(u, t, !0); c && (l = !0, Ie(i, c)) }; !n && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a) } return !s && !l ? (be(e) && r.set(e, null), null) : (Q(s) ? s.forEach(a => i[a] = null) : Ie(i, s), be(e) && r.set(e, i), i) } function Fo(e, t) { return !e || !Sr(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), ue(e, t[0].toLowerCase() + t.slice(1)) || ue(e, Qt(t)) || ue(e, t)) } function us(e) { const { type: t, vnode: n, proxy: r, withProxy: o, propsOptions: [s], slots: i, attrs: l, emit: a, render: u, renderCache: c, props: f, data: d, setupState: h, ctx: g, inheritAttrs: p } = e, b = po(e); let _, C; try { if (n.shapeFlag & 4) { const w = o || r, S = w; _ = Ye(u.call(S, w, c, f, h, d, g)), C = l } else { const w = t; _ = Ye(w.length > 1 ? w(f, { attrs: l, slots: i, emit: a }) : w(f, null)), C = t.props ? l : Kp(l) } } catch (w) { ar.length = 0, Nn(w, e, 1), _ = z(Oe) } let y = _; if (C && p !== !1) { const w = Object.keys(C), { shapeFlag: S } = y; w.length && S & 7 && (s && w.some(_i) && (C = Jp(C, s)), y = Mt(y, C, !1, !0)) } return n.dirs && (y = Mt(y, null, !1, !0), y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs), n.transition && gr(y, n.transition), _ = y, po(b), _ } function Gp(e, t = !0) { let n; for (let r = 0; r < e.length; r++) { const o = e[r]; if (Mn(o)) { if (o.type !== Oe || o.children === "v-if") { if (n) return; n = o } } else return } return n } const Kp = e => { let t; for (const n in e) (n === "class" || n === "style" || Sr(n)) && ((t || (t = {}))[n] = e[n]); return t }, Jp = (e, t) => { const n = {}; for (const r in e) (!_i(r) || !(r.slice(9) in t)) && (n[r] = e[r]); return n }; function Zp(e, t, n) { const { props: r, children: o, component: s } = e, { props: i, children: l, patchFlag: a } = t, u = s.emitsOptions; if (t.dirs || t.transition) return !0; if (n && a >= 0) { if (a & 1024) return !0; if (a & 16) return r ? Ol(r, i, u) : !!i; if (a & 8) { const c = t.dynamicProps; for (let f = 0; f < c.length; f++) { const d = c[f]; if (i[d] !== r[d] && !Fo(u, d)) return !0 } } } else return (o || l) && (!l || !l.$stable) ? !0 : r === i ? !1 : r ? i ? Ol(r, i, u) : !0 : !!i; return !1 } function Ol(e, t, n) { const r = Object.keys(t); if (r.length !== Object.keys(e).length) return !0; for (let o = 0; o < r.length; o++) { const s = r[o]; if (t[s] !== e[s] && !Fo(n, s)) return !0 } return !1 } function Bo({ vnode: e, parent: t }, n) { for (; t;) { const r = t.subTree; if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el), r === e) (e = t.vnode).el = n, t = t.parent; else break } } const uu = e => e.__isSuspense; let Bs = 0; const Qp = { name: "Suspense", __isSuspense: !0, process(e, t, n, r, o, s, i, l, a, u) { if (e == null) Xp(t, n, r, o, s, i, l, a, u); else { if (s && s.deps > 0 && !e.suspense.isInFallback) { t.suspense = e.suspense, t.suspense.vnode = t, t.el = e.el; return } eh(e, t, n, r, o, i, l, a, u) } }, hydrate: th, normalize: nh }, Yp = Qp; function yr(e, t) { const n = e.props && e.props[t]; J(n) && n() } function Xp(e, t, n, r, o, s, i, l, a) { const { p: u, o: { createElement: c } } = a, f = c("div"), d = e.suspense = fu(e, o, r, t, f, n, s, i, l, a); u(null, d.pendingBranch = e.ssContent, f, null, r, d, s, i), d.deps > 0 ? (yr(e, "onPending"), yr(e, "onFallback"), u(null, e.ssFallback, t, n, r, null, s, i), On(d, e.ssFallback)) : d.resolve(!1, !0) } function eh(e, t, n, r, o, s, i, l, { p: a, um: u, o: { createElement: c } }) { const f = t.suspense = e.suspense; f.vnode = t, t.el = e.el; const d = t.ssContent, h = t.ssFallback, { activeBranch: g, pendingBranch: p, isInFallback: b, isHydrating: _ } = f; if (p) f.pendingBranch = d, vt(d, p) ? (a(p, d, f.hiddenContainer, null, o, f, s, i, l), f.deps <= 0 ? f.resolve() : b && (_ || (a(g, h, n, r, o, null, s, i, l), On(f, h)))) : (f.pendingId = Bs++, _ ? (f.isHydrating = !1, f.activeBranch = p) : u(p, o, f), f.deps = 0, f.effects.length = 0, f.hiddenContainer = c("div"), b ? (a(null, d, f.hiddenContainer, null, o, f, s, i, l), f.deps <= 0 ? f.resolve() : (a(g, h, n, r, o, null, s, i, l), On(f, h))) : g && vt(d, g) ? (a(g, d, n, r, o, f, s, i, l), f.resolve(!0)) : (a(null, d, f.hiddenContainer, null, o, f, s, i, l), f.deps <= 0 && f.resolve())); else if (g && vt(d, g)) a(g, d, n, r, o, f, s, i, l), On(f, d); else if (yr(t, "onPending"), f.pendingBranch = d, d.shapeFlag & 512 ? f.pendingId = d.component.suspenseId : f.pendingId = Bs++, a(null, d, f.hiddenContainer, null, o, f, s, i, l), f.deps <= 0) f.resolve(); else { const { timeout: C, pendingId: y } = f; C > 0 ? setTimeout(() => { f.pendingId === y && f.fallback(h) }, C) : C === 0 && f.fallback(h) } } function fu(e, t, n, r, o, s, i, l, a, u, c = !1) { const { p: f, m: d, um: h, n: g, o: { parentNode: p, remove: b } } = u; let _; const C = rh(e); C && t && t.pendingBranch && (_ = t.pendingId, t.deps++); const y = e.props ? tc(e.props.timeout) : void 0, w = s, S = { vnode: e, parent: t, parentComponent: n, namespace: i, container: r, hiddenContainer: o, deps: 0, pendingId: Bs++, timeout: typeof y == "number" ? y : -1, activeBranch: null, pendingBranch: null, isInFallback: !c, isHydrating: c, isUnmounted: !1, effects: [], resolve(k = !1, M = !1) { const { vnode: D, activeBranch: A, pendingBranch: P, pendingId: W, effects: T, parentComponent: U, container: te } = S; let oe = !1; S.isHydrating ? S.isHydrating = !1 : k || (oe = A && P.transition && P.transition.mode === "out-in", oe && (A.transition.afterLeave = () => { W === S.pendingId && (d(P, te, s === w ? g(A) : s, 0), Os(T)) }), A && (p(A.el) === te && (s = g(A)), h(A, U, S, !0)), oe || d(P, te, s, 0)), On(S, P), S.pendingBranch = null, S.isInFallback = !1; let F = S.parent, Z = !1; for (; F;) { if (F.pendingBranch) { F.effects.push(...T), Z = !0; break } F = F.parent } !Z && !oe && Os(T), S.effects = [], C && t && t.pendingBranch && _ === t.pendingId && (t.deps--, t.deps === 0 && !M && t.resolve()), yr(D, "onResolve") }, fallback(k) { if (!S.pendingBranch) return; const { vnode: M, activeBranch: D, parentComponent: A, container: P, namespace: W } = S; yr(M, "onFallback"); const T = g(D), U = () => { S.isInFallback && (f(null, k, P, T, A, null, W, l, a), On(S, k)) }, te = k.transition && k.transition.mode === "out-in"; te && (D.transition.afterLeave = U), S.isInFallback = !0, h(D, A, null, !0), te || U() }, move(k, M, D) { S.activeBranch && d(S.activeBranch, k, M, D), S.container = k }, next() { return S.activeBranch && g(S.activeBranch) }, registerDep(k, M, D) { const A = !!S.pendingBranch; A && S.deps++; const P = k.vnode.el; k.asyncDep.catch(W => { Nn(W, k, 0) }).then(W => { if (k.isUnmounted || S.isUnmounted || S.pendingId !== k.suspenseId) return; k.asyncResolved = !0; const { vnode: T } = k; Ds(k, W), P && (T.el = P); const U = !P && k.subTree.el; M(k, T, p(P || k.subTree.el), P ? null : g(k.subTree), S, i, D), U && b(U), Bo(k, T.el), A && --S.deps === 0 && S.resolve() }) }, unmount(k, M) { S.isUnmounted = !0, S.activeBranch && h(S.activeBranch, n, k, M), S.pendingBranch && h(S.pendingBranch, n, k, M) } }; return S } function th(e, t, n, r, o, s, i, l, a) { const u = t.suspense = fu(t, r, n, e.parentNode, document.createElement("div"), null, o, s, i, l, !0), c = a(e, u.pendingBranch = t.ssContent, n, u, s, i); return u.deps === 0 && u.resolve(!1, !0), c } function nh(e) { const { shapeFlag: t, children: n } = e, r = t & 32; e.ssContent = Il(r ? n.default : n), e.ssFallback = r ? Il(n.fallback) : z(Oe) } function Il(e) { let t; if (J(e)) { const n = Ln && e._c; n && (e._d = !1, se()), e = e(), n && (e._d = !0, t = qe, pu()) } return Q(e) && (e = Gp(e)), e = Ye(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n => n !== e)), e } function du(e, t) { t && t.pendingBranch ? Q(e) ? t.effects.push(...e) : t.effects.push(e) : Os(e) } function On(e, t) { e.activeBranch = t; const { vnode: n, parentComponent: r } = e; let o = t.el; for (; !o && t.component;)t = t.component.subTree, o = t.el; n.el = o, r && r.subTree === n && (r.vnode.el = o, Bo(r, o)) } function rh(e) { const t = e.props && e.props.suspensible; return t != null && t !== !1 } const ke = Symbol.for("v-fgt"), gn = Symbol.for("v-txt"), Oe = Symbol.for("v-cmt"), Qr = Symbol.for("v-stc"), ar = []; let qe = null; function se(e = !1) { ar.push(qe = e ? null : []) } function pu() { ar.pop(), qe = ar[ar.length - 1] || null } let Ln = 1; function Ll(e, t = !1) { Ln += e, e < 0 && qe && t && (qe.hasOnce = !0) } function hu(e) { return e.dynamicChildren = Ln > 0 ? qe || Tn : null, pu(), Ln > 0 && qe && qe.push(e), e } function Fe(e, t, n, r, o, s) { return hu(m(e, t, n, r, o, s, !0)) } function Ce(e, t, n, r, o) { return hu(z(e, t, n, r, o, !0)) } function Mn(e) { return e ? e.__v_isVNode === !0 : !1 } function vt(e, t) { return e.type === t.type && e.key === t.key } const gu = ({ key: e }) => e ?? null, Yr = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? _e(e) || Ee(e) || J(e) ? { i: Pe, r: e, k: t, f: !!n } : e : null); function m(e, t = null, n = null, r = 0, o = null, s = e === ke ? 0 : 1, i = !1, l = !1) { const a = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && gu(t), ref: t && Yr(t), scopeId: Tc, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: s, patchFlag: r, dynamicProps: o, dynamicChildren: null, appContext: null, ctx: Pe }; return l ? (Bi(a, n), s & 128 && e.normalize(a)) : n && (a.shapeFlag |= _e(n) ? 8 : 16), Ln > 0 && !i && qe && (a.patchFlag > 0 || s & 6) && a.patchFlag !== 32 && qe.push(a), a } const z = oh; function oh(e, t = null, n = null, r = 0, o = null, s = !1) { if ((!e || e === Uc) && (e = Oe), Mn(e)) { const l = Mt(e, t, !0); return n && Bi(l, n), Ln > 0 && !s && qe && (l.shapeFlag & 6 ? qe[qe.indexOf(e)] = l : qe.push(l)), l.patchFlag = -2, l } if (dh(e) && (e = e.__vccOpts), t) { t = br(t); let { class: l, style: a } = t; l && !_e(l) && (t.class = $e(l)), be(a) && (Oi(a) && !Q(a) && (a = Ie({}, a)), t.style = Lo(a)) } const i = _e(e) ? 1 : uu(e) ? 128 : Pc(e) ? 64 : be(e) ? 4 : J(e) ? 2 : 0; return m(e, t, n, r, o, i, s, !0) } function br(e) { return e ? Oi(e) || Yc(e) ? Ie({}, e) : e : null } function Mt(e, t, n = !1, r = !1) { const { props: o, ref: s, patchFlag: i, children: l, transition: a } = e, u = t ? ot(o || {}, t) : o, c = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: u, key: u && gu(u), ref: t && t.ref ? n && s ? Q(s) ? s.concat(Yr(t)) : [s, Yr(t)] : Yr(t) : s, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: l, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== ke ? i === -1 ? 16 : i | 16 : i, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: a, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Mt(e.ssContent), ssFallback: e.ssFallback && Mt(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return a && r && gr(c, a.clone(c)), c } function ne(e = " ", t = 0) { return z(gn, null, e, t) } function Xr(e = "", t = !1) { return t ? (se(), Ce(Oe, null, e)) : z(Oe, null, e) } function Ye(e) { return e == null || typeof e == "boolean" ? z(Oe) : Q(e) ? z(ke, null, e.slice()) : Mn(e) ? zt(e) : z(gn, null, String(e)) } function zt(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Mt(e) } function Bi(e, t) { let n = 0; const { shapeFlag: r } = e; if (t == null) t = null; else if (Q(t)) n = 16; else if (typeof t == "object") if (r & 65) { const o = t.default; o && (o._c && (o._d = !1), Bi(e, o()), o._c && (o._d = !0)); return } else { n = 32; const o = t._; !o && !Yc(t) ? t._ctx = Pe : o === 3 && Pe && (Pe.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else J(t) ? (t = { default: t, _ctx: Pe }, n = 32) : (t = String(t), r & 64 ? (n = 16, t = [ne(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function ot(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n]; for (const o in r) if (o === "class") t.class !== r.class && (t.class = $e([t.class, r.class])); else if (o === "style") t.style = Lo([t.style, r.style]); else if (Sr(o)) { const s = t[o], i = r[o]; i && s !== i && !(Q(s) && s.includes(i)) && (t[o] = s ? [].concat(s, i) : i) } else o !== "" && (t[o] = r[o]) } return t } function nt(e, t, n, r = null) { ft(e, t, 7, [n, r]) } const sh = Jc(); let ih = 0; function lh(e, t, n) { const r = e.type, o = (t ? t.appContext : e.appContext) || sh, s = { uid: ih++, vnode: e, type: r, parent: t, appContext: o, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new sc(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(o.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: eu(r, o), emitsOptions: cu(r, o), emit: null, emitted: null, propsDefaults: pe, inheritAttrs: r.inheritAttrs, ctx: pe, data: pe, props: pe, attrs: pe, slots: pe, refs: pe, setupState: pe, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return s.ctx = { _: s }, s.root = t ? t.root : s, s.emit = Vp.bind(null, s), e.ce && e.ce(s), s } let Ae = null; const vn = () => Ae || Pe; let mo, Hs; { const e = Io(), t = (n, r) => { let o; return (o = e[n]) || (o = e[n] = []), o.push(r), s => { o.length > 1 ? o.forEach(i => i(s)) : o[0](s) } }; mo = t("__VUE_INSTANCE_SETTERS__", n => Ae = n), Hs = t("__VUE_SSR_SETTERS__", n => Rn = n) } const Er = e => { const t = Ae; return mo(e), e.scope.on(), () => { e.scope.off(), mo(t) } }, Ml = () => { Ae && Ae.scope.off(), mo(null) }; function mu(e) { return e.vnode.shapeFlag & 4 } let Rn = !1; function ah(e, t = !1, n = !1) { t && Hs(t); const { props: r, children: o } = e.vnode, s = mu(e); Lp(e, r, s, t), Np(e, o, n); const i = s ? ch(e, t) : void 0; return t && Hs(!1), i } function ch(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Cp); const { setup: r } = n; if (r) { Yt(); const o = e.setupContext = r.length > 1 ? bu(e) : null, s = Er(e), i = Cr(r, e, 0, [e.props, o]), l = Qa(i); if (Xt(), s(), (l || e.sp) && !pn(e) && Ri(e), l) { if (i.then(Ml, Ml), t) return i.then(a => { Ds(e, a) }).catch(a => { Nn(a, e, 0) }); e.asyncDep = i } else Ds(e, i) } else yu(e) } function Ds(e, t, n) { J(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : be(t) && (e.setupState = Sc(t)), yu(e) } function yu(e, t, n) { const r = e.type; e.render || (e.render = r.render || xt); { const o = Er(e); Yt(); try { Ep(e) } finally { Xt(), o() } } } const uh = { get(e, t) { return je(e, "get", ""), e[t] } }; function bu(e) { const t = n => { e.exposed = n || {} }; return { attrs: new Proxy(e.attrs, uh), slots: e.slots, emit: e.emit, expose: t } } function Ho(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Sc(Kd(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in lr) return lr[n](e) }, has(t, n) { return n in t || n in lr } })) : e.proxy } function fh(e, t = !0) { return J(e) ? e.displayName || e.name : e.name || t && e.__name } function dh(e) { return J(e) && "__vccOpts" in e } const R = (e, t) => tp(e, t, Rn); function xe(e, t, n) { const r = arguments.length; return r === 2 ? be(t) && !Q(t) ? Mn(t) ? z(e, null, [t]) : z(e, t) : z(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Mn(n) && (n = [n]), z(e, t, n)) } const ph = "3.5.13";/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Us; const Rl = typeof window < "u" && window.trustedTypes; if (Rl) try { Us = Rl.createPolicy("vue", { createHTML: e => e }) } catch { } const vu = Us ? e => Us.createHTML(e) : e => e, hh = "http://www.w3.org/2000/svg", gh = "http://www.w3.org/1998/Math/MathML", At = typeof document < "u" ? document : null, jl = At && At.createElement("template"), mh = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, r) => { const o = t === "svg" ? At.createElementNS(hh, e) : t === "mathml" ? At.createElementNS(gh, e) : n ? At.createElement(e, { is: n }) : At.createElement(e); return e === "select" && r && r.multiple != null && o.setAttribute("multiple", r.multiple), o }, createText: e => At.createTextNode(e), createComment: e => At.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => At.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, r, o, s) { const i = n ? n.previousSibling : t.lastChild; if (o && (o === s || o.nextSibling)) for (; t.insertBefore(o.cloneNode(!0), n), !(o === s || !(o = o.nextSibling));); else { jl.innerHTML = vu(r === "svg" ? `<svg>${e}</svg>` : r === "mathml" ? `<math>${e}</math>` : e); const l = jl.content; if (r === "svg" || r === "mathml") { const a = l.firstChild; for (; a.firstChild;)l.appendChild(a.firstChild); l.removeChild(a) } t.insertBefore(l, n) } return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, Ft = "transition", Wn = "animation", vr = Symbol("_vtc"), wu = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, yh = Ie({}, Ic, wu), bh = e => (e.displayName = "Transition", e.props = yh, e), vh = bh((e, { slots: t }) => xe(fp, wh(e), t)), nn = (e, t = []) => { Q(e) ? e.forEach(n => n(...t)) : e && e(...t) }, Nl = e => e ? Q(e) ? e.some(t => t.length > 1) : e.length > 1 : !1; function wh(e) { const t = {}; for (const T in e) T in wu || (t[T] = e[T]); if (e.css === !1) return t; const { name: n = "v", type: r, duration: o, enterFromClass: s = `${n}-enter-from`, enterActiveClass: i = `${n}-enter-active`, enterToClass: l = `${n}-enter-to`, appearFromClass: a = s, appearActiveClass: u = i, appearToClass: c = l, leaveFromClass: f = `${n}-leave-from`, leaveActiveClass: d = `${n}-leave-active`, leaveToClass: h = `${n}-leave-to` } = e, g = xh(o), p = g && g[0], b = g && g[1], { onBeforeEnter: _, onEnter: C, onEnterCancelled: y, onLeave: w, onLeaveCancelled: S, onBeforeAppear: k = _, onAppear: M = C, onAppearCancelled: D = y } = t, A = (T, U, te, oe) => { T._enterCancelled = oe, rn(T, U ? c : l), rn(T, U ? u : i), te && te() }, P = (T, U) => { T._isLeaving = !1, rn(T, f), rn(T, h), rn(T, d), U && U() }, W = T => (U, te) => { const oe = T ? M : C, F = () => A(U, T, te); nn(oe, [U, F]), Fl(() => { rn(U, T ? a : s), Ct(U, T ? c : l), Nl(oe) || Bl(U, r, p, F) }) }; return Ie(t, { onBeforeEnter(T) { nn(_, [T]), Ct(T, s), Ct(T, i) }, onBeforeAppear(T) { nn(k, [T]), Ct(T, a), Ct(T, u) }, onEnter: W(!1), onAppear: W(!0), onLeave(T, U) { T._isLeaving = !0; const te = () => P(T, U); Ct(T, f), T._enterCancelled ? (Ct(T, d), Ul()) : (Ul(), Ct(T, d)), Fl(() => { T._isLeaving && (rn(T, f), Ct(T, h), Nl(w) || Bl(T, r, b, te)) }), nn(w, [T, te]) }, onEnterCancelled(T) { A(T, !1, void 0, !0), nn(y, [T]) }, onAppearCancelled(T) { A(T, !0, void 0, !0), nn(D, [T]) }, onLeaveCancelled(T) { P(T), nn(S, [T]) } }) } function xh(e) { if (e == null) return null; if (be(e)) return [fs(e.enter), fs(e.leave)]; { const t = fs(e); return [t, t] } } function fs(e) { return tc(e) } function Ct(e, t) { t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e[vr] || (e[vr] = new Set)).add(t) } function rn(e, t) { t.split(/\s+/).forEach(r => r && e.classList.remove(r)); const n = e[vr]; n && (n.delete(t), n.size || (e[vr] = void 0)) } function Fl(e) { requestAnimationFrame(() => { requestAnimationFrame(e) }) } let _h = 0; function Bl(e, t, n, r) { const o = e._endId = ++_h, s = () => { o === e._endId && r() }; if (n != null) return setTimeout(s, n); const { type: i, timeout: l, propCount: a } = Sh(e, t); if (!i) return r(); const u = i + "end"; let c = 0; const f = () => { e.removeEventListener(u, d), s() }, d = h => { h.target === e && ++c >= a && f() }; setTimeout(() => { c < a && f() }, l + 1), e.addEventListener(u, d) } function Sh(e, t) { const n = window.getComputedStyle(e), r = g => (n[g] || "").split(", "), o = r(`${Ft}Delay`), s = r(`${Ft}Duration`), i = Hl(o, s), l = r(`${Wn}Delay`), a = r(`${Wn}Duration`), u = Hl(l, a); let c = null, f = 0, d = 0; t === Ft ? i > 0 && (c = Ft, f = i, d = s.length) : t === Wn ? u > 0 && (c = Wn, f = u, d = a.length) : (f = Math.max(i, u), c = f > 0 ? i > u ? Ft : Wn : null, d = c ? c === Ft ? s.length : a.length : 0); const h = c === Ft && /\b(transform|all)(,|$)/.test(r(`${Ft}Property`).toString()); return { type: c, timeout: f, propCount: d, hasTransform: h } } function Hl(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max(...t.map((n, r) => Dl(n) + Dl(e[r]))) } function Dl(e) { return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3 } function Ul() { return document.body.offsetHeight } function Ch(e, t, n) { const r = e[vr]; r && (t = (t ? [t, ...r] : [...r]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } const yo = Symbol("_vod"), xu = Symbol("_vsh"), kh = { beforeMount(e, { value: t }, { transition: n }) { e[yo] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Vn(e, t) }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e) }, updated(e, { value: t, oldValue: n }, { transition: r }) { !t != !n && (r ? t ? (r.beforeEnter(e), Vn(e, !0), r.enter(e)) : r.leave(e, () => { Vn(e, !1) }) : Vn(e, t)) }, beforeUnmount(e, { value: t }) { Vn(e, t) } }; function Vn(e, t) { e.style.display = t ? e[yo] : "none", e[xu] = !t } const Eh = Symbol(""), Th = /(^|;)\s*display\s*:/; function Ah(e, t, n) { const r = e.style, o = _e(n); let s = !1; if (n && !o) { if (t) if (_e(t)) for (const i of t.split(";")) { const l = i.slice(0, i.indexOf(":")).trim(); n[l] == null && eo(r, l, "") } else for (const i in t) n[i] == null && eo(r, i, ""); for (const i in n) i === "display" && (s = !0), eo(r, i, n[i]) } else if (o) { if (t !== n) { const i = r[Eh]; i && (n += ";" + i), r.cssText = n, s = Th.test(n) } } else t && e.removeAttribute("style"); yo in e && (e[yo] = s ? r.display : "", e[xu] && (r.display = "none")) } const zl = /\s*!important$/; function eo(e, t, n) { if (Q(n)) n.forEach(r => eo(e, t, r)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { const r = Ph(e, t); zl.test(n) ? e.setProperty(Qt(r), n.replace(zl, ""), "important") : e[r] = n } } const ql = ["Webkit", "Moz", "ms"], ds = {}; function Ph(e, t) { const n = ds[t]; if (n) return n; let r = st(t); if (r !== "filter" && r in e) return ds[t] = r; r = Oo(r); for (let o = 0; o < ql.length; o++) { const s = ql[o] + r; if (s in e) return ds[t] = s } return t } const Wl = "http://www.w3.org/1999/xlink"; function Vl(e, t, n, r, o, s = Td(t)) { r && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(Wl, t.slice(6, t.length)) : e.setAttributeNS(Wl, t, n) : n == null || s && !nc(n) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : Rt(n) ? String(n) : n) } function Gl(e, t, n, r, o) { if (t === "innerHTML" || t === "textContent") { n != null && (e[t] = t === "innerHTML" ? vu(n) : n); return } const s = e.tagName; if (t === "value" && s !== "PROGRESS" && !s.includes("-")) { const l = s === "OPTION" ? e.getAttribute("value") || "" : e.value, a = n == null ? e.type === "checkbox" ? "on" : "" : String(n); (l !== a || !("_value" in e)) && (e.value = a), n == null && e.removeAttribute(t), e._value = n; return } let i = !1; if (n === "" || n == null) { const l = typeof e[t]; l === "boolean" ? n = nc(n) : n == null && l === "string" ? (n = "", i = !0) : l === "number" && (n = 0, i = !0) } try { e[t] = n } catch { } i && e.removeAttribute(o || t) } function $h(e, t, n, r) { e.addEventListener(t, n, r) } function Oh(e, t, n, r) { e.removeEventListener(t, n, r) } const Kl = Symbol("_vei"); function Ih(e, t, n, r, o = null) { const s = e[Kl] || (e[Kl] = {}), i = s[t]; if (r && i) i.value = r; else { const [l, a] = Lh(t); if (r) { const u = s[t] = jh(r, o); $h(e, l, u, a) } else i && (Oh(e, l, i, a), s[t] = void 0) } } const Jl = /(?:Once|Passive|Capture)$/; function Lh(e) { let t; if (Jl.test(e)) { t = {}; let r; for (; r = e.match(Jl);)e = e.slice(0, e.length - r[0].length), t[r[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : Qt(e.slice(2)), t] } let ps = 0; const Mh = Promise.resolve(), Rh = () => ps || (Mh.then(() => ps = 0), ps = Date.now()); function jh(e, t) { const n = r => { if (!r._vts) r._vts = Date.now(); else if (r._vts <= n.attached) return; ft(Nh(r, n.value), t, 5, [r]) }; return n.value = e, n.attached = Rh(), n } function Nh(e, t) { if (Q(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(r => o => !o._stopped && r && r(o)) } else return t } const Zl = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, Fh = (e, t, n, r, o, s) => { const i = o === "svg"; t === "class" ? Ch(e, r, i) : t === "style" ? Ah(e, n, r) : Sr(t) ? _i(t) || Ih(e, t, n, r, s) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Bh(e, t, r, i)) ? (Gl(e, t, r), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && Vl(e, t, r, i, s, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !_e(r)) ? Gl(e, st(t), r, s, t) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r), Vl(e, t, r, i)) }; function Bh(e, t, n, r) { if (r) return !!(t === "innerHTML" || t === "textContent" || t in e && Zl(t) && J(n)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const o = e.tagName; if (o === "IMG" || o === "VIDEO" || o === "CANVAS" || o === "SOURCE") return !1 } return Zl(t) && _e(n) ? !1 : t in e } const Hh = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, Ql = (e, t) => { const n = e._withKeys || (e._withKeys = {}), r = t.join("."); return n[r] || (n[r] = o => { if (!("key" in o)) return; const s = Qt(o.key); if (t.some(i => i === s || Hh[i] === s)) return e(o) }) }, _u = Ie({ patchProp: Fh }, mh); let cr, Yl = !1; function Dh() { return cr || (cr = Bp(_u)) } function Uh() { return cr = Yl ? cr : Hp(_u), Yl = !0, cr } const zh = (...e) => { const t = Dh().createApp(...e), { mount: n } = t; return t.mount = r => { const o = Cu(r); if (!o) return; const s = t._component; !J(s) && !s.render && !s.template && (s.template = o.innerHTML), o.nodeType === 1 && (o.textContent = ""); const i = n(o, !1, Su(o)); return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), i }, t }, qh = (...e) => { const t = Uh().createApp(...e), { mount: n } = t; return t.mount = r => { const o = Cu(r); if (o) return n(o, !0, Su(o)) }, t }; function Su(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function Cu(e) { return _e(e) ? document.querySelector(e) : e } const Wh = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Vh = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, Gh = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/; function Kh(e, t) { if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype" in t) { Jh(e); return } return t } function Jh(e) { console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`) } function bo(e, t = {}) { if (typeof e != "string") return e; if (e[0] === '"' && e[e.length - 1] === '"' && e.indexOf("\\") === -1) return e.slice(1, -1); const n = e.trim(); if (n.length <= 9) switch (n.toLowerCase()) { case "true": return !0; case "false": return !1; case "undefined": return; case "null": return null; case "nan": return Number.NaN; case "infinity": return Number.POSITIVE_INFINITY; case "-infinity": return Number.NEGATIVE_INFINITY }if (!Gh.test(e)) { if (t.strict) throw new SyntaxError("[destr] Invalid JSON"); return e } try { if (Wh.test(e) || Vh.test(e)) { if (t.strict) throw new Error("[destr] Possible prototype pollution"); return JSON.parse(e, Kh) } return JSON.parse(e) } catch (r) { if (t.strict) throw r; return e } } const ku = /#/g, Eu = /&/g, Tu = /\//g, Zh = /=/g, Qh = /\?/g, Do = /\+/g, Yh = /%5e/gi, Xh = /%60/gi, eg = /%7c/gi, tg = /%20/gi, ng = /%252f/gi; function Au(e) { return encodeURI("" + e).replace(eg, "|") } function zs(e) { return Au(typeof e == "string" ? e : JSON.stringify(e)).replace(Do, "%2B").replace(tg, "+").replace(ku, "%23").replace(Eu, "%26").replace(Xh, "`").replace(Yh, "^").replace(Tu, "%2F") } function hs(e) { return zs(e).replace(Zh, "%3D") } function Pu(e) { return Au(e).replace(ku, "%23").replace(Qh, "%3F").replace(ng, "%2F").replace(Eu, "%26").replace(Do, "%2B") } function Xl(e) { return Pu(e).replace(Tu, "%2F") } function vo(e = "") { try { return decodeURIComponent("" + e) } catch { return "" + e } } function rg(e) { return vo(e.replace(Do, " ")) } function og(e) { return vo(e.replace(Do, " ")) } function Uo(e = "") { const t = Object.create(null); e[0] === "?" && (e = e.slice(1)); for (const n of e.split("&")) { const r = n.match(/([^=]+)=?(.*)/) || []; if (r.length < 2) continue; const o = rg(r[1]); if (o === "__proto__" || o === "constructor") continue; const s = og(r[2] || ""); t[o] === void 0 ? t[o] = s : Array.isArray(t[o]) ? t[o].push(s) : t[o] = [t[o], s] } return t } function sg(e, t) { return (typeof t == "number" || typeof t == "boolean") && (t = String(t)), t ? Array.isArray(t) ? t.map(n => `${hs(e)}=${zs(n)}`).join("&") : `${hs(e)}=${zs(t)}` : hs(e) } function $u(e) { return Object.keys(e).filter(t => e[t] !== void 0).map(t => sg(t, e[t])).filter(Boolean).join("&") } const ig = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/, lg = /^[\s\w\0+.-]{2,}:([/\\]{2})?/, ag = /^([/\\]\s*){2,}[^/\\]/, cg = /^[\s\0]*(blob|data|javascript|vbscript):$/i, ug = /\/$|\/\?|\/#/, fg = /^\.?\//; function _t(e, t = {}) { return typeof t == "boolean" && (t = { acceptRelative: t }), t.strict ? ig.test(e) : lg.test(e) || (t.acceptRelative ? ag.test(e) : !1) } function dg(e) { return !!e && cg.test(e) } function qs(e = "", t) { return t ? ug.test(e) : e.endsWith("/") } function zo(e = "", t) { if (!t) return (qs(e) ? e.slice(0, -1) : e) || "/"; if (!qs(e, !0)) return e || "/"; let n = e, r = ""; const o = e.indexOf("#"); o !== -1 && (n = e.slice(0, o), r = e.slice(o)); const [s, ...i] = n.split("?"); return ((s.endsWith("/") ? s.slice(0, -1) : s) || "/") + (i.length > 0 ? `?${i.join("?")}` : "") + r } function wo(e = "", t) { if (!t) return e.endsWith("/") ? e : e + "/"; if (qs(e, !0)) return e || "/"; let n = e, r = ""; const o = e.indexOf("#"); if (o !== -1 && (n = e.slice(0, o), r = e.slice(o), !n)) return r; const [s, ...i] = n.split("?"); return s + "/" + (i.length > 0 ? `?${i.join("?")}` : "") + r } function pg(e = "") { return e.startsWith("/") } function Ws(e = "") { return pg(e) ? e : "/" + e } function hg(e, t) { if (Iu(t) || _t(e)) return e; const n = zo(t); return e.startsWith(n) ? e : Jt(n, e) } function gg(e, t) { if (Iu(t)) return e; const n = zo(t); if (!e.startsWith(n)) return e; const r = e.slice(n.length); return r[0] === "/" ? r : "/" + r } function Ou(e, t) { const n = Hi(e), r = { ...Uo(n.search), ...t }; return n.search = $u(r), Ru(n) } function Iu(e) { return !e || e === "/" } function mg(e) { return e && e !== "/" } function Jt(e, ...t) { let n = e || ""; for (const r of t.filter(o => mg(o))) if (n) { const o = r.replace(fg, ""); n = wo(n) + o } else n = r; return n } function Lu(...e) { var i, l, a, u; const t = /\/(?!\/)/, n = e.filter(Boolean), r = []; let o = 0; for (const c of n) if (!(!c || c === "/")) { for (const [f, d] of c.split(t).entries()) if (!(!d || d === ".")) { if (d === "..") { if (r.length === 1 && _t(r[0])) continue; r.pop(), o--; continue } if (f === 1 && ((i = r[r.length - 1]) != null && i.endsWith(":/"))) { r[r.length - 1] += "/" + d; continue } r.push(d), o++ } } let s = r.join("/"); return o >= 0 ? (l = n[0]) != null && l.startsWith("/") && !s.startsWith("/") ? s = "/" + s : (a = n[0]) != null && a.startsWith("./") && !s.startsWith("./") && (s = "./" + s) : s = "../".repeat(-1 * o) + s, (u = n[n.length - 1]) != null && u.endsWith("/") && !s.endsWith("/") && (s += "/"), s } function yg(e, t, n = {}) { return n.trailingSlash || (e = wo(e), t = wo(t)), n.leadingSlash || (e = Ws(e), t = Ws(t)), n.encoding || (e = vo(e), t = vo(t)), e === t } const Mu = Symbol.for("ufo:protocolRelative"); function Hi(e = "", t) { const n = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i); if (n) { const [, f, d = ""] = n; return { protocol: f.toLowerCase(), pathname: d, href: f + d, auth: "", host: "", search: "", hash: "" } } if (!_t(e, { acceptRelative: !0 })) return ea(e); const [, r = "", o, s = ""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []; let [, i = "", l = ""] = s.match(/([^#/?]*)(.*)?/) || []; r === "file:" && (l = l.replace(/\/(?=[A-Za-z]:)/, "")); const { pathname: a, search: u, hash: c } = ea(l); return { protocol: r.toLowerCase(), auth: o ? o.slice(0, Math.max(0, o.length - 1)) : "", host: i, pathname: a, search: u, hash: c, [Mu]: !r } } function ea(e = "") { const [t = "", n = "", r = ""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1); return { pathname: t, search: n, hash: r } } function Ru(e) { const t = e.pathname || "", n = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : "", r = e.hash || "", o = e.auth ? e.auth + "@" : "", s = e.host || ""; return (e.protocol || e[Mu] ? (e.protocol || "") + "//" : "") + o + s + t + n + r } class bg extends Error { constructor(t, n) { super(t, n), this.name = "FetchError", n != null && n.cause && !this.cause && (this.cause = n.cause) } } function vg(e) { var a, u, c, f, d; const t = ((a = e.error) == null ? void 0 : a.message) || ((u = e.error) == null ? void 0 : u.toString()) || "", n = ((c = e.request) == null ? void 0 : c.method) || ((f = e.options) == null ? void 0 : f.method) || "GET", r = ((d = e.request) == null ? void 0 : d.url) || String(e.request) || "/", o = `[${n}] ${JSON.stringify(r)}`, s = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>", i = `${o}: ${s}${t ? ` ${t}` : ""}`, l = new bg(i, e.error ? { cause: e.error } : void 0); for (const h of ["request", "options", "response"]) Object.defineProperty(l, h, { get() { return e[h] } }); for (const [h, g] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]]) Object.defineProperty(l, h, { get() { return e.response && e.response[g] } }); return l } const wg = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"])); function ta(e = "GET") { return wg.has(e.toUpperCase()) } function xg(e) { if (e === void 0) return !1; const t = typeof e; return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function" } const _g = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]), Sg = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i; function Cg(e = "") { if (!e) return "json"; const t = e.split(";").shift() || ""; return Sg.test(t) ? "json" : _g.has(t) || t.startsWith("text/") ? "text" : "blob" } function kg(e, t, n, r) { const o = Eg((t == null ? void 0 : t.headers) ?? (e == null ? void 0 : e.headers), n == null ? void 0 : n.headers, r); let s; return (n != null && n.query || n != null && n.params || t != null && t.params || t != null && t.query) && (s = { ...n == null ? void 0 : n.params, ...n == null ? void 0 : n.query, ...t == null ? void 0 : t.params, ...t == null ? void 0 : t.query }), { ...n, ...t, query: s, params: s, headers: o } } function Eg(e, t, n) { if (!t) return new n(e); const r = new n(t); if (e) for (const [o, s] of Symbol.iterator in e || Array.isArray(e) ? e : new n(e)) r.set(o, s); return r } async function Ur(e, t) { if (t) if (Array.isArray(t)) for (const n of t) await n(e); else await t(e) } const Tg = new Set([408, 409, 425, 429, 500, 502, 503, 504]), Ag = new Set([101, 204, 205, 304]); function ju(e = {}) { const { fetch: t = globalThis.fetch, Headers: n = globalThis.Headers, AbortController: r = globalThis.AbortController } = e; async function o(l) { const a = l.error && l.error.name === "AbortError" && !l.options.timeout || !1; if (l.options.retry !== !1 && !a) { let c; typeof l.options.retry == "number" ? c = l.options.retry : c = ta(l.options.method) ? 0 : 1; const f = l.response && l.response.status || 500; if (c > 0 && (Array.isArray(l.options.retryStatusCodes) ? l.options.retryStatusCodes.includes(f) : Tg.has(f))) { const d = typeof l.options.retryDelay == "function" ? l.options.retryDelay(l) : l.options.retryDelay || 0; return d > 0 && await new Promise(h => setTimeout(h, d)), s(l.request, { ...l.options, retry: c - 1 }) } } const u = vg(l); throw Error.captureStackTrace && Error.captureStackTrace(u, s), u } const s = async function (a, u = {}) { const c = { request: a, options: kg(a, u, e.defaults, n), response: void 0, error: void 0 }; c.options.method && (c.options.method = c.options.method.toUpperCase()), c.options.onRequest && await Ur(c, c.options.onRequest), typeof c.request == "string" && (c.options.baseURL && (c.request = hg(c.request, c.options.baseURL)), c.options.query && (c.request = Ou(c.request, c.options.query), delete c.options.query), "query" in c.options && delete c.options.query, "params" in c.options && delete c.options.params), c.options.body && ta(c.options.method) && (xg(c.options.body) ? (c.options.body = typeof c.options.body == "string" ? c.options.body : JSON.stringify(c.options.body), c.options.headers = new n(c.options.headers || {}), c.options.headers.has("content-type") || c.options.headers.set("content-type", "application/json"), c.options.headers.has("accept") || c.options.headers.set("accept", "application/json")) : ("pipeTo" in c.options.body && typeof c.options.body.pipeTo == "function" || typeof c.options.body.pipe == "function") && ("duplex" in c.options || (c.options.duplex = "half"))); let f; if (!c.options.signal && c.options.timeout) { const h = new r; f = setTimeout(() => { const g = new Error("[TimeoutError]: The operation was aborted due to timeout"); g.name = "TimeoutError", g.code = 23, h.abort(g) }, c.options.timeout), c.options.signal = h.signal } try { c.response = await t(c.request, c.options) } catch (h) { return c.error = h, c.options.onRequestError && await Ur(c, c.options.onRequestError), await o(c) } finally { f && clearTimeout(f) } if ((c.response.body || c.response._bodyInit) && !Ag.has(c.response.status) && c.options.method !== "HEAD") { const h = (c.options.parseResponse ? "json" : c.options.responseType) || Cg(c.response.headers.get("content-type") || ""); switch (h) { case "json": { const g = await c.response.text(), p = c.options.parseResponse || bo; c.response._data = p(g); break } case "stream": { c.response._data = c.response.body || c.response._bodyInit; break } default: c.response._data = await c.response[h]() } } return c.options.onResponse && await Ur(c, c.options.onResponse), !c.options.ignoreResponseError && c.response.status >= 400 && c.response.status < 600 ? (c.options.onResponseError && await Ur(c, c.options.onResponseError), await o(c)) : c.response }, i = async function (a, u) { return (await s(a, u))._data }; return i.raw = s, i.native = (...l) => t(...l), i.create = (l = {}, a = {}) => ju({ ...e, ...a, defaults: { ...e.defaults, ...a.defaults, ...l } }), i } const xo = function () { if (typeof globalThis < "u") return globalThis; if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("unable to locate global object") }(), Pg = xo.fetch ? (...e) => xo.fetch(...e) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!")), $g = xo.Headers, Og = xo.AbortController, Ig = ju({ fetch: Pg, Headers: $g, AbortController: Og }), Lg = Ig, Mg = () => { var e; return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {} }, _o = Mg().app, Rg = () => _o.baseURL, jg = () => _o.buildAssetsDir, Di = (...e) => Lu(Tr(), jg(), ...e), Tr = (...e) => { const t = _o.cdnURL || _o.baseURL; return e.length ? Lu(t, ...e) : t }; globalThis.__buildAssetsURL = Di, globalThis.__publicAssetsURL = Tr; globalThis.$fetch || (globalThis.$fetch = Lg.create({ baseURL: Rg() })); function Vs(e, t = {}, n) { for (const r in e) { const o = e[r], s = n ? `${n}:${r}` : r; typeof o == "object" && o !== null ? Vs(o, t, s) : typeof o == "function" && (t[s] = o) } return t } const Ng = { run: e => e() }, Fg = () => Ng, Nu = typeof console.createTask < "u" ? console.createTask : Fg; function Bg(e, t) { const n = t.shift(), r = Nu(n); return e.reduce((o, s) => o.then(() => r.run(() => s(...t))), Promise.resolve()) } function Hg(e, t) { const n = t.shift(), r = Nu(n); return Promise.all(e.map(o => r.run(() => o(...t)))) } function gs(e, t) { for (const n of [...e]) n(t) } class Dg { constructor() { this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this) } hook(t, n, r = {}) { if (!t || typeof n != "function") return () => { }; const o = t; let s; for (; this._deprecatedHooks[t];)s = this._deprecatedHooks[t], t = s.to; if (s && !r.allowDeprecated) { let i = s.message; i || (i = `${o} hook has been deprecated` + (s.to ? `, please use ${s.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(i) || (console.warn(i), this._deprecatedMessages.add(i)) } if (!n.name) try { Object.defineProperty(n, "name", { get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb", configurable: !0 }) } catch { } return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(n), () => { n && (this.removeHook(t, n), n = void 0) } } hookOnce(t, n) { let r, o = (...s) => (typeof r == "function" && r(), r = void 0, o = void 0, n(...s)); return r = this.hook(t, o), r } removeHook(t, n) { if (this._hooks[t]) { const r = this._hooks[t].indexOf(n); r !== -1 && this._hooks[t].splice(r, 1), this._hooks[t].length === 0 && delete this._hooks[t] } } deprecateHook(t, n) { this._deprecatedHooks[t] = typeof n == "string" ? { to: n } : n; const r = this._hooks[t] || []; delete this._hooks[t]; for (const o of r) this.hook(t, o) } deprecateHooks(t) { Object.assign(this._deprecatedHooks, t); for (const n in t) this.deprecateHook(n, t[n]) } addHooks(t) { const n = Vs(t), r = Object.keys(n).map(o => this.hook(o, n[o])); return () => { for (const o of r.splice(0, r.length)) o() } } removeHooks(t) { const n = Vs(t); for (const r in n) this.removeHook(r, n[r]) } removeAllHooks() { for (const t in this._hooks) delete this._hooks[t] } callHook(t, ...n) { return n.unshift(t), this.callHookWith(Bg, t, ...n) } callHookParallel(t, ...n) { return n.unshift(t), this.callHookWith(Hg, t, ...n) } callHookWith(t, n, ...r) { const o = this._before || this._after ? { name: n, args: r, context: {} } : void 0; this._before && gs(this._before, o); const s = t(n in this._hooks ? [...this._hooks[n]] : [], r); return s instanceof Promise ? s.finally(() => { this._after && o && gs(this._after, o) }) : (this._after && o && gs(this._after, o), s) } beforeEach(t) { return this._before = this._before || [], this._before.push(t), () => { if (this._before !== void 0) { const n = this._before.indexOf(t); n !== -1 && this._before.splice(n, 1) } } } afterEach(t) { return this._after = this._after || [], this._after.push(t), () => { if (this._after !== void 0) { const n = this._after.indexOf(t); n !== -1 && this._after.splice(n, 1) } } } } function Fu() { return new Dg } function Ug(e = {}) { let t, n = !1; const r = i => { if (t && t !== i) throw new Error("Context conflict") }; let o; if (e.asyncContext) { const i = e.AsyncLocalStorage || globalThis.AsyncLocalStorage; i ? o = new i : console.warn("[unctx] `AsyncLocalStorage` is not provided.") } const s = () => { if (o) { const i = o.getStore(); if (i !== void 0) return i } return t }; return { use: () => { const i = s(); if (i === void 0) throw new Error("Context is not available"); return i }, tryUse: () => s(), set: (i, l) => { l || r(i), t = i, n = !0 }, unset: () => { t = void 0, n = !1 }, call: (i, l) => { r(i), t = i; try { return o ? o.run(i, l) : l() } finally { n || (t = void 0) } }, async callAsync(i, l) { t = i; const a = () => { t = i }, u = () => t === i ? a : void 0; Gs.add(u); try { const c = o ? o.run(i, l) : l(); return n || (t = void 0), await c } finally { Gs.delete(u) } } } } function zg(e = {}) { const t = {}; return { get(n, r = {}) { return t[n] || (t[n] = Ug({ ...e, ...r })), t[n] } } } const So = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}, na = "__unctx__", qg = So[na] || (So[na] = zg()), Wg = (e, t = {}) => qg.get(e, t), ra = "__unctx_async_handlers__", Gs = So[ra] || (So[ra] = new Set); function Bu(e) { const t = []; for (const o of Gs) { const s = o(); s && t.push(s) } const n = () => { for (const o of t) o() }; let r = e(); return r && typeof r == "object" && "catch" in r && (r = r.catch(o => { throw n(), o })), [r, n] } const Vg = { componentName: "NuxtLink", prefetch: !0, prefetchOn: { visibility: !0 } }, Gg = null, Kg = "#__nuxt", Hu = "nuxt-app", oa = 36e5, Jg = "vite:preloadError"; function Du(e = Hu) { return Wg(e, { asyncContext: !1 }) } const Zg = "__nuxt_plugin"; function Qg(e) { var o; let t = 0; const n = { _id: e.id || Hu || "nuxt-app", _scope: Ad(), provide: void 0, globalName: "nuxt", versions: { get nuxt() { return "3.16.2" }, get vue() { return n.vueApp.version } }, payload: kn({ ...((o = e.ssrContext) == null ? void 0 : o.payload) || {}, data: kn({}), state: ut({}), once: new Set, _errors: kn({}) }), static: { data: {} }, runWithContext(s) { return n._scope.active && !ic() ? n._scope.run(() => sa(n, s)) : sa(n, s) }, isHydrating: !0, deferHydration() { if (!n.isHydrating) return () => { }; t++; let s = !1; return () => { if (!s && (s = !0, t--, t === 0)) return n.isHydrating = !1, n.callHook("app:suspense:resolve") } }, _asyncDataPromises: {}, _asyncData: kn({}), _payloadRevivers: {}, ...e }; { const s = window.__NUXT__; if (s) for (const i in s) switch (i) { case "data": case "state": case "_errors": Object.assign(n.payload[i], s[i]); break; default: n.payload[i] = s[i] } } n.hooks = Fu(), n.hook = n.hooks.hook, n.callHook = n.hooks.callHook, n.provide = (s, i) => { const l = "$" + s; zr(n, l, i), zr(n.vueApp.config.globalProperties, l, i) }, zr(n.vueApp, "$nuxt", n), zr(n.vueApp.config.globalProperties, "$nuxt", n); { window.addEventListener(Jg, i => { n.callHook("app:chunkError", { error: i.payload }), (n.isHydrating || i.payload.message.includes("Unable to preload CSS")) && i.preventDefault() }), window.useNuxtApp || (window.useNuxtApp = he); const s = n.hook("app:error", (...i) => { console.error("[nuxt] error caught during app initialization", ...i) }); n.hook("app:mounted", s) } const r = n.payload.config; return n.provide("config", r), n } function Yg(e, t) { t.hooks && e.hooks.addHooks(t.hooks) } async function Xg(e, t) { if (typeof t == "function") { const { provide: n } = await e.runWithContext(() => t(e)) || {}; if (n && typeof n == "object") for (const r in n) e.provide(r, n[r]) } } async function em(e, t) { const n = [], r = [], o = [], s = []; let i = 0; async function l(a) { var c; const u = ((c = a.dependsOn) == null ? void 0 : c.filter(f => t.some(d => d._name === f) && !n.includes(f))) ?? []; if (u.length > 0) r.push([new Set(u), a]); else { const f = Xg(e, a).then(async () => { a._name && (n.push(a._name), await Promise.all(r.map(async ([d, h]) => { d.has(a._name) && (d.delete(a._name), d.size === 0 && (i++, await l(h))) }))) }); a.parallel ? o.push(f.catch(d => s.push(d))) : await f } } for (const a of t) Yg(e, a); for (const a of t) await l(a); if (await Promise.all(o), i) for (let a = 0; a < i; a++)await Promise.all(o); if (s.length) throw s[0] } function et(e) { if (typeof e == "function") return e; const t = e._name || e.name; return delete e.name, Object.assign(e.setup || (() => { }), e, { [Zg]: !0, _name: t }) } function sa(e, t, n) { const r = () => t(); return Du(e._id).set(e), e.vueApp.runWithContext(r) } function Uu(e) { var n; let t; return No() && (t = (n = vn()) == null ? void 0 : n.appContext.app.$nuxt), t || (t = Du(e).tryUse()), t || null } function he(e) { const t = Uu(e); if (!t) throw new Error("[nuxt] instance unavailable"); return t } function Zt(e) { return he().$config } function zr(e, t, n) { Object.defineProperty(e, t, { get: () => n }) } function tm(e, t) { return { ctx: { table: e }, matchAll: n => qu(n, e) } } function zu(e) { const t = {}; for (const n in e) t[n] = n === "dynamic" ? new Map(Object.entries(e[n]).map(([r, o]) => [r, zu(o)])) : new Map(Object.entries(e[n])); return t } function nm(e) { return tm(zu(e)) } function qu(e, t, n) { e.endsWith("/") && (e = e.slice(0, -1) || "/"); const r = []; for (const [s, i] of ia(t.wildcard)) (e === s || e.startsWith(s + "/")) && r.push(i); for (const [s, i] of ia(t.dynamic)) if (e.startsWith(s + "/")) { const l = "/" + e.slice(s.length).split("/").splice(2).join("/"); r.push(...qu(l, i)) } const o = t.static.get(e); return o && r.push(o), r.filter(Boolean) } function ia(e) { return [...e.entries()].sort((t, n) => t[0].length - n[0].length) } function ms(e) { if (e === null || typeof e != "object") return !1; const t = Object.getPrototypeOf(e); return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0 } function Ks(e, t, n = ".", r) { if (!ms(t)) return Ks(e, {}, n, r); const o = Object.assign({}, t); for (const s in e) { if (s === "__proto__" || s === "constructor") continue; const i = e[s]; i != null && (r && r(o, s, i, n) || (Array.isArray(i) && Array.isArray(o[s]) ? o[s] = [...i, ...o[s]] : ms(i) && ms(o[s]) ? o[s] = Ks(i, o[s], (n ? `${n}.` : "") + s.toString(), r) : o[s] = i)) } return o } function Ui(e) { return (...t) => t.reduce((n, r) => Ks(n, r, "", e), {}) } const Ar = Ui(), rm = Ui((e, t, n) => { if (e[t] !== void 0 && typeof n == "function") return e[t] = n(e[t]), !0 }); function om(e, t) { try { return t in e } catch { return !1 } } class Js extends Error { constructor(n, r = {}) { super(n, r); Nt(this, "statusCode", 500); Nt(this, "fatal", !1); Nt(this, "unhandled", !1); Nt(this, "statusMessage"); Nt(this, "data"); Nt(this, "cause"); r.cause && !this.cause && (this.cause = r.cause) } toJSON() { const n = { message: this.message, statusCode: Zs(this.statusCode, 500) }; return this.statusMessage && (n.statusMessage = Wu(this.statusMessage)), this.data !== void 0 && (n.data = this.data), n } } Nt(Js, "__h3_error__", !0); function sm(e) { if (typeof e == "string") return new Js(e); if (im(e)) return e; const t = new Js(e.message ?? e.statusMessage ?? "", { cause: e.cause || e }); if (om(e, "stack")) try { Object.defineProperty(t, "stack", { get() { return e.stack } }) } catch { try { t.stack = e.stack } catch { } } if (e.data && (t.data = e.data), e.statusCode ? t.statusCode = Zs(e.statusCode, t.statusCode) : e.status && (t.statusCode = Zs(e.status, t.statusCode)), e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText), t.statusMessage) { const n = t.statusMessage; Wu(t.statusMessage) !== n && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.") } return e.fatal !== void 0 && (t.fatal = e.fatal), e.unhandled !== void 0 && (t.unhandled = e.unhandled), t } function im(e) { var t; return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0 } const lm = /[^\u0009\u0020-\u007E]/g; function Wu(e = "") { return e.replace(lm, "") } function Zs(e, t = 200) { return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)), e < 100 || e > 999) ? t : e } const Vu = Symbol("route"), dt = () => { var e; return (e = he()) == null ? void 0 : e.$router }, zi = () => No() ? Se(Vu, he()._route) : he()._route; const am = () => { try { if (he()._processingMiddleware) return !0 } catch { return !1 } return !1 }, Gu = (e, t) => { e || (e = "/"); const n = typeof e == "string" ? e : "path" in e ? Qs(e) : dt().resolve(e).href; if (t != null && t.open) { const { target: a = "_blank", windowFeatures: u = {} } = t.open, c = Object.entries(u).filter(([f, d]) => d !== void 0).map(([f, d]) => `${f.toLowerCase()}=${d}`).join(", "); return open(n, a, c), Promise.resolve() } const r = _t(n, { acceptRelative: !0 }), o = (t == null ? void 0 : t.external) || r; if (o) { if (!(t != null && t.external)) throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`."); const { protocol: a } = new URL(n, window.location.href); if (a && dg(a)) throw new Error(`Cannot navigate to a URL with '${a}' protocol.`) } const s = am(); if (!o && s) { if (t != null && t.replace) { if (typeof e == "string") { const { pathname: a, search: u, hash: c } = Hi(e); return { path: a, ...u && { query: Uo(u) }, ...c && { hash: c }, replace: !0 } } return { ...e, replace: !0 } } return e } const i = dt(), l = he(); return o ? (l._scope.stop(), t != null && t.replace ? location.replace(n) : location.href = n, s ? l.isHydrating ? new Promise(() => { }) : !1 : Promise.resolve()) : t != null && t.replace ? i.replace(e) : i.push(e) }; function Qs(e) { return Ou(e.path || "", e.query || {}) + (e.hash || "") } const Ku = "__nuxt_error", qi = () => yn(he().payload, "error"), cm = e => { const t = Wi(e); try { const n = he(), r = qi(); n.hooks.callHook("app:error", t), r.value || (r.value = t) } catch { throw t } return t }, um = async (e = {}) => { const t = he(), n = qi(); t.callHook("app:error:cleared", e), e.redirect && await dt().replace(e.redirect), n.value = Gg }, fm = e => !!e && typeof e == "object" && Ku in e, Wi = e => { const t = sm(e); return Object.defineProperty(t, Ku, { value: !0, configurable: !1, writable: !1 }), t }; function la(e) { const t = pm(e), n = new ArrayBuffer(t.length), r = new DataView(n); for (let o = 0; o < n.byteLength; o++)r.setUint8(o, t.charCodeAt(o)); return n } const dm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; function pm(e) { e.length % 4 === 0 && (e = e.replace(/==?$/, "")); let t = "", n = 0, r = 0; for (let o = 0; o < e.length; o++)n <<= 6, n |= dm.indexOf(e[o]), r += 6, r === 24 && (t += String.fromCharCode((n & 16711680) >> 16), t += String.fromCharCode((n & 65280) >> 8), t += String.fromCharCode(n & 255), n = r = 0); return r === 12 ? (n >>= 4, t += String.fromCharCode(n)) : r === 18 && (n >>= 2, t += String.fromCharCode((n & 65280) >> 8), t += String.fromCharCode(n & 255)), t } const hm = -1, gm = -2, mm = -3, ym = -4, bm = -5, vm = -6; function wm(e, t) { return xm(JSON.parse(e), t) } function xm(e, t) { if (typeof e == "number") return o(e, !0); if (!Array.isArray(e) || e.length === 0) throw new Error("Invalid input"); const n = e, r = Array(n.length); function o(s, i = !1) { if (s === hm) return; if (s === mm) return NaN; if (s === ym) return 1 / 0; if (s === bm) return -1 / 0; if (s === vm) return -0; if (i) throw new Error("Invalid input"); if (s in r) return r[s]; const l = n[s]; if (!l || typeof l != "object") r[s] = l; else if (Array.isArray(l)) if (typeof l[0] == "string") { const a = l[0], u = t == null ? void 0 : t[a]; if (u) return r[s] = u(o(l[1])); switch (a) { case "Date": r[s] = new Date(l[1]); break; case "Set": const c = new Set; r[s] = c; for (let h = 1; h < l.length; h += 1)c.add(o(l[h])); break; case "Map": const f = new Map; r[s] = f; for (let h = 1; h < l.length; h += 2)f.set(o(l[h]), o(l[h + 1])); break; case "RegExp": r[s] = new RegExp(l[1], l[2]); break; case "Object": r[s] = Object(l[1]); break; case "BigInt": r[s] = BigInt(l[1]); break; case "null": const d = Object.create(null); r[s] = d; for (let h = 1; h < l.length; h += 2)d[l[h]] = o(l[h + 1]); break; case "Int8Array": case "Uint8Array": case "Uint8ClampedArray": case "Int16Array": case "Uint16Array": case "Int32Array": case "Uint32Array": case "Float32Array": case "Float64Array": case "BigInt64Array": case "BigUint64Array": { const h = globalThis[a], g = l[1], p = la(g), b = new h(p); r[s] = b; break } case "ArrayBuffer": { const h = l[1], g = la(h); r[s] = g; break } default: throw new Error(`Unknown type ${a}`) } } else { const a = new Array(l.length); r[s] = a; for (let u = 0; u < l.length; u += 1) { const c = l[u]; c !== gm && (a[u] = o(c)) } } else { const a = {}; r[s] = a; for (const u in l) { const c = l[u]; a[u] = o(c) } } return r[s] } return o(0) } const _m = new Set(["link", "style", "script", "noscript"]), Sm = new Set(["title", "titleTemplate", "script", "style", "noscript"]), aa = new Set(["base", "meta", "link", "style", "script", "noscript"]), Cm = new Set(["title", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]), km = new Set(["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]), Em = new Set(["key", "tagPosition", "tagPriority", "tagDuplicateStrategy", "innerHTML", "textContent", "processTemplateParams"]), Tm = new Set(["templateParams", "htmlAttrs", "bodyAttrs"]), Vi = new Set(["theme-color", "google-site-verification", "og", "article", "book", "profile", "twitter", "author"]), wr = { META: new Set(["twitter"]), OG: new Set(["og", "book", "article", "profile", "fb"]), MEDIA: new Set(["ogImage", "ogVideo", "ogAudio", "twitterImage"]), HTTP_EQUIV: new Set(["contentType", "defaultStyle", "xUaCompatible"]) }, Am = { articleExpirationTime: "article:expiration_time", articleModifiedTime: "article:modified_time", articlePublishedTime: "article:published_time", bookReleaseDate: "book:release_date", fbAppId: "fb:app_id", ogAudioSecureUrl: "og:audio:secure_url", ogAudioUrl: "og:audio", ogImageSecureUrl: "og:image:secure_url", ogImageUrl: "og:image", ogSiteName: "og:site_name", ogVideoSecureUrl: "og:video:secure_url", ogVideoUrl: "og:video", profileFirstName: "profile:first_name", profileLastName: "profile:last_name", profileUsername: "profile:username", msapplicationConfig: "msapplication-Config", msapplicationTileColor: "msapplication-TileColor", msapplicationTileImage: "msapplication-TileImage" }, Ju = { appleItunesApp: { unpack: { entrySeparator: ", ", resolve: ({ key: e, value: t }) => `${Lt(e)}=${t}` } }, refresh: { metaKey: "http-equiv", unpack: { entrySeparator: ";", resolve: ({ key: e, value: t }) => e === "seconds" ? `${t}` : void 0 } }, robots: { unpack: { entrySeparator: ", ", resolve: ({ key: e, value: t }) => typeof t == "boolean" ? Lt(e) : `${Lt(e)}:${t}` } }, contentSecurityPolicy: { metaKey: "http-equiv", unpack: { entrySeparator: "; ", resolve: ({ key: e, value: t }) => `${Lt(e)} ${t}` } }, charset: {} }; function Lt(e) { const t = e.replace(/([A-Z])/g, "-$1").toLowerCase(), n = t.indexOf("-"); return n === -1 ? t : wr.META.has(t.slice(0, n)) || wr.OG.has(t.slice(0, n)) ? e.replace(/([A-Z])/g, ":$1").toLowerCase() : t } function Zu(e) { return Object.fromEntries(Object.entries(e).filter(([t, n]) => String(n) !== "false" && t)) } function Ys(e) { return Array.isArray(e) ? e.map(Ys) : !e || typeof e != "object" ? e : Object.fromEntries(Object.entries(e).map(([t, n]) => [Lt(t), Ys(n)])) } function Qu(e, t = {}) { const { entrySeparator: n = "", keyValueSeparator: r = "", wrapValue: o, resolve: s } = t; return Object.entries(e).map(([i, l]) => { if (s) { const u = s({ key: i, value: l }); if (u !== void 0) return u } const a = typeof l == "object" ? Qu(l, t) : typeof l == "number" ? l.toString() : typeof l == "string" && o ? `${o}${l.replace(new RegExp(o, "g"), `\\${o}`)}${o}` : l; return `${i}${r}${a}` }).join(n) } function ca(e, t) { const n = Zu(t), r = Lt(e), o = Yu(r); if (!Vi.has(r)) return [{ [o]: r, ...n }]; const s = Object.fromEntries(Object.entries(n).map(([i, l]) => [`${e}${i === "url" ? "" : `${i[0].toUpperCase()}${i.slice(1)}`}`, l])); return Co(s || {}).sort((i, l) => { var a, u; return (((a = i[o]) == null ? void 0 : a.length) || 0) - (((u = l[o]) == null ? void 0 : u.length) || 0) }) } function Yu(e) { var r; if (((r = Ju[e]) == null ? void 0 : r.metaKey) === "http-equiv" || wr.HTTP_EQUIV.has(e)) return "http-equiv"; const t = Lt(e), n = t.indexOf(":"); return n === -1 ? "name" : wr.OG.has(t.slice(0, n)) ? "property" : "name" } function Pm(e) { return Am[e] || Lt(e) } function $m(e, t) { var n; return t === "refresh" ? `${e.seconds};url=${e.url}` : Qu(Ys(e), { keyValueSeparator: "=", entrySeparator: ", ", resolve: ({ value: r, key: o }) => r === null ? "" : typeof r == "boolean" ? o : void 0, ...(n = Ju[t]) == null ? void 0 : n.unpack }) } function Co(e) { const t = [], n = {}; for (const [o, s] of Object.entries(e)) { if (Array.isArray(s)) { if (o === "themeColor") { s.forEach(i => { typeof i == "object" && i !== null && t.push({ name: "theme-color", ...i }) }); continue } for (const i of s) if (typeof i == "object" && i !== null) { const l = [], a = []; for (const [u, c] of Object.entries(i)) { const f = `${o}${u === "url" ? "" : `:${u}`}`, d = Co({ [f]: c }); (u === "url" ? l : a).push(...d) } t.push(...l, ...a) } else t.push(...typeof i == "string" ? Co({ [o]: i }) : ca(o, i)); continue } if (typeof s == "object" && s) if (wr.MEDIA.has(o)) { const i = o.startsWith("twitter") ? "twitter" : "og", l = o.replace(/^(og|twitter)/, "").toLowerCase(), a = i === "twitter" ? "name" : "property"; s.url && t.push({ [a]: `${i}:${l}`, content: s.url }), s.secureUrl && t.push({ [a]: `${i}:${l}:secure_url`, content: s.secureUrl }); for (const [u, c] of Object.entries(s)) u !== "url" && u !== "secureUrl" && t.push({ [a]: `${i}:${l}:${u}`, content: c }) } else Vi.has(Lt(o)) ? t.push(...ca(o, s)) : n[o] = Zu(s); else n[o] = s } const r = Object.entries(n).map(([o, s]) => { if (o === "charset") return { charset: s === null ? "_null" : s }; const i = Yu(o), l = Pm(o), a = s === null ? "_null" : typeof s == "object" ? $m(s, o) : typeof s == "number" ? s.toString() : s; return i === "http-equiv" ? { "http-equiv": l, content: a } : { [i]: l, content: a } }); return [...t, ...r].map(o => "content" in o && o.content === "_null" ? { ...o, content: null } : o) } const Om = { key: "flatMeta", hooks: { "entries:normalize": e => { const t = []; e.tags = e.tags.map(n => n.tag !== "_flatMeta" ? n : (t.push(Co(n.props).map(r => ({ ...n, tag: "meta", props: r }))), !1)).filter(Boolean).concat(...t) } } }, Im = ["name", "property", "http-equiv"]; function Xu(e) { const t = e.split(":")[1]; return Vi.has(t) } function Xs(e) { const { props: t, tag: n } = e; if (km.has(n)) return n; if (n === "link" && t.rel === "canonical") return "canonical"; if (t.charset) return "charset"; if (e.tag === "meta") { for (const r of Im) if (t[r] !== void 0) return `${n}:${t[r]}` } if (e.key) return `${n}:key:${e.key}`; if (t.id) return `${n}:id:${t.id}`; if (Sm.has(n)) { const r = e.textContent || e.innerHTML; if (r) return `${n}:content:${r}` } } function ua(e) { const t = e._h || e._d; if (t) return t; const n = e.textContent || e.innerHTML; return n || `${e.tag}:${Object.entries(e.props).map(([r, o]) => `${r}:${String(o)}`).join(",")}` } function ko(e, t, n) { typeof e === "function" && (!n || n !== "titleTemplate" && !(n[0] === "o" && n[1] === "n")) && (e = e()); let o; if (t && (o = t(n, e)), Array.isArray(o)) return o.map(s => ko(s, t)); if ((o == null ? void 0 : o.constructor) === Object) { const s = {}; for (const i of Object.keys(o)) s[i] = ko(o[i], t, i); return s } return o } function Lm(e, t) { const n = e === "style" ? new Map : new Set; function r(o) { const s = o.trim(); if (s) if (e === "style") { const [i, ...l] = s.split(":").map(a => a.trim()); i && l.length && n.set(i, l.join(":")) } else s.split(" ").filter(Boolean).forEach(i => n.add(i)) } return typeof t == "string" ? e === "style" ? t.split(";").forEach(r) : r(t) : Array.isArray(t) ? t.forEach(o => r(o)) : t && typeof t == "object" && Object.entries(t).forEach(([o, s]) => { s && s !== "false" && (e === "style" ? n.set(o.trim(), s) : r(o)) }), n } function ef(e, t) { return e.props = e.props || {}, t && Object.entries(t).forEach(([n, r]) => { if (r === null) { e.props[n] = null; return } if (n === "class" || n === "style") { e.props[n] = Lm(n, r); return } if (Em.has(n)) { if (["textContent", "innerHTML"].includes(n) && typeof r == "object") { let i = t.type; if (t.type || (i = "application/json"), !(i != null && i.endsWith("json")) && i !== "speculationrules") return; t.type = i, e.props.type = i, e[n] = JSON.stringify(r) } else e[n] = r; return } const o = String(r), s = n.startsWith("data-"); o === "true" || o === "" ? e.props[n] = s ? o : !0 : !r && s && o === "false" ? e.props[n] = "false" : r !== void 0 && (e.props[n] = r) }), e } function Mm(e, t) { const n = typeof t == "object" && typeof t != "function" ? t : { [e === "script" || e === "noscript" || e === "style" ? "innerHTML" : "textContent"]: t }, r = ef({ tag: e, props: {} }, n); return r.key && _m.has(r.tag) && (r.props["data-hid"] = r._h = r.key), r.tag === "script" && typeof r.innerHTML == "object" && (r.innerHTML = JSON.stringify(r.innerHTML), r.props.type = r.props.type || "application/json"), Array.isArray(r.props.content) ? r.props.content.map(o => ({ ...r, props: { ...r.props, content: o } })) : r } function Rm(e, t) { if (!e) return []; typeof e == "function" && (e = e()); const n = (o, s) => { for (let i = 0; i < t.length; i++)s = t[i](o, s); return s }; e = n(void 0, e); const r = []; return e = ko(e, n), Object.entries(e || {}).forEach(([o, s]) => { if (s !== void 0) for (const i of Array.isArray(s) ? s : [s]) r.push(Mm(o, i)) }), r.flat() } const ei = (e, t) => e._w === t._w ? e._p - t._p : e._w - t._w, fa = { base: -10, title: 10 }, jm = { critical: -8, high: -1, low: 2 }, da = { meta: { "content-security-policy": -30, charset: -20, viewport: -15 }, link: { preconnect: 20, stylesheet: 60, preload: 70, modulepreload: 70, prefetch: 90, "dns-prefetch": 90, prerender: 90 }, script: { async: 30, defer: 80, sync: 50 }, style: { imported: 40, sync: 60 } }, Nm = /@import/, Gn = e => e === "" || e === !0; function Fm(e, t) { var s; if (typeof t.tagPriority == "number") return t.tagPriority; let n = 100; const r = jm[t.tagPriority] || 0, o = e.resolvedOptions.disableCapoSorting ? { link: {}, script: {}, style: {} } : da; if (t.tag in fa) n = fa[t.tag]; else if (t.tag === "meta") { const i = t.props["http-equiv"] === "content-security-policy" ? "content-security-policy" : t.props.charset ? "charset" : t.props.name === "viewport" ? "viewport" : null; i && (n = da.meta[i]) } else t.tag === "link" && t.props.rel ? n = o.link[t.props.rel] : t.tag === "script" ? Gn(t.props.async) ? n = o.script.async : t.props.src && !Gn(t.props.defer) && !Gn(t.props.async) && t.props.type !== "module" && !((s = t.props.type) != null && s.endsWith("json")) ? n = o.script.sync : Gn(t.props.defer) && t.props.src && !Gn(t.props.async) && (n = o.script.defer) : t.tag === "style" && (n = t.innerHTML && Nm.test(t.innerHTML) ? o.style.imported : o.style.sync); return (n || 100) + r } function pa(e, t) { const n = typeof t == "function" ? t(e) : t, r = n.key || String(e.plugins.size + 1); e.plugins.get(r) || (e.plugins.set(r, n), e.hooks.addHooks(n.hooks || {})) } function Bm(e = {}) { var l; const t = Fu(); t.addHooks(e.hooks || {}); const n = !e.document, r = new Map, o = new Map, s = [], i = { _entryCount: 1, plugins: o, dirty: !1, resolvedOptions: e, hooks: t, ssr: n, entries: r, headEntries() { return [...r.values()] }, use: a => pa(i, a), push(a, u) { const c = { ...u || {} }; delete c.head; const f = c._index ?? i._entryCount++, d = { _i: f, input: a, options: c }, h = { _poll(g = !1) { i.dirty = !0, !g && s.push(f), t.callHook("entries:updated", i) }, dispose() { r.delete(f) && h._poll(!0) }, patch(g) { (!c.mode || c.mode === "server" && n || c.mode === "client" && !n) && (d.input = g, r.set(f, d), h._poll()) } }; return h.patch(a), h }, async resolveTags() { var h; const a = { tagMap: new Map, tags: [], entries: [...i.entries.values()] }; for (await t.callHook("entries:resolve", a); s.length;) { const g = s.shift(), p = r.get(g); if (p) { const b = { tags: Rm(p.input, e.propResolvers || []).map(_ => Object.assign(_, p.options)), entry: p }; await t.callHook("entries:normalize", b), p._tags = b.tags.map((_, C) => (_._w = Fm(i, _), _._p = (p._i << 10) + C, _._d = Xs(_), _)) } } let u = !1; a.entries.flatMap(g => (g._tags || []).map(p => ({ ...p, props: { ...p.props } }))).sort(ei).reduce((g, p) => { const b = String(p._d || p._p); if (!g.has(b)) return g.set(b, p); const _ = g.get(b); if (((p == null ? void 0 : p.tagDuplicateStrategy) || (Tm.has(p.tag) ? "merge" : null) || (p.key && p.key === _.key ? "merge" : null)) === "merge") { const y = { ..._.props }; Object.entries(p.props).forEach(([w, S]) => y[w] = w === "style" ? new Map([..._.props.style || new Map, ...S]) : w === "class" ? new Set([..._.props.class || new Set, ...S]) : S), g.set(b, { ...p, props: y }) } else p._p >> 10 === _._p >> 10 && Xu(p._d) ? (g.set(b, Object.assign([...Array.isArray(_) ? _ : [_], p], p)), u = !0) : (p._w === _._w ? p._p > _._p : (p == null ? void 0 : p._w) < (_ == null ? void 0 : _._w)) && g.set(b, p); return g }, a.tagMap); const c = a.tagMap.get("title"), f = a.tagMap.get("titleTemplate"); if (i._title = c == null ? void 0 : c.textContent, f) { const g = f == null ? void 0 : f.textContent; if (i._titleTemplate = g, g) { let p = typeof g == "function" ? g(c == null ? void 0 : c.textContent) : g; typeof p == "string" && !i.plugins.has("template-params") && (p = p.replace("%s", (c == null ? void 0 : c.textContent) || "")), c ? p === null ? a.tagMap.delete("title") : a.tagMap.set("title", { ...c, textContent: p }) : (f.tag = "title", f.textContent = p) } } a.tags = Array.from(a.tagMap.values()), u && (a.tags = a.tags.flat().sort(ei)), await t.callHook("tags:beforeResolve", a), await t.callHook("tags:resolve", a), await t.callHook("tags:afterResolve", a); const d = []; for (const g of a.tags) { const { innerHTML: p, tag: b, props: _ } = g; if (Cm.has(b) && !(Object.keys(_).length === 0 && !g.innerHTML && !g.textContent) && !(b === "meta" && !_.content && !_["http-equiv"] && !_.charset)) { if (b === "script" && p) { if ((h = _.type) != null && h.endsWith("json")) { const C = typeof p == "string" ? p : JSON.stringify(p); g.innerHTML = C.replace(/</g, "\\u003C") } else typeof p == "string" && (g.innerHTML = p.replace(new RegExp(`</${b}`, "g"), `<\\/${b}`)); g._d = Xs(g) } d.push(g) } } return d } }; return ((e == null ? void 0 : e.plugins) || []).forEach(a => pa(i, a)), i.hooks.callHook("init", i), (l = e.init) == null || l.forEach(a => a && i.push(a)), i } const qt = "%separator", Hm = new RegExp(`${qt}(?:\\s*${qt})*`, "g"); function Dm(e, t, n = !1) { var o; let r; if (t === "s" || t === "pageTitle") r = e.pageTitle; else if (t.includes(".")) { const s = t.indexOf("."); r = (o = e[t.substring(0, s)]) == null ? void 0 : o[t.substring(s + 1)] } else r = e[t]; if (r !== void 0) return n ? (r || "").replace(/\\/g, "\\\\").replace(/</g, "\\u003C").replace(/"/g, '\\"') : r || "" } function qr(e, t, n, r = !1) { if (typeof e != "string" || !e.includes("%")) return e; let o = e; try { o = decodeURI(e) } catch { } const s = o.match(/%\w+(?:\.\w+)?/g); if (!s) return e; const i = e.includes(qt); return e = e.replace(/%\w+(?:\.\w+)?/g, l => { if (l === qt || !s.includes(l)) return l; const a = Dm(t, l.slice(1), r); return a !== void 0 ? a : l }).trim(), i && (e.endsWith(qt) && (e = e.slice(0, -qt.length)), e.startsWith(qt) && (e = e.slice(qt.length)), e = e.replace(Hm, n || "").trim()), e } const ha = e => e.includes(":key") ? e : e.split(":").join(":key:"), Um = { key: "aliasSorting", hooks: { "tags:resolve": e => { let t = !1; for (const n of e.tags) { const r = n.tagPriority; if (!r) continue; const o = String(r); if (o.startsWith("before:")) { const s = ha(o.slice(7)), i = e.tagMap.get(s); i && (typeof i.tagPriority == "number" && (n.tagPriority = i.tagPriority), n._p = i._p - 1, t = !0) } else if (o.startsWith("after:")) { const s = ha(o.slice(6)), i = e.tagMap.get(s); i && (typeof i.tagPriority == "number" && (n.tagPriority = i.tagPriority), n._p = i._p + 1, t = !0) } } t && (e.tags = e.tags.sort(ei)) } } }, zm = { key: "deprecations", hooks: { "entries:normalize": ({ tags: e }) => { for (const t of e) t.props.children && (t.innerHTML = t.props.children, delete t.props.children), t.props.hid && (t.key = t.props.hid, delete t.props.hid), t.props.vmid && (t.key = t.props.vmid, delete t.props.vmid), t.props.body && (t.tagPosition = "bodyClose", delete t.props.body) } } }; async function ti(e) { if (typeof e === "function") return e; if (e instanceof Promise) return await e; if (Array.isArray(e)) return await Promise.all(e.map(n => ti(n))); if ((e == null ? void 0 : e.constructor) === Object) { const n = {}; for (const r of Object.keys(e)) n[r] = await ti(e[r]); return n } return e } const qm = { key: "promises", hooks: { "entries:resolve": async e => { const t = []; for (const n in e.entries) e.entries[n]._promisesProcessed || t.push(ti(e.entries[n].input).then(r => { e.entries[n].input = r, e.entries[n]._promisesProcessed = !0 })); await Promise.all(t) } } }, Wm = { meta: "content", link: "href", htmlAttrs: "lang" }, Vm = ["innerHTML", "textContent"], Gm = e => ({ key: "template-params", hooks: { "entries:normalize": t => { var r, o, s; const n = ((o = (r = t.tags.filter(i => i.tag === "templateParams" && i.mode === "server")) == null ? void 0 : r[0]) == null ? void 0 : o.props) || {}; Object.keys(n).length && (e._ssrPayload = { templateParams: { ...((s = e._ssrPayload) == null ? void 0 : s.templateParams) || {}, ...n } }) }, "tags:resolve": ({ tagMap: t, tags: n }) => { var s; const r = ((s = t.get("templateParams")) == null ? void 0 : s.props) || {}, o = r.separator || "|"; delete r.separator, r.pageTitle = qr(r.pageTitle || e._title || "", r, o); for (const i of n) { if (i.processTemplateParams === !1) continue; const l = Wm[i.tag]; if (l && typeof i.props[l] == "string") i.props[l] = qr(i.props[l], r, o); else if (i.processTemplateParams || i.tag === "titleTemplate" || i.tag === "title") for (const a of Vm) typeof i[a] == "string" && (i[a] = qr(i[a], r, o, i.tag === "script" && i.props.type.endsWith("json"))) } e._templateParams = r, e._separator = o }, "tags:afterResolve": ({ tagMap: t }) => { const n = t.get("title"); n != null && n.textContent && n.processTemplateParams !== !1 && (n.textContent = qr(n.textContent, e._templateParams, e._separator)) } } }), Km = (e, t) => Ee(t) ? Jr(t) : t, Gi = "usehead"; function Jm(e) { return { install(n) { n.config.globalProperties.$unhead = e, n.config.globalProperties.$head = e, n.provide(Gi, e) } }.install } function tf() { if (No()) { const e = Se(Gi); if (!e) throw new Error("useHead() was called without provide context, ensure you call it through the setup() function."); return e } throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.") } function nf(e, t = {}) { const n = t.head || tf(); return n.ssr ? n.push(e || {}, t) : Zm(n, e, t) } function Zm(e, t, n = {}) { const r = G(!1); let o; return Ge(() => { const i = r.value ? {} : ko(t, Km); o ? o.patch(i) : o = e.push(i, n) }), vn() && (jo(() => { o.dispose() }), Fc(() => { r.value = !0 }), Nc(() => { r.value = !1 })), o } function Qm(e = {}, t = {}) { (t.head || tf()).use(Om); const { title: r, titleTemplate: o, ...s } = e; return nf({ title: r, titleTemplate: o, _flatMeta: s }, t) } function rf(e) { var n; const t = e || Uu(); return ((n = t == null ? void 0 : t.ssrContext) == null ? void 0 : n.head) || (t == null ? void 0 : t.runWithContext(() => { if (No()) return Se(Gi) })) } function Ym(e, t = {}) { const n = rf(t.nuxt); if (n) return nf(e, { head: n, ...t }) } function Xm(e, t = {}) { const n = rf(t.nuxt); if (n) return Qm(e, { head: n, ...t }) } const e0 = "modulepreload", t0 = function (e, t) { return new URL(e, t).href }, ga = {}, ni = function (t, n, r) { let o = Promise.resolve(); if (n && n.length > 0) { let i = function (c) { return Promise.all(c.map(f => Promise.resolve(f).then(d => ({ status: "fulfilled", value: d }), d => ({ status: "rejected", reason: d })))) }; const l = document.getElementsByTagName("link"), a = document.querySelector("meta[property=csp-nonce]"), u = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce")); o = i(n.map(c => { if (c = t0(c, r), c in ga) return; ga[c] = !0; const f = c.endsWith(".css"), d = f ? '[rel="stylesheet"]' : ""; if (!!r) for (let p = l.length - 1; p >= 0; p--) { const b = l[p]; if (b.href === c && (!f || b.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${c}"]${d}`)) return; const g = document.createElement("link"); if (g.rel = f ? "stylesheet" : e0, f || (g.as = "script"), g.crossOrigin = "", g.href = c, u && g.setAttribute("nonce", u), document.head.appendChild(g), f) return new Promise((p, b) => { g.addEventListener("load", p), g.addEventListener("error", () => b(new Error(`Unable to preload CSS for ${c}`))) }) })) } function s(i) { const l = new Event("vite:preloadError", { cancelable: !0 }); if (l.payload = i, window.dispatchEvent(l), !l.defaultPrevented) throw i } return o.then(i => { for (const l of i || []) l.status === "rejected" && s(l.reason); return t().catch(s) }) }; let to, no; function n0() { return to = $fetch(Di(`builds/meta/${Zt().app.buildId}.json`), { responseType: "json" }), to.then(e => { no = nm(e.matcher) }).catch(e => { console.error("[nuxt] Error fetching app manifest.", e) }), to } function qo() { return to || n0() } async function Ki(e) { const t = typeof e == "string" ? e : e.path; if (await qo(), !no) return console.error("[nuxt] Error creating app manifest matcher.", no), {}; try { return Ar({}, ...no.matchAll(t).reverse()) } catch (n) { return console.error("[nuxt] Error matching route rules.", n), {} } } async function ma(e, t = {}) { if (!await sf(e)) return null; const r = await o0(e, t); return await of(r) || null } const r0 = "_payload.json"; async function o0(e, t = {}) { const n = new URL(e, "http://localhost"); if (n.host !== "localhost" || _t(n.pathname, { acceptRelative: !0 })) throw new Error("Payload URL must not include hostname: " + e); const r = Zt(), o = t.hash || (t.fresh ? Date.now() : r.app.buildId), s = r.app.cdnURL, i = s && await sf(e) ? s : r.app.baseURL; return Jt(i, n.pathname, r0 + (o ? `?${o}` : "")) } async function of(e) { const t = fetch(e, { cache: "force-cache" }).then(n => n.text().then(lf)); try { return await t } catch (n) { console.warn("[nuxt] Cannot load payload ", e, n) } return null } async function sf(e = zi().path) { const t = he(); return e = zo(e), (await qo()).prerendered.includes(e) ? !0 : t.runWithContext(async () => { const r = await Ki({ path: e }); return !!r.prerender && !r.redirect }) } let on = null; async function s0() { var r; if (on) return on; const e = document.getElementById("__NUXT_DATA__"); if (!e) return {}; const t = await lf(e.textContent || ""), n = e.dataset.src ? await of(e.dataset.src) : void 0; return on = { ...t, ...n, ...window.__NUXT__ }, (r = on.config) != null && r.public && (on.config.public = ut(on.config.public)), on } async function lf(e) { return await wm(e, he()._payloadRevivers) } function i0(e, t) { he()._payloadRevivers[e] = t } const l0 = [["NuxtError", e => Wi(e)], ["EmptyShallowRef", e => pr(e === "_" ? void 0 : e === "0n" ? BigInt(0) : bo(e))], ["EmptyRef", e => G(e === "_" ? void 0 : e === "0n" ? BigInt(0) : bo(e))], ["ShallowRef", e => pr(e)], ["ShallowReactive", e => kn(e)], ["Ref", e => G(e)], ["Reactive", e => ut(e)]], a0 = et({ name: "nuxt:revive-payload:client", order: -30, async setup(e) { let t, n; for (const [r, o] of l0) i0(r, o); Object.assign(e.payload, ([t, n] = Bu(() => e.runWithContext(s0)), t = await t, n(), t)), window.__NUXT__ = e.payload } }); async function Ji(e, t = {}) { const n = t.document || e.resolvedOptions.document; if (!n || !e.dirty) return; const r = { shouldRender: !0, tags: [] }; if (await e.hooks.callHook("dom:beforeRender", r), !!r.shouldRender) return e._domUpdatePromise || (e._domUpdatePromise = new Promise(async o => { var h; const s = new Map, i = new Promise(g => { e.resolveTags().then(p => { g(p.map(b => { const _ = s.get(b._d) || 0, C = { tag: b, id: (_ ? `${b._d}:${_}` : b._d) || ua(b), shouldRender: !0 }; return b._d && Xu(b._d) && s.set(b._d, _ + 1), C })) }) }); let l = e._dom; if (!l) { l = { title: n.title, elMap: new Map().set("htmlAttrs", n.documentElement).set("bodyAttrs", n.body) }; for (const g of ["body", "head"]) { const p = (h = n[g]) == null ? void 0 : h.children; for (const b of p) { const _ = b.tagName.toLowerCase(); if (!aa.has(_)) continue; const C = ef({ tag: _, props: {} }, { innerHTML: b.innerHTML, ...b.getAttributeNames().reduce((y, w) => (y[w] = b.getAttribute(w), y), {}) || {} }); if (C.key = b.getAttribute("data-hid") || void 0, C._d = Xs(C) || ua(C), l.elMap.has(C._d)) { let y = 1, w = C._d; for (; l.elMap.has(w);)w = `${C._d}:${y++}`; l.elMap.set(w, b) } else l.elMap.set(C._d, b) } } } l.pendingSideEffects = { ...l.sideEffects }, l.sideEffects = {}; function a(g, p, b) { const _ = `${g}:${p}`; l.sideEffects[_] = b, delete l.pendingSideEffects[_] } function u({ id: g, $el: p, tag: b }) { const _ = b.tag.endsWith("Attrs"); l.elMap.set(g, p), _ || (b.textContent && b.textContent !== p.textContent && (p.textContent = b.textContent), b.innerHTML && b.innerHTML !== p.innerHTML && (p.innerHTML = b.innerHTML), a(g, "el", () => { p == null || p.remove(), l.elMap.delete(g) })); for (const C in b.props) { if (!Object.prototype.hasOwnProperty.call(b.props, C)) continue; const y = b.props[C]; if (C.startsWith("on") && typeof y == "function") { const S = p == null ? void 0 : p.dataset; if (S && S[`${C}fired`]) { const k = C.slice(0, -5); y.call(p, new Event(k.substring(2))) } p.getAttribute(`data-${C}`) !== "" && ((b.tag === "bodyAttrs" ? n.defaultView : p).addEventListener(C.substring(2), y.bind(p)), p.setAttribute(`data-${C}`, "")); continue } const w = `attr:${C}`; if (C === "class") { if (!y) continue; for (const S of y) _ && a(g, `${w}:${S}`, () => p.classList.remove(S)), !p.classList.contains(S) && p.classList.add(S) } else if (C === "style") { if (!y) continue; for (const [S, k] of y) a(g, `${w}:${S}`, () => { p.style.removeProperty(S) }), p.style.setProperty(S, k) } else y !== !1 && y !== null && (p.getAttribute(C) !== y && p.setAttribute(C, y === !0 ? "" : String(y)), _ && a(g, w, () => p.removeAttribute(C))) } } const c = [], f = { bodyClose: void 0, bodyOpen: void 0, head: void 0 }, d = await i; for (const g of d) { const { tag: p, shouldRender: b, id: _ } = g; if (b) { if (p.tag === "title") { n.title = p.textContent, a("title", "", () => n.title = l.title); continue } g.$el = g.$el || l.elMap.get(_), g.$el ? u(g) : aa.has(p.tag) && c.push(g) } } for (const g of c) { const p = g.tag.tagPosition || "head"; g.$el = n.createElement(g.tag.tag), u(g), f[p] = f[p] || n.createDocumentFragment(), f[p].appendChild(g.$el) } for (const g of d) await e.hooks.callHook("dom:renderTag", g, n, a); f.head && n.head.appendChild(f.head), f.bodyOpen && n.body.insertBefore(f.bodyOpen, n.body.firstChild), f.bodyClose && n.body.appendChild(f.bodyClose); for (const g in l.pendingSideEffects) l.pendingSideEffects[g](); e._dom = l, await e.hooks.callHook("dom:rendered", { renders: d }), o() }).finally(() => { e._domUpdatePromise = void 0, e.dirty = !1 })), e._domUpdatePromise } function c0(e = {}) { var r, o, s; const t = ((r = e.domOptions) == null ? void 0 : r.render) || Ji; e.document = e.document || (typeof window < "u" ? document : void 0); const n = ((s = (o = e.document) == null ? void 0 : o.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : s.innerHTML) || !1; return Bm({ ...e, plugins: [...e.plugins || [], { key: "client", hooks: { "entries:updated": t } }], init: [n ? JSON.parse(n) : !1, ...e.init || []] }) } function u0(e, t) { let n = 0; return () => { const r = ++n; t(() => { n === r && e() }) } } function f0(e = {}) { const t = c0({ domOptions: { render: u0(() => Ji(t), n => setTimeout(n, 0)) }, ...e }); return t.install = Jm(t), t } const d0 = { disableDefaults: !0, disableCapoSorting: !1, plugins: [zm, qm, Gm, Um] }, p0 = et({ name: "nuxt:head", enforce: "pre", setup(e) { const t = f0(d0); e.vueApp.use(t); { let n = !0; const r = async () => { n = !1, await Ji(t) }; t.hooks.hook("dom:beforeRender", o => { o.shouldRender = !n }), e.hooks.hook("page:start", () => { n = !0 }), e.hooks.hook("page:finish", () => { e.isHydrating || r() }), e.hooks.hook("app:error", r), e.hooks.hook("app:suspense:resolve", r) } } }), h0 = async e => { let t, n; const r = ([t, n] = Bu(() => Ki({ path: e.path })), t = await t, n(), t); if (r.redirect) return _t(r.redirect, { acceptRelative: !0 }) ? (window.location.href = r.redirect, !1) : r.redirect }, g0 = [h0]; function ys(e) { typeof e == "object" && (e = Ru({ pathname: e.path || "", search: $u(e.query || {}), hash: e.hash || "" })); const t = new URL(e.toString(), window.location.href); return { path: t.pathname, fullPath: e, query: Uo(t.search), hash: t.hash, params: {}, name: void 0, matched: [], redirectedFrom: void 0, meta: {}, href: e } } const m0 = et({ name: "nuxt:router", enforce: "pre", setup(e) { const t = gg(window.location.pathname, Zt().app.baseURL) + window.location.search + window.location.hash, n = [], r = { "navigate:before": [], "resolve:before": [], "navigate:after": [], error: [] }, o = (f, d) => (r[f].push(d), () => r[f].splice(r[f].indexOf(d), 1)), s = Zt().app.baseURL, i = ut(ys(t)); async function l(f, d) { try { const h = ys(f); for (const g of r["navigate:before"]) { const p = await g(h, i); if (p === !1 || p instanceof Error) return; if (typeof p == "string" && p.length) return l(p, !0) } for (const g of r["resolve:before"]) await g(h, i); Object.assign(i, h), window.history[d ? "replaceState" : "pushState"]({}, "", Jt(s, h.fullPath)), e.isHydrating || await e.runWithContext(um); for (const g of r["navigate:after"]) await g(h, i) } catch (h) { for (const g of r.error) await g(h) } } const u = { currentRoute: R(() => i), isReady: () => Promise.resolve(), options: {}, install: () => Promise.resolve(), push: f => l(f, !1), replace: f => l(f, !0), back: () => window.history.go(-1), go: f => window.history.go(f), forward: () => window.history.go(1), beforeResolve: f => o("resolve:before", f), beforeEach: f => o("navigate:before", f), afterEach: f => o("navigate:after", f), onError: f => o("error", f), resolve: ys, addRoute: (f, d) => { n.push(d) }, getRoutes: () => n, hasRoute: f => n.some(d => d.name === f), removeRoute: f => { const d = n.findIndex(h => h.name === f); d !== -1 && n.splice(d, 1) } }; e.vueApp.component("RouterLink", ce({ functional: !0, props: { to: { type: String, required: !0 }, custom: Boolean, replace: Boolean, activeClass: String, exactActiveClass: String, ariaCurrentValue: String }, setup: (f, { slots: d }) => { const h = () => l(f.to, f.replace); return () => { var p; const g = u.resolve(f.to); return f.custom ? (p = d.default) == null ? void 0 : p.call(d, { href: f.to, navigate: h, route: g }) : xe("a", { href: f.to, onClick: b => (b.preventDefault(), h()) }, d) } } })), window.addEventListener("popstate", f => { const d = f.target.location; u.replace(d.href.replace(d.origin, "")) }), e._route = i, e._middleware || (e._middleware = { global: [], named: {} }); const c = e.payload.state._layout; return e.hooks.hookOnce("app:created", async () => { u.beforeEach(async (f, d) => { f.meta = ut(f.meta || {}), e.isHydrating && c && !Kt(f.meta.layout) && (f.meta.layout = c), e._processingMiddleware = !0; { const h = new Set([...g0, ...e._middleware.global]); { const g = await e.runWithContext(() => Ki({ path: f.path })); if (g.appMiddleware) for (const p in g.appMiddleware) { const b = e._middleware.named[p]; if (!b) return; g.appMiddleware[p] ? h.add(b) : h.delete(b) } } for (const g of h) { const p = await e.runWithContext(() => g(f, d)); if (p !== !0 && (p || p === !1)) return p } } }), u.afterEach(() => { delete e._processingMiddleware }), await u.replace(t), yg(i.fullPath, t) || await e.runWithContext(() => Gu(i.fullPath)) }), { provide: { route: i, router: u } } } }), ri = globalThis.requestIdleCallback || (e => { const t = Date.now(), n = { didTimeout: !1, timeRemaining: () => Math.max(0, 50 - (Date.now() - t)) }; return setTimeout(() => { e(n) }, 1) }), y0 = globalThis.cancelIdleCallback || (e => { clearTimeout(e) }), Wo = e => { const t = he(); t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", () => { ri(() => e()) }) : ri(() => e()) }, b0 = et({ name: "nuxt:payload", setup(e) { const t = new Set; dt().beforeResolve(async (n, r) => { if (n.path === r.path) return; const o = await ma(n.path); if (o) { for (const s of t) delete e.static.data[s]; for (const s in o.data) s in e.static.data || t.add(s), e.static.data[s] = o.data[s] } }), Wo(() => { var n; e.hooks.hook("link:prefetch", async r => { const { hostname: o } = new URL(r, window.location.href); o === window.location.hostname && await ma(r).catch(() => { console.warn("[nuxt] Error preloading payload for", r) }) }), ((n = navigator.connection) == null ? void 0 : n.effectiveType) !== "slow-2g" && setTimeout(qo, 1e3) }) } }), v0 = et(() => { const e = dt(); Wo(() => { e.beforeResolve(async () => { await new Promise(t => { setTimeout(t, 100), requestAnimationFrame(() => { setTimeout(t, 0) }) }) }) }) }), w0 = et(e => { let t; async function n() { const r = await qo(); t && clearTimeout(t), t = setTimeout(n, oa); try { const o = await $fetch(Di("builds/latest.json") + `?${Date.now()}`); o.id !== r.id && e.hooks.callHook("app:manifest:update", o) } catch { } } Wo(() => { t = setTimeout(n, oa) }) }); function x0(e = {}) { const t = e.path || window.location.pathname; let n = {}; try { n = bo(sessionStorage.getItem("nuxt:reload") || "{}") } catch { } if (e.force || (n == null ? void 0 : n.path) !== t || (n == null ? void 0 : n.expires) < Date.now()) { try { sessionStorage.setItem("nuxt:reload", JSON.stringify({ path: t, expires: Date.now() + (e.ttl ?? 1e4) })) } catch { } if (e.persistState) try { sessionStorage.setItem("nuxt:reload:state", JSON.stringify({ state: he().payload.state })) } catch { } window.location.pathname !== t ? window.location.href = t : window.location.reload() } } const _0 = et({ name: "nuxt:chunk-reload", setup(e) { const t = dt(), n = Zt(), r = new Set; t.beforeEach(() => { r.clear() }), e.hook("app:chunkError", ({ error: s }) => { r.add(s) }); function o(s) { const l = "href" in s && s.href[0] === "#" ? n.app.baseURL + s.href : Jt(n.app.baseURL, s.fullPath); x0({ path: l, persistState: !0 }) } e.hook("app:manifest:update", () => { t.beforeResolve(o) }), t.onError((s, i) => { r.has(s) && o(i) }) } }), S0 = Ms(() => ni(() => Promise.resolve().then(() => kv), void 0, import.meta.url).then(e => e.default || e.default || e)), C0 = [["Icon", S0]], k0 = et({ name: "nuxt:global-components", setup(e) { for (const [t, n] of C0) e.vueApp.component(t, n), e.vueApp.component("Lazy" + t, n) } }), E0 = Symbol("nuxt-ui.slideover"), T0 = et(e => { const t = pr({ component: "div", props: {} }); e.vueApp.provide(E0, t) }), A0 = Symbol("nuxt-ui.modal"), P0 = et(e => { const t = pr({ component: "div", props: {} }); e.vueApp.provide(A0, t) }), Zi = "-", $0 = e => { const t = I0(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e; return { getClassGroupId: i => { const l = i.split(Zi); return l[0] === "" && l.length !== 1 && l.shift(), af(l, t) || O0(i) }, getConflictingClassGroupIds: (i, l) => { const a = n[i] || []; return l && r[i] ? [...a, ...r[i]] : a } } }, af = (e, t) => { var i; if (e.length === 0) return t.classGroupId; const n = e[0], r = t.nextPart.get(n), o = r ? af(e.slice(1), r) : void 0; if (o) return o; if (t.validators.length === 0) return; const s = e.join(Zi); return (i = t.validators.find(({ validator: l }) => l(s))) == null ? void 0 : i.classGroupId }, ya = /^\[(.+)\]$/, O0 = e => { if (ya.test(e)) { const t = ya.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":")); if (n) return "arbitrary.." + n } }, I0 = e => { const { theme: t, prefix: n } = e, r = { nextPart: new Map, validators: [] }; return M0(Object.entries(e.classGroups), n).forEach(([s, i]) => { oi(i, r, s, t) }), r }, oi = (e, t, n, r) => { e.forEach(o => { if (typeof o == "string") { const s = o === "" ? t : ba(t, o); s.classGroupId = n; return } if (typeof o == "function") { if (L0(o)) { oi(o(r), t, n, r); return } t.validators.push({ validator: o, classGroupId: n }); return } Object.entries(o).forEach(([s, i]) => { oi(i, ba(t, s), n, r) }) }) }, ba = (e, t) => { let n = e; return t.split(Zi).forEach(r => { n.nextPart.has(r) || n.nextPart.set(r, { nextPart: new Map, validators: [] }), n = n.nextPart.get(r) }), n }, L0 = e => e.isThemeGetter, M0 = (e, t) => t ? e.map(([n, r]) => { const o = r.map(s => typeof s == "string" ? t + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([i, l]) => [t + i, l])) : s); return [n, o] }) : e, R0 = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, n = new Map, r = new Map; const o = (s, i) => { n.set(s, i), t++, t > e && (t = 0, r = n, n = new Map) }; return { get(s) { let i = n.get(s); if (i !== void 0) return i; if ((i = r.get(s)) !== void 0) return o(s, i), i }, set(s, i) { n.has(s) ? n.set(s, i) : o(s, i) } } }, cf = "!", j0 = e => { const { separator: t, experimentalParseClassName: n } = e, r = t.length === 1, o = t[0], s = t.length, i = l => { const a = []; let u = 0, c = 0, f; for (let b = 0; b < l.length; b++) { let _ = l[b]; if (u === 0) { if (_ === o && (r || l.slice(b, b + s) === t)) { a.push(l.slice(c, b)), c = b + s; continue } if (_ === "/") { f = b; continue } } _ === "[" ? u++ : _ === "]" && u-- } const d = a.length === 0 ? l : l.substring(c), h = d.startsWith(cf), g = h ? d.substring(1) : d, p = f && f > c ? f - c : void 0; return { modifiers: a, hasImportantModifier: h, baseClassName: g, maybePostfixModifierPosition: p } }; return n ? l => n({ className: l, parseClassName: i }) : i }, N0 = e => { if (e.length <= 1) return e; const t = []; let n = []; return e.forEach(r => { r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r) }), t.push(...n.sort()), t }, F0 = e => ({ cache: R0(e.cacheSize), parseClassName: j0(e), ...$0(e) }), B0 = /\s+/, H0 = (e, t) => { const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: o } = t, s = [], i = e.trim().split(B0); let l = ""; for (let a = i.length - 1; a >= 0; a -= 1) { const u = i[a], { modifiers: c, hasImportantModifier: f, baseClassName: d, maybePostfixModifierPosition: h } = n(u); let g = !!h, p = r(g ? d.substring(0, h) : d); if (!p) { if (!g) { l = u + (l.length > 0 ? " " + l : l); continue } if (p = r(d), !p) { l = u + (l.length > 0 ? " " + l : l); continue } g = !1 } const b = N0(c).join(":"), _ = f ? b + cf : b, C = _ + p; if (s.includes(C)) continue; s.push(C); const y = o(p, g); for (let w = 0; w < y.length; ++w) { const S = y[w]; s.push(_ + S) } l = u + (l.length > 0 ? " " + l : l) } return l }; function ro() { let e = 0, t, n, r = ""; for (; e < arguments.length;)(t = arguments[e++]) && (n = uf(t)) && (r && (r += " "), r += n); return r } const uf = e => { if (typeof e == "string") return e; let t, n = ""; for (let r = 0; r < e.length; r++)e[r] && (t = uf(e[r])) && (n && (n += " "), n += t); return n }; function va(e, ...t) { let n, r, o, s = i; function i(a) { const u = t.reduce((c, f) => f(c), e()); return n = F0(u), r = n.cache.get, o = n.cache.set, s = l, l(a) } function l(a) { const u = r(a); if (u) return u; const c = H0(a, n); return o(a, c), c } return function () { return s(ro.apply(null, arguments)) } } const ve = e => { const t = n => n[e] || []; return t.isThemeGetter = !0, t }, ff = /^\[(?:([a-z-]+):)?(.+)\]$/i, D0 = /^\d+\/\d+$/, U0 = new Set(["px", "full", "screen"]), z0 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, q0 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, W0 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, V0 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, G0 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, kt = e => In(e) || U0.has(e) || D0.test(e), Bt = e => Fn(e, "length", ty), In = e => !!e && !Number.isNaN(Number(e)), bs = e => Fn(e, "number", In), Kn = e => !!e && Number.isInteger(Number(e)), K0 = e => e.endsWith("%") && In(e.slice(0, -1)), re = e => ff.test(e), Ht = e => z0.test(e), J0 = new Set(["length", "size", "percentage"]), Z0 = e => Fn(e, J0, df), Q0 = e => Fn(e, "position", df), Y0 = new Set(["image", "url"]), X0 = e => Fn(e, Y0, ry), ey = e => Fn(e, "", ny), Jn = () => !0, Fn = (e, t, n) => { const r = ff.exec(e); return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1 }, ty = e => q0.test(e) && !W0.test(e), df = () => !1, ny = e => V0.test(e), ry = e => G0.test(e), wa = () => { const e = ve("colors"), t = ve("spacing"), n = ve("blur"), r = ve("brightness"), o = ve("borderColor"), s = ve("borderRadius"), i = ve("borderSpacing"), l = ve("borderWidth"), a = ve("contrast"), u = ve("grayscale"), c = ve("hueRotate"), f = ve("invert"), d = ve("gap"), h = ve("gradientColorStops"), g = ve("gradientColorStopPositions"), p = ve("inset"), b = ve("margin"), _ = ve("opacity"), C = ve("padding"), y = ve("saturate"), w = ve("scale"), S = ve("sepia"), k = ve("skew"), M = ve("space"), D = ve("translate"), A = () => ["auto", "contain", "none"], P = () => ["auto", "hidden", "clip", "visible", "scroll"], W = () => ["auto", re, t], T = () => [re, t], U = () => ["", kt, Bt], te = () => ["auto", In, re], oe = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], F = () => ["solid", "dashed", "dotted", "double", "none"], Z = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], q = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], ge = () => ["", "0", re], ht = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], ee = () => [In, re]; return { cacheSize: 500, separator: ":", theme: { colors: [Jn], spacing: [kt, Bt], blur: ["none", "", Ht, re], brightness: ee(), borderColor: [e], borderRadius: ["none", "", "full", Ht, re], borderSpacing: T(), borderWidth: U(), contrast: ee(), grayscale: ge(), hueRotate: ee(), invert: ge(), gap: T(), gradientColorStops: [e], gradientColorStopPositions: [K0, Bt], inset: W(), margin: W(), opacity: ee(), padding: T(), saturate: ee(), scale: ee(), sepia: ge(), skew: ee(), space: T(), translate: T() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", re] }], container: ["container"], columns: [{ columns: [Ht] }], "break-after": [{ "break-after": ht() }], "break-before": [{ "break-before": ht() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...oe(), re] }], overflow: [{ overflow: P() }], "overflow-x": [{ "overflow-x": P() }], "overflow-y": [{ "overflow-y": P() }], overscroll: [{ overscroll: A() }], "overscroll-x": [{ "overscroll-x": A() }], "overscroll-y": [{ "overscroll-y": A() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [p] }], "inset-x": [{ "inset-x": [p] }], "inset-y": [{ "inset-y": [p] }], start: [{ start: [p] }], end: [{ end: [p] }], top: [{ top: [p] }], right: [{ right: [p] }], bottom: [{ bottom: [p] }], left: [{ left: [p] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", Kn, re] }], basis: [{ basis: W() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", re] }], grow: [{ grow: ge() }], shrink: [{ shrink: ge() }], order: [{ order: ["first", "last", "none", Kn, re] }], "grid-cols": [{ "grid-cols": [Jn] }], "col-start-end": [{ col: ["auto", { span: ["full", Kn, re] }, re] }], "col-start": [{ "col-start": te() }], "col-end": [{ "col-end": te() }], "grid-rows": [{ "grid-rows": [Jn] }], "row-start-end": [{ row: ["auto", { span: [Kn, re] }, re] }], "row-start": [{ "row-start": te() }], "row-end": [{ "row-end": te() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", re] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", re] }], gap: [{ gap: [d] }], "gap-x": [{ "gap-x": [d] }], "gap-y": [{ "gap-y": [d] }], "justify-content": [{ justify: ["normal", ...q()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...q(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...q(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [C] }], px: [{ px: [C] }], py: [{ py: [C] }], ps: [{ ps: [C] }], pe: [{ pe: [C] }], pt: [{ pt: [C] }], pr: [{ pr: [C] }], pb: [{ pb: [C] }], pl: [{ pl: [C] }], m: [{ m: [b] }], mx: [{ mx: [b] }], my: [{ my: [b] }], ms: [{ ms: [b] }], me: [{ me: [b] }], mt: [{ mt: [b] }], mr: [{ mr: [b] }], mb: [{ mb: [b] }], ml: [{ ml: [b] }], "space-x": [{ "space-x": [M] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [M] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", re, t] }], "min-w": [{ "min-w": [re, t, "min", "max", "fit"] }], "max-w": [{ "max-w": [re, t, "none", "full", "min", "max", "fit", "prose", { screen: [Ht] }, Ht] }], h: [{ h: [re, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [re, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [re, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [re, t, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", Ht, Bt] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", bs] }], "font-family": [{ font: [Jn] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", re] }], "line-clamp": [{ "line-clamp": ["none", In, bs] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", kt, re] }], "list-image": [{ "list-image": ["none", re] }], "list-style-type": [{ list: ["none", "disc", "decimal", re] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [e] }], "placeholder-opacity": [{ "placeholder-opacity": [_] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [e] }], "text-opacity": [{ "text-opacity": [_] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...F(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", kt, Bt] }], "underline-offset": [{ "underline-offset": ["auto", kt, re] }], "text-decoration-color": [{ decoration: [e] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: T() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", re] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", re] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [_] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...oe(), Q0] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", Z0] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, X0] }], "bg-color": [{ bg: [e] }], "gradient-from-pos": [{ from: [g] }], "gradient-via-pos": [{ via: [g] }], "gradient-to-pos": [{ to: [g] }], "gradient-from": [{ from: [h] }], "gradient-via": [{ via: [h] }], "gradient-to": [{ to: [h] }], rounded: [{ rounded: [s] }], "rounded-s": [{ "rounded-s": [s] }], "rounded-e": [{ "rounded-e": [s] }], "rounded-t": [{ "rounded-t": [s] }], "rounded-r": [{ "rounded-r": [s] }], "rounded-b": [{ "rounded-b": [s] }], "rounded-l": [{ "rounded-l": [s] }], "rounded-ss": [{ "rounded-ss": [s] }], "rounded-se": [{ "rounded-se": [s] }], "rounded-ee": [{ "rounded-ee": [s] }], "rounded-es": [{ "rounded-es": [s] }], "rounded-tl": [{ "rounded-tl": [s] }], "rounded-tr": [{ "rounded-tr": [s] }], "rounded-br": [{ "rounded-br": [s] }], "rounded-bl": [{ "rounded-bl": [s] }], "border-w": [{ border: [l] }], "border-w-x": [{ "border-x": [l] }], "border-w-y": [{ "border-y": [l] }], "border-w-s": [{ "border-s": [l] }], "border-w-e": [{ "border-e": [l] }], "border-w-t": [{ "border-t": [l] }], "border-w-r": [{ "border-r": [l] }], "border-w-b": [{ "border-b": [l] }], "border-w-l": [{ "border-l": [l] }], "border-opacity": [{ "border-opacity": [_] }], "border-style": [{ border: [...F(), "hidden"] }], "divide-x": [{ "divide-x": [l] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [l] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [_] }], "divide-style": [{ divide: F() }], "border-color": [{ border: [o] }], "border-color-x": [{ "border-x": [o] }], "border-color-y": [{ "border-y": [o] }], "border-color-s": [{ "border-s": [o] }], "border-color-e": [{ "border-e": [o] }], "border-color-t": [{ "border-t": [o] }], "border-color-r": [{ "border-r": [o] }], "border-color-b": [{ "border-b": [o] }], "border-color-l": [{ "border-l": [o] }], "divide-color": [{ divide: [o] }], "outline-style": [{ outline: ["", ...F()] }], "outline-offset": [{ "outline-offset": [kt, re] }], "outline-w": [{ outline: [kt, Bt] }], "outline-color": [{ outline: [e] }], "ring-w": [{ ring: U() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [e] }], "ring-opacity": [{ "ring-opacity": [_] }], "ring-offset-w": [{ "ring-offset": [kt, Bt] }], "ring-offset-color": [{ "ring-offset": [e] }], shadow: [{ shadow: ["", "inner", "none", Ht, ey] }], "shadow-color": [{ shadow: [Jn] }], opacity: [{ opacity: [_] }], "mix-blend": [{ "mix-blend": [...Z(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": Z() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [n] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [a] }], "drop-shadow": [{ "drop-shadow": ["", "none", Ht, re] }], grayscale: [{ grayscale: [u] }], "hue-rotate": [{ "hue-rotate": [c] }], invert: [{ invert: [f] }], saturate: [{ saturate: [y] }], sepia: [{ sepia: [S] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [n] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [a] }], "backdrop-grayscale": [{ "backdrop-grayscale": [u] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [c] }], "backdrop-invert": [{ "backdrop-invert": [f] }], "backdrop-opacity": [{ "backdrop-opacity": [_] }], "backdrop-saturate": [{ "backdrop-saturate": [y] }], "backdrop-sepia": [{ "backdrop-sepia": [S] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [i] }], "border-spacing-x": [{ "border-spacing-x": [i] }], "border-spacing-y": [{ "border-spacing-y": [i] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", re] }], duration: [{ duration: ee() }], ease: [{ ease: ["linear", "in", "out", "in-out", re] }], delay: [{ delay: ee() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", re] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [w] }], "scale-x": [{ "scale-x": [w] }], "scale-y": [{ "scale-y": [w] }], rotate: [{ rotate: [Kn, re] }], "translate-x": [{ "translate-x": [D] }], "translate-y": [{ "translate-y": [D] }], "skew-x": [{ "skew-x": [k] }], "skew-y": [{ "skew-y": [k] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", re] }], accent: [{ accent: ["auto", e] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", re] }], "caret-color": [{ caret: [e] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": T() }], "scroll-mx": [{ "scroll-mx": T() }], "scroll-my": [{ "scroll-my": T() }], "scroll-ms": [{ "scroll-ms": T() }], "scroll-me": [{ "scroll-me": T() }], "scroll-mt": [{ "scroll-mt": T() }], "scroll-mr": [{ "scroll-mr": T() }], "scroll-mb": [{ "scroll-mb": T() }], "scroll-ml": [{ "scroll-ml": T() }], "scroll-p": [{ "scroll-p": T() }], "scroll-px": [{ "scroll-px": T() }], "scroll-py": [{ "scroll-py": T() }], "scroll-ps": [{ "scroll-ps": T() }], "scroll-pe": [{ "scroll-pe": T() }], "scroll-pt": [{ "scroll-pt": T() }], "scroll-pr": [{ "scroll-pr": T() }], "scroll-pb": [{ "scroll-pb": T() }], "scroll-pl": [{ "scroll-pl": T() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", re] }], fill: [{ fill: [e, "none"] }], "stroke-w": [{ stroke: [kt, Bt, bs] }], stroke: [{ stroke: [e, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }, oy = (e, { cacheSize: t, prefix: n, separator: r, experimentalParseClassName: o, extend: s = {}, override: i = {} }) => { nr(e, "cacheSize", t), nr(e, "prefix", n), nr(e, "separator", r), nr(e, "experimentalParseClassName", o); for (const l in i) sy(e[l], i[l]); for (const l in s) iy(e[l], s[l]); return e }, nr = (e, t, n) => { n !== void 0 && (e[t] = n) }, sy = (e, t) => { if (t) for (const n in t) nr(e, n, t[n]) }, iy = (e, t) => { if (t) for (const n in t) { const r = t[n]; r !== void 0 && (e[n] = (e[n] || []).concat(r)) } }, ly = (e, ...t) => typeof e == "function" ? va(wa, e, ...t) : va(() => oy(wa(), e), ...t); function wn() { const e = he(); return e._appConfig || (e._appConfig = ut(pt)), e._appConfig } const ay = { ui: { primary: "primaryColor", gray: "neutral", button: { base: "transition", default: { size: "xl" }, variant: { link: "hover:opacity-70" } }, slideover: { overlay: { background: "dark:bg-black/40" }, background: "dark:bg-[#242424]" } } }, cy = { nuxt: {}, icon: { provider: "iconify", class: "", aliases: {}, iconifyApiEndpoint: "https://api.iconify.design", localApiEndpoint: "/api/_nuxt_icon", fallbackToApi: !0, cssSelectorPrefix: "i-", cssWherePseudo: !0, mode: "css", attrs: { "aria-hidden": !0 }, collections: ["academicons", "akar-icons", "ant-design", "arcticons", "basil", "bi", "bitcoin-icons", "bpmn", "brandico", "bx", "bxl", "bxs", "bytesize", "carbon", "catppuccin", "cbi", "charm", "ci", "cib", "cif", "cil", "circle-flags", "circum", "clarity", "codicon", "covid", "cryptocurrency", "cryptocurrency-color", "dashicons", "devicon", "devicon-plain", "ei", "el", "emojione", "emojione-monotone", "emojione-v1", "entypo", "entypo-social", "eos-icons", "ep", "et", "eva", "f7", "fa", "fa-brands", "fa-regular", "fa-solid", "fa6-brands", "fa6-regular", "fa6-solid", "fad", "fe", "feather", "file-icons", "flag", "flagpack", "flat-color-icons", "flat-ui", "flowbite", "fluent", "fluent-emoji", "fluent-emoji-flat", "fluent-emoji-high-contrast", "fluent-mdl2", "fontelico", "fontisto", "formkit", "foundation", "fxemoji", "gala", "game-icons", "geo", "gg", "gis", "gravity-ui", "gridicons", "grommet-icons", "guidance", "healthicons", "heroicons", "heroicons-outline", "heroicons-solid", "hugeicons", "humbleicons", "ic", "icomoon-free", "icon-park", "icon-park-outline", "icon-park-solid", "icon-park-twotone", "iconamoon", "iconoir", "icons8", "il", "ion", "iwwa", "jam", "la", "lets-icons", "line-md", "logos", "ls", "lucide", "lucide-lab", "mage", "majesticons", "maki", "map", "marketeq", "material-symbols", "material-symbols-light", "mdi", "mdi-light", "medical-icon", "memory", "meteocons", "mi", "mingcute", "mono-icons", "mynaui", "nimbus", "nonicons", "noto", "noto-v1", "octicon", "oi", "ooui", "openmoji", "oui", "pajamas", "pepicons", "pepicons-pencil", "pepicons-pop", "pepicons-print", "ph", "pixelarticons", "prime", "ps", "quill", "radix-icons", "raphael", "ri", "rivet-icons", "si-glyph", "simple-icons", "simple-line-icons", "skill-icons", "solar", "streamline", "streamline-emojis", "subway", "svg-spinners", "system-uicons", "tabler", "tdesign", "teenyicons", "token", "token-branded", "topcoat", "twemoji", "typcn", "uil", "uim", "uis", "uit", "uiw", "unjs", "vaadin", "vs", "vscode-icons", "websymbol", "weui", "whh", "wi", "wpf", "zmdi", "zondicons"], fetchTimeout: 1500 }, ui: { primary: "green", gray: "cool", colors: ["red", "orange", "amber", "yellow", "lime", "green", "emerald", "teal", "cyan", "sky", "blue", "indigo", "violet", "purple", "fuchsia", "pink", "rose", "primary-color", "primary"], strategy: "merge" } }, pt = rm(ay, cy); function pf(e, t) { const n = { ...e }; for (const r of t) delete n[r]; return n } function si(e, t, n) { typeof t == "string" && (t = t.split(".").map(o => { const s = Number(o); return Number.isNaN(s) ? o : s })); let r = e; for (const o of t) { if (r == null) return n; r = r[o] } return r !== void 0 ? r : n } const Qi = { to: { type: [String, Object], default: void 0, required: !1 }, href: { type: [String, Object], default: void 0, required: !1 }, target: { type: String, default: void 0, required: !1 }, rel: { type: String, default: void 0, required: !1 }, noRel: { type: Boolean, default: void 0, required: !1 }, prefetch: { type: Boolean, default: void 0, required: !1 }, noPrefetch: { type: Boolean, default: void 0, required: !1 }, activeClass: { type: String, default: void 0, required: !1 }, exactActiveClass: { type: String, default: void 0, required: !1 }, prefetchedClass: { type: String, default: void 0, required: !1 }, replace: { type: Boolean, default: void 0, required: !1 }, ariaCurrentValue: { type: String, default: void 0, required: !1 }, external: { type: Boolean, default: void 0, required: !1 } }, uy = e => Object.keys(Qi).reduce((n, r) => (e[r] !== void 0 && (n[r] = e[r]), n), {}); var Ja; const hf = ly(Ar({ extend: { classGroups: { icons: [e => e.startsWith("i-")] } } }, (Ja = pt.ui) == null ? void 0 : Ja.tailwindMerge)), fy = Ui((e, t, n, r) => { if (r === "default" || r.startsWith("default.") || r === "popper" || r.startsWith("popper.") || r.endsWith("avatar") && t === "size" || r.endsWith("chip") && t === "size" || r.endsWith("badge") && t === "size" || t === "color" || t === "variant") return !1; if (typeof e[t] == "string" && typeof n == "string" && e[t] && n) return e[t] = hf(e[t], n), !0 }); function Pr(e, ...t) { return e === "override" ? Ar({}, ...t) : fy({}, ...t) } const gf = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i; function xa(e) { return gf.test(e) ? dy(e) : e } function dy(e) { const t = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; e = e.replace(t, function (r, o, s, i) { return o + o + s + s + i + i }); const n = gf.exec(e); return n ? `${Number.parseInt(n[1], 16)} ${Number.parseInt(n[2], 16)} ${Number.parseInt(n[3], 16)}` : null } const py = "inherit", hy = "currentColor", gy = "transparent", my = "#000", yy = "#fff", by = { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a", 950: "#020617" }, vy = { 50: "rgb(var(--color-gray-50) / <alpha-value>)", 100: "rgb(var(--color-gray-100) / <alpha-value>)", 200: "rgb(var(--color-gray-200) / <alpha-value>)", 300: "rgb(var(--color-gray-300) / <alpha-value>)", 400: "rgb(var(--color-gray-400) / <alpha-value>)", 500: "rgb(var(--color-gray-500) / <alpha-value>)", 600: "rgb(var(--color-gray-600) / <alpha-value>)", 700: "rgb(var(--color-gray-700) / <alpha-value>)", 800: "rgb(var(--color-gray-800) / <alpha-value>)", 900: "rgb(var(--color-gray-900) / <alpha-value>)", 950: "rgb(var(--color-gray-950) / <alpha-value>)" }, wy = { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b", 950: "#09090b" }, xy = { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717", 950: "#0a0a0a" }, _y = { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917", 950: "#0c0a09" }, Sy = { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d", 950: "#450a0a" }, Cy = { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12", 950: "#431407" }, ky = { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f", 950: "#451a03" }, Ey = { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12", 950: "#422006" }, Ty = { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314", 950: "#1a2e05" }, Ay = { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d", 950: "#052e16" }, Py = { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b", 950: "#022c22" }, $y = { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a", 950: "#042f2e" }, Oy = { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63", 950: "#083344" }, Iy = { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e", 950: "#082f49" }, Ly = { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a", 950: "#172554" }, My = { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81", 950: "#1e1b4b" }, Ry = { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95", 950: "#2e1065" }, jy = { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87", 950: "#3b0764" }, Ny = { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75", 950: "#4a044e" }, Fy = { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843", 950: "#500724" }, By = { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337", 950: "#4c0519" }, Hy = { 50: "#81d197", 100: "#72cc8a", 200: "#54c172", 300: "#3fad5d", 400: "#348f4d", 500: "#256637", 600: "#163d21", 700: "#07140b", 800: "#000000", 900: "#000000" }, Dy = { 50: "rgb(var(--color-primary-50) / <alpha-value>)", 100: "rgb(var(--color-primary-100) / <alpha-value>)", 200: "rgb(var(--color-primary-200) / <alpha-value>)", 300: "rgb(var(--color-primary-300) / <alpha-value>)", 400: "rgb(var(--color-primary-400) / <alpha-value>)", 500: "rgb(var(--color-primary-500) / <alpha-value>)", 600: "rgb(var(--color-primary-600) / <alpha-value>)", 700: "rgb(var(--color-primary-700) / <alpha-value>)", 800: "rgb(var(--color-primary-800) / <alpha-value>)", 900: "rgb(var(--color-primary-900) / <alpha-value>)", 950: "rgb(var(--color-primary-950) / <alpha-value>)", DEFAULT: "rgb(var(--color-primary-DEFAULT) / <alpha-value>)" }, Uy = { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827", 950: "#030712" }, Wr = { inherit: py, current: hy, transparent: gy, black: my, white: yy, slate: by, gray: vy, zinc: wy, neutral: xy, stone: _y, red: Sy, orange: Cy, amber: ky, yellow: Ey, lime: Ty, green: Ay, emerald: Py, teal: $y, cyan: Oy, sky: Iy, blue: Ly, indigo: My, violet: Ry, purple: jy, fuchsia: Ny, pink: Fy, rose: By, primaryColor: Hy, primary: Dy, cool: Uy }, zy = et(() => {
  const e = wn(), t = he(), n = R(() => {
    const o = si(Wr, e.ui.primary), s = si(Wr, e.ui.gray); return o || console.warn(`[@nuxt/ui] Primary color '${e.ui.primary}' not found in Tailwind config`), s || console.warn(`[@nuxt/ui] Gray color '${e.ui.gray}' not found in Tailwind config`), `:root {
${Object.entries(o || Wr.green).map(([i, l]) => `--color-primary-${i}: ${xa(l)};`).join(`
`)}
--color-primary-DEFAULT: var(--color-primary-500);

${Object.entries(s || Wr.cool).map(([i, l]) => `--color-gray-${i}: ${xa(l)};`).join(`
`)}
}

.dark {
  --color-primary-DEFAULT: var(--color-primary-400);
}
`}), r = { style: [{ innerHTML: () => n.value, tagPriority: -2, id: "nuxt-ui-colors" }] }; if (t.isHydrating && !t.payload.serverRendered) { const o = document.createElement("style"); o.innerHTML = n.value, o.setAttribute("data-nuxt-ui-colors", ""), document.head.appendChild(o), r.script = [{ innerHTML: "document.head.removeChild(document.querySelector('[data-nuxt-ui-colors]'))" }] } Ym(r)
}), qy = "__NUXT_COLOR_MODE__", vs = "nuxt-color-mode", Wy = "localStorage", Vy = "$s"; function Gy(...e) { const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0; typeof e[0] != "string" && e.unshift(t); const [n, r] = e; if (!n || typeof n != "string") throw new TypeError("[nuxt] [useState] key must be a string: " + n); if (r !== void 0 && typeof r != "function") throw new Error("[nuxt] [useState] init must be a function: " + r); const o = Vy + n, s = he(), i = yn(s.payload.state, o); if (i.value === void 0 && r) { const l = r(); if (Ee(l)) return s.payload.state[o] = l, l; i.value = l } return i } const Et = window[qy] || {}, Ky = et(e => { const t = Gy("color-mode", () => ut({ preference: Et.preference, value: Et.value, unknown: !1, forced: !1 })).value; dt().afterEach(s => { const i = s.meta.colorMode; i && i !== "system" ? (t.value = i, t.forced = !0) : (i === "system" && console.warn("You cannot force the colorMode to system at the page level."), t.forced = !1, t.value = t.preference === "system" ? Et.getColorScheme() : t.preference) }); let n; function r() { n || !window.matchMedia || (n = window.matchMedia("(prefers-color-scheme: dark)"), n.addEventListener("change", () => { !t.forced && t.preference === "system" && (t.value = Et.getColorScheme()) })) } function o(s, i) { var l, a; switch (s) { case "cookie": window.document.cookie = vs + "=" + i; break; case "sessionStorage": (l = window.sessionStorage) == null || l.setItem(vs, i); break; case "localStorage": default: (a = window.localStorage) == null || a.setItem(vs, i) } } We(() => t.preference, s => { t.forced || (s === "system" ? (t.value = Et.getColorScheme(), r()) : t.value = s, o(Wy, s)) }, { immediate: !0 }), We(() => t.value, (s, i) => { Et.removeColorScheme(i), Et.addColorScheme(s) }), t.preference === "system" && r(), e.hook("app:mounted", () => { t.unknown && (t.preference = Et.preference, t.value = Et.value, t.unknown = !1) }), e.provide("colorMode", t) }), mf = /^[a-z0-9]+(-[a-z0-9]+)*$/, $r = (e, t, n, r = "") => { const o = e.split(":"); if (e.slice(0, 1) === "@") { if (o.length < 2 || o.length > 3) return null; r = o.shift().slice(1) } if (o.length > 3 || !o.length) return null; if (o.length > 1) { const l = o.pop(), a = o.pop(), u = { provider: o.length > 0 ? o[0] : r, prefix: a, name: l }; return t && !oo(u) ? null : u } const s = o[0], i = s.split("-"); if (i.length > 1) { const l = { provider: r, prefix: i.shift(), name: i.join("-") }; return t && !oo(l) ? null : l } if (n && r === "") { const l = { provider: r, prefix: "", name: s }; return t && !oo(l, n) ? null : l } return null }, oo = (e, t) => e ? !!((t && e.prefix === "" || e.prefix) && e.name) : !1, yf = Object.freeze({ left: 0, top: 0, width: 16, height: 16 }), Eo = Object.freeze({ rotate: 0, vFlip: !1, hFlip: !1 }), Bn = Object.freeze({ ...yf, ...Eo }), ii = Object.freeze({ ...Bn, body: "", hidden: !1 }); function Jy(e, t) { const n = {}; !e.hFlip != !t.hFlip && (n.hFlip = !0), !e.vFlip != !t.vFlip && (n.vFlip = !0); const r = ((e.rotate || 0) + (t.rotate || 0)) % 4; return r && (n.rotate = r), n } function _a(e, t) { const n = Jy(e, t); for (const r in ii) r in Eo ? r in e && !(r in n) && (n[r] = Eo[r]) : r in t ? n[r] = t[r] : r in e && (n[r] = e[r]); return n } function Zy(e, t) { const n = e.icons, r = e.aliases || Object.create(null), o = Object.create(null); function s(i) { if (n[i]) return o[i] = []; if (!(i in o)) { o[i] = null; const l = r[i] && r[i].parent, a = l && s(l); a && (o[i] = [l].concat(a)) } return o[i] } return Object.keys(n).concat(Object.keys(r)).forEach(s), o } function Qy(e, t, n) { const r = e.icons, o = e.aliases || Object.create(null); let s = {}; function i(l) { s = _a(r[l] || o[l], s) } return i(t), n.forEach(i), _a(e, s) } function bf(e, t) { const n = []; if (typeof e != "object" || typeof e.icons != "object") return n; e.not_found instanceof Array && e.not_found.forEach(o => { t(o, null), n.push(o) }); const r = Zy(e); for (const o in r) { const s = r[o]; s && (t(o, Qy(e, o, s)), n.push(o)) } return n } const Yy = { provider: "", aliases: {}, not_found: {}, ...yf }; function ws(e, t) { for (const n in t) if (n in e && typeof e[n] != typeof t[n]) return !1; return !0 } function vf(e) { if (typeof e != "object" || e === null) return null; const t = e; if (typeof t.prefix != "string" || !e.icons || typeof e.icons != "object" || !ws(e, Yy)) return null; const n = t.icons; for (const o in n) { const s = n[o]; if (!o || typeof s.body != "string" || !ws(s, ii)) return null } const r = t.aliases || Object.create(null); for (const o in r) { const s = r[o], i = s.parent; if (!o || typeof i != "string" || !n[i] && !r[i] || !ws(s, ii)) return null } return t } const Sa = Object.create(null); function Xy(e, t) { return { provider: e, prefix: t, icons: Object.create(null), missing: new Set } } function bn(e, t) { const n = Sa[e] || (Sa[e] = Object.create(null)); return n[t] || (n[t] = Xy(e, t)) } function wf(e, t) { return vf(t) ? bf(t, (n, r) => { r ? e.icons[n] = r : e.missing.add(n) }) : [] } function eb(e, t, n) { try { if (typeof n.body == "string") return e.icons[t] = { ...n }, !0 } catch { } return !1 } let xr = !1; function xf(e) { return typeof e == "boolean" && (xr = e), xr } function Yi(e) { const t = typeof e == "string" ? $r(e, !0, xr) : e; if (t) { const n = bn(t.provider, t.prefix), r = t.name; return n.icons[r] || (n.missing.has(r) ? null : void 0) } } function Xi(e, t) { const n = $r(e, !0, xr); if (!n) return !1; const r = bn(n.provider, n.prefix); return t ? eb(r, n.name, t) : (r.missing.add(n.name), !0) } function tb(e, t) { if (typeof e != "object") return !1; if (typeof t != "string" && (t = e.provider || ""), xr && !t && !e.prefix) { let o = !1; return vf(e) && (e.prefix = "", bf(e, (s, i) => { Xi(s, i) && (o = !0) })), o } const n = e.prefix; if (!oo({ prefix: n, name: "a" })) return !1; const r = bn(t, n); return !!wf(r, e) } function li(e) { const t = Yi(e); return t && { ...Bn, ...t } } const _f = Object.freeze({ width: null, height: null }), Sf = Object.freeze({ ..._f, ...Eo }), nb = /(-?[0-9.]*[0-9]+[0-9.]*)/g, rb = /^-?[0-9.]*[0-9]+[0-9.]*$/g; function Ca(e, t, n) { if (t === 1) return e; if (n = n || 100, typeof e == "number") return Math.ceil(e * t * n) / n; if (typeof e != "string") return e; const r = e.split(nb); if (r === null || !r.length) return e; const o = []; let s = r.shift(), i = rb.test(s); for (; ;) { if (i) { const l = parseFloat(s); isNaN(l) ? o.push(s) : o.push(Math.ceil(l * t * n) / n) } else o.push(s); if (s = r.shift(), s === void 0) return o.join(""); i = !i } } function ob(e, t = "defs") { let n = ""; const r = e.indexOf("<" + t); for (; r >= 0;) { const o = e.indexOf(">", r), s = e.indexOf("</" + t); if (o === -1 || s === -1) break; const i = e.indexOf(">", s); if (i === -1) break; n += e.slice(o + 1, s).trim(), e = e.slice(0, r).trim() + e.slice(i + 1) } return { defs: n, content: e } } function sb(e, t) { return e ? "<defs>" + e + "</defs>" + t : t } function ib(e, t, n) { const r = ob(e); return sb(r.defs, t + r.content + n) } const lb = e => e === "unset" || e === "undefined" || e === "none"; function ab(e, t) { const n = { ...Bn, ...e }, r = { ...Sf, ...t }, o = { left: n.left, top: n.top, width: n.width, height: n.height }; let s = n.body;[n, r].forEach(p => { const b = [], _ = p.hFlip, C = p.vFlip; let y = p.rotate; _ ? C ? y += 2 : (b.push("translate(" + (o.width + o.left).toString() + " " + (0 - o.top).toString() + ")"), b.push("scale(-1 1)"), o.top = o.left = 0) : C && (b.push("translate(" + (0 - o.left).toString() + " " + (o.height + o.top).toString() + ")"), b.push("scale(1 -1)"), o.top = o.left = 0); let w; switch (y < 0 && (y -= Math.floor(y / 4) * 4), y = y % 4, y) { case 1: w = o.height / 2 + o.top, b.unshift("rotate(90 " + w.toString() + " " + w.toString() + ")"); break; case 2: b.unshift("rotate(180 " + (o.width / 2 + o.left).toString() + " " + (o.height / 2 + o.top).toString() + ")"); break; case 3: w = o.width / 2 + o.left, b.unshift("rotate(-90 " + w.toString() + " " + w.toString() + ")"); break }y % 2 === 1 && (o.left !== o.top && (w = o.left, o.left = o.top, o.top = w), o.width !== o.height && (w = o.width, o.width = o.height, o.height = w)), b.length && (s = ib(s, '<g transform="' + b.join(" ") + '">', "</g>")) }); const i = r.width, l = r.height, a = o.width, u = o.height; let c, f; i === null ? (f = l === null ? "1em" : l === "auto" ? u : l, c = Ca(f, a / u)) : (c = i === "auto" ? a : i, f = l === null ? Ca(c, u / a) : l === "auto" ? u : l); const d = {}, h = (p, b) => { lb(b) || (d[p] = b.toString()) }; h("width", c), h("height", f); const g = [o.left, o.top, a, u]; return d.viewBox = g.join(" "), { attributes: d, viewBox: g, body: s } } const cb = /\sid="(\S+)"/g, ub = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16); let fb = 0; function db(e, t = ub) { const n = []; let r; for (; r = cb.exec(e);)n.push(r[1]); if (!n.length) return e; const o = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16); return n.forEach(s => { const i = typeof t == "function" ? t(s) : t + (fb++).toString(), l = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); e = e.replace(new RegExp('([#;"])(' + l + ')([")]|\\.[a-z])', "g"), "$1" + i + o + "$3") }), e = e.replace(new RegExp(o, "g"), ""), e } const ai = Object.create(null); function Cf(e, t) { ai[e] = t } function ci(e) { return ai[e] || ai[""] } function el(e) { let t; if (typeof e.resources == "string") t = [e.resources]; else if (t = e.resources, !(t instanceof Array) || !t.length) return null; return { resources: t, path: e.path || "/", maxURL: e.maxURL || 500, rotate: e.rotate || 750, timeout: e.timeout || 5e3, random: e.random === !0, index: e.index || 0, dataAfterTimeout: e.dataAfterTimeout !== !1 } } const Vo = Object.create(null), Zn = ["https://api.simplesvg.com", "https://api.unisvg.com"], so = []; for (; Zn.length > 0;)Zn.length === 1 || Math.random() > .5 ? so.push(Zn.shift()) : so.push(Zn.pop()); Vo[""] = el({ resources: ["https://api.iconify.design"].concat(so) }); function kf(e, t) { const n = el(t); return n === null ? !1 : (Vo[e] = n, !0) } function Go(e) { return Vo[e] } function pb() { return Object.keys(Vo) } const hb = () => { let e; try { if (e = fetch, typeof e == "function") return e } catch { } }; let To = hb(); function gb(e) { To = e } function mb() { return To } function yb(e, t) { const n = Go(e); if (!n) return 0; let r; if (!n.maxURL) r = 0; else { let o = 0; n.resources.forEach(i => { o = Math.max(o, i.length) }); const s = t + ".json?icons="; r = n.maxURL - o - n.path.length - s.length } return r } function bb(e) { return e === 404 } const vb = (e, t, n) => { const r = [], o = yb(e, t), s = "icons"; let i = { type: s, provider: e, prefix: t, icons: [] }, l = 0; return n.forEach((a, u) => { l += a.length + 1, l >= o && u > 0 && (r.push(i), i = { type: s, provider: e, prefix: t, icons: [] }, l = a.length), i.icons.push(a) }), r.push(i), r }; function wb(e) { if (typeof e == "string") { const t = Go(e); if (t) return t.path } return "/" } const xb = (e, t, n) => { if (!To) { n("abort", 424); return } let r = wb(t.provider); switch (t.type) { case "icons": { const s = t.prefix, l = t.icons.join(","), a = new URLSearchParams({ icons: l }); r += s + ".json?" + a.toString(); break } case "custom": { const s = t.uri; r += s.slice(0, 1) === "/" ? s.slice(1) : s; break } default: n("abort", 400); return }let o = 503; To(e + r).then(s => { const i = s.status; if (i !== 200) { setTimeout(() => { n(bb(i) ? "abort" : "next", i) }); return } return o = 501, s.json() }).then(s => { if (typeof s != "object" || s === null) { setTimeout(() => { s === 404 ? n("abort", s) : n("next", o) }); return } setTimeout(() => { n("success", s) }) }).catch(() => { n("next", o) }) }, _b = { prepare: vb, send: xb }; function Sb(e) { const t = { loaded: [], missing: [], pending: [] }, n = Object.create(null); e.sort((o, s) => o.provider !== s.provider ? o.provider.localeCompare(s.provider) : o.prefix !== s.prefix ? o.prefix.localeCompare(s.prefix) : o.name.localeCompare(s.name)); let r = { provider: "", prefix: "", name: "" }; return e.forEach(o => { if (r.name === o.name && r.prefix === o.prefix && r.provider === o.provider) return; r = o; const s = o.provider, i = o.prefix, l = o.name, a = n[s] || (n[s] = Object.create(null)), u = a[i] || (a[i] = bn(s, i)); let c; l in u.icons ? c = t.loaded : i === "" || u.missing.has(l) ? c = t.missing : c = t.pending; const f = { provider: s, prefix: i, name: l }; c.push(f) }), t } function Ef(e, t) { e.forEach(n => { const r = n.loaderCallbacks; r && (n.loaderCallbacks = r.filter(o => o.id !== t)) }) } function Cb(e) { e.pendingCallbacksFlag || (e.pendingCallbacksFlag = !0, setTimeout(() => { e.pendingCallbacksFlag = !1; const t = e.loaderCallbacks ? e.loaderCallbacks.slice(0) : []; if (!t.length) return; let n = !1; const r = e.provider, o = e.prefix; t.forEach(s => { const i = s.icons, l = i.pending.length; i.pending = i.pending.filter(a => { if (a.prefix !== o) return !0; const u = a.name; if (e.icons[u]) i.loaded.push({ provider: r, prefix: o, name: u }); else if (e.missing.has(u)) i.missing.push({ provider: r, prefix: o, name: u }); else return n = !0, !0; return !1 }), i.pending.length !== l && (n || Ef([e], s.id), s.callback(i.loaded.slice(0), i.missing.slice(0), i.pending.slice(0), s.abort)) }) })) } let kb = 0; function Eb(e, t, n) { const r = kb++, o = Ef.bind(null, n, r); if (!t.pending.length) return o; const s = { id: r, icons: t, callback: e, abort: o }; return n.forEach(i => { (i.loaderCallbacks || (i.loaderCallbacks = [])).push(s) }), o } function Tb(e, t = !0, n = !1) { const r = []; return e.forEach(o => { const s = typeof o == "string" ? $r(o, t, n) : o; s && r.push(s) }), r } var Ab = { resources: [], index: 0, timeout: 2e3, rotate: 750, random: !1, dataAfterTimeout: !1 }; function Pb(e, t, n, r) { const o = e.resources.length, s = e.random ? Math.floor(Math.random() * o) : e.index; let i; if (e.random) { let k = e.resources.slice(0); for (i = []; k.length > 1;) { const M = Math.floor(Math.random() * k.length); i.push(k[M]), k = k.slice(0, M).concat(k.slice(M + 1)) } i = i.concat(k) } else i = e.resources.slice(s).concat(e.resources.slice(0, s)); const l = Date.now(); let a = "pending", u = 0, c, f = null, d = [], h = []; typeof r == "function" && h.push(r); function g() { f && (clearTimeout(f), f = null) } function p() { a === "pending" && (a = "aborted"), g(), d.forEach(k => { k.status === "pending" && (k.status = "aborted") }), d = [] } function b(k, M) { M && (h = []), typeof k == "function" && h.push(k) } function _() { return { startTime: l, payload: t, status: a, queriesSent: u, queriesPending: d.length, subscribe: b, abort: p } } function C() { a = "failed", h.forEach(k => { k(void 0, c) }) } function y() { d.forEach(k => { k.status === "pending" && (k.status = "aborted") }), d = [] } function w(k, M, D) { const A = M !== "success"; switch (d = d.filter(P => P !== k), a) { case "pending": break; case "failed": if (A || !e.dataAfterTimeout) return; break; default: return }if (M === "abort") { c = D, C(); return } if (A) { c = D, d.length || (i.length ? S() : C()); return } if (g(), y(), !e.random) { const P = e.resources.indexOf(k.resource); P !== -1 && P !== e.index && (e.index = P) } a = "completed", h.forEach(P => { P(D) }) } function S() { if (a !== "pending") return; g(); const k = i.shift(); if (k === void 0) { if (d.length) { f = setTimeout(() => { g(), a === "pending" && (y(), C()) }, e.timeout); return } C(); return } const M = { status: "pending", resource: k, callback: (D, A) => { w(M, D, A) } }; d.push(M), u++, f = setTimeout(S, e.rotate), n(k, t, M.callback) } return setTimeout(S), _ } function Tf(e) { const t = { ...Ab, ...e }; let n = []; function r() { n = n.filter(l => l().status === "pending") } function o(l, a, u) { const c = Pb(t, l, a, (f, d) => { r(), u && u(f, d) }); return n.push(c), c } function s(l) { return n.find(a => l(a)) || null } return { query: o, find: s, setIndex: l => { t.index = l }, getIndex: () => t.index, cleanup: r } } function ka() { } const xs = Object.create(null); function $b(e) { if (!xs[e]) { const t = Go(e); if (!t) return; const n = Tf(t), r = { config: t, redundancy: n }; xs[e] = r } return xs[e] } function Af(e, t, n) { let r, o; if (typeof e == "string") { const s = ci(e); if (!s) return n(void 0, 424), ka; o = s.send; const i = $b(e); i && (r = i.redundancy) } else { const s = el(e); if (s) { r = Tf(s); const i = e.resources ? e.resources[0] : "", l = ci(i); l && (o = l.send) } } return !r || !o ? (n(void 0, 424), ka) : r.query(t, o, n)().abort } function Ea() { } function Ob(e) { e.iconsLoaderFlag || (e.iconsLoaderFlag = !0, setTimeout(() => { e.iconsLoaderFlag = !1, Cb(e) })) } function Ib(e) { const t = [], n = []; return e.forEach(r => { (r.match(mf) ? t : n).push(r) }), { valid: t, invalid: n } } function Qn(e, t, n) { function r() { const o = e.pendingIcons; t.forEach(s => { o && o.delete(s), e.icons[s] || e.missing.add(s) }) } if (n && typeof n == "object") try { if (!wf(e, n).length) { r(); return } } catch (o) { console.error(o) } r(), Ob(e) } function Ta(e, t) { e instanceof Promise ? e.then(n => { t(n) }).catch(() => { t(null) }) : t(e) } function Lb(e, t) { e.iconsToLoad ? e.iconsToLoad = e.iconsToLoad.concat(t).sort() : e.iconsToLoad = t, e.iconsQueueFlag || (e.iconsQueueFlag = !0, setTimeout(() => { e.iconsQueueFlag = !1; const { provider: n, prefix: r } = e, o = e.iconsToLoad; if (delete e.iconsToLoad, !o || !o.length) return; const s = e.loadIcon; if (e.loadIcons && (o.length > 1 || !s)) { Ta(e.loadIcons(o, r, n), c => { Qn(e, o, c) }); return } if (s) { o.forEach(c => { const f = s(c, r, n); Ta(f, d => { const h = d ? { prefix: r, icons: { [c]: d } } : null; Qn(e, [c], h) }) }); return } const { valid: i, invalid: l } = Ib(o); if (l.length && Qn(e, l, null), !i.length) return; const a = r.match(mf) ? ci(n) : null; if (!a) { Qn(e, i, null); return } a.prepare(n, r, i).forEach(c => { Af(n, c, f => { Qn(e, c.icons, f) }) }) })) } const Pf = (e, t) => { const n = Tb(e, !0, xf()), r = Sb(n); if (!r.pending.length) { let a = !0; return t && setTimeout(() => { a && t(r.loaded, r.missing, r.pending, Ea) }), () => { a = !1 } } const o = Object.create(null), s = []; let i, l; return r.pending.forEach(a => { const { provider: u, prefix: c } = a; if (c === l && u === i) return; i = u, l = c, s.push(bn(u, c)); const f = o[u] || (o[u] = Object.create(null)); f[c] || (f[c] = []) }), r.pending.forEach(a => { const { provider: u, prefix: c, name: f } = a, d = bn(u, c), h = d.pendingIcons || (d.pendingIcons = new Set); h.has(f) || (h.add(f), o[u][c].push(f)) }), s.forEach(a => { const u = o[a.provider][a.prefix]; u.length && Lb(a, u) }), t ? Eb(t, r, s) : Ea }, Mb = e => new Promise((t, n) => { const r = typeof e == "string" ? $r(e, !0) : e; if (!r) { n(e); return } Pf([r || e], o => { if (o.length && r) { const s = Yi(r); if (s) { t({ ...Bn, ...s }); return } } n(e) }) }); function Rb(e, t, n) { bn("", t).loadIcons = e } function jb(e, t) { const n = { ...e }; for (const r in t) { const o = t[r], s = typeof o; r in _f ? (o === null || o && (s === "string" || s === "number")) && (n[r] = o) : s === typeof n[r] && (n[r] = r === "rotate" ? o % 4 : o) } return n } const Nb = /[\s,]+/; function Fb(e, t) { t.split(Nb).forEach(n => { switch (n.trim()) { case "horizontal": e.hFlip = !0; break; case "vertical": e.vFlip = !0; break } }) } function Bb(e, t = 0) { const n = e.replace(/^-?[0-9.]*/, ""); function r(o) { for (; o < 0;)o += 4; return o % 4 } if (n === "") { const o = parseInt(e); return isNaN(o) ? 0 : r(o) } else if (n !== e) { let o = 0; switch (n) { case "%": o = 25; break; case "deg": o = 90 }if (o) { let s = parseFloat(e.slice(0, e.length - n.length)); return isNaN(s) ? 0 : (s = s / o, s % 1 === 0 ? r(s) : 0) } } return t } function Hb(e, t) { let n = e.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"'; for (const r in t) n += " " + r + '="' + t[r] + '"'; return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + e + "</svg>" } function Db(e) { return e.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ") } function Ub(e) { return "data:image/svg+xml," + Db(e) } function zb(e) { return 'url("' + Ub(e) + '")' } const Aa = { ...Sf, inline: !1 }, qb = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", "aria-hidden": !0, role: "img" }, Wb = { display: "inline-block" }, ui = { backgroundColor: "currentColor" }, $f = { backgroundColor: "transparent" }, Pa = { Image: "var(--svg)", Repeat: "no-repeat", Size: "100% 100%" }, $a = { webkitMask: ui, mask: ui, background: $f }; for (const e in $a) { const t = $a[e]; for (const n in Pa) t[e + n] = Pa[n] } const io = {};["horizontal", "vertical"].forEach(e => { const t = e.slice(0, 1) + "Flip"; io[e + "-flip"] = t, io[e.slice(0, 1) + "-flip"] = t, io[e + "Flip"] = t }); function Oa(e) { return e + (e.match(/^[-0-9.]+$/) ? "px" : "") } const Ia = (e, t) => { const n = jb(Aa, t), r = { ...qb }, o = t.mode || "svg", s = {}, i = t.style, l = typeof i == "object" && !(i instanceof Array) ? i : {}; for (let p in t) { const b = t[p]; if (b !== void 0) switch (p) { case "icon": case "style": case "onLoad": case "mode": case "ssr": break; case "inline": case "hFlip": case "vFlip": n[p] = b === !0 || b === "true" || b === 1; break; case "flip": typeof b == "string" && Fb(n, b); break; case "color": s.color = b; break; case "rotate": typeof b == "string" ? n[p] = Bb(b) : typeof b == "number" && (n[p] = b); break; case "ariaHidden": case "aria-hidden": b !== !0 && b !== "true" && delete r["aria-hidden"]; break; default: { const _ = io[p]; _ ? (b === !0 || b === "true" || b === 1) && (n[_] = !0) : Aa[p] === void 0 && (r[p] = b) } } } const a = ab(e, n), u = a.attributes; if (n.inline && (s.verticalAlign = "-0.125em"), o === "svg") { r.style = { ...s, ...l }, Object.assign(r, u); let p = 0, b = t.id; return typeof b == "string" && (b = b.replace(/-/g, "_")), r.innerHTML = db(a.body, b ? () => b + "ID" + p++ : "iconifyVue"), xe("svg", r) } const { body: c, width: f, height: d } = e, h = o === "mask" || (o === "bg" ? !1 : c.indexOf("currentColor") !== -1), g = Hb(c, { ...u, width: f + "", height: d + "" }); return r.style = { ...s, "--svg": zb(g), width: Oa(u.width), height: Oa(u.height), ...Wb, ...h ? ui : $f, ...l }, xe("span", r) }; xf(!0); Cf("", _b); if (typeof document < "u" && typeof window < "u") { const e = window; if (e.IconifyPreload !== void 0) { const t = e.IconifyPreload, n = "Invalid IconifyPreload syntax."; typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach(r => { try { (typeof r != "object" || r === null || r instanceof Array || typeof r.icons != "object" || typeof r.prefix != "string" || !tb(r)) && console.error(n) } catch { console.error(n) } }) } if (e.IconifyProviders !== void 0) { const t = e.IconifyProviders; if (typeof t == "object" && t !== null) for (let n in t) { const r = "IconifyProviders[" + n + "] is invalid."; try { const o = t[n]; if (typeof o != "object" || !o || o.resources === void 0) continue; kf(n, o) || console.error(r) } catch { console.error(r) } } } } const Vb = { ...Bn, body: "" }, Gb = ce({ inheritAttrs: !1, data() { return { _name: "", _loadingIcon: null, iconMounted: !1, counter: 0 } }, mounted() { this.iconMounted = !0 }, unmounted() { this.abortLoading() }, methods: { abortLoading() { this._loadingIcon && (this._loadingIcon.abort(), this._loadingIcon = null) }, getIcon(e, t, n) { if (typeof e == "object" && e !== null && typeof e.body == "string") return this._name = "", this.abortLoading(), { data: e }; let r; if (typeof e != "string" || (r = $r(e, !1, !0)) === null) return this.abortLoading(), null; let o = Yi(r); if (!o) return (!this._loadingIcon || this._loadingIcon.name !== e) && (this.abortLoading(), this._name = "", o !== null && (this._loadingIcon = { name: e, abort: Pf([r], () => { this.counter++ }) })), null; if (this.abortLoading(), this._name !== e && (this._name = e, t && t(e)), n) { o = Object.assign({}, o); const i = n(o.body, r.name, r.prefix, r.provider); typeof i == "string" && (o.body = i) } const s = ["iconify"]; return r.prefix !== "" && s.push("iconify--" + r.prefix), r.provider !== "" && s.push("iconify--" + r.provider), { data: o, classes: s } } }, render() { this.counter; const e = this.$attrs, t = this.iconMounted || e.ssr ? this.getIcon(e.icon, e.onLoad, e.customise) : null; if (!t) return Ia(Vb, e); let n = e; return t.classes && (n = { ...e, class: (typeof e.class == "string" ? e.class + " " : "") + t.classes.join(" ") }), Ia({ ...Bn, ...t.data }, n) } }), Kb = { getAPIConfig: Go, setAPIModule: Cf, sendAPIQuery: Af, setFetch: gb, getFetch: mb, listAPIProviders: pb }, Jb = et({ name: "@nuxt/icon", setup() { var o, s; const e = Zt(), t = wn().icon; Kb.setFetch($fetch.native); const n = []; if (t.provider === "server") { const i = ((s = (o = e.app) == null ? void 0 : o.baseURL) == null ? void 0 : s.replace(/\/$/, "")) ?? ""; n.push(i + (t.localApiEndpoint || "/api/_nuxt_icon")), (t.fallbackToApi === !0 || t.fallbackToApi === "client-only") && n.push(t.iconifyApiEndpoint) } else n.push(t.iconifyApiEndpoint); async function r(i, l) { try { const a = await $fetch(n[0] + "/" + l + ".json", { query: { icons: i.join(",") } }); if (!a || a.prefix !== l || !a.icons) throw new Error("Invalid data" + JSON.stringify(a)); return a } catch (a) { return console.error("Failed to load custom icons", a), null } } kf("", { resources: n }); for (const i of t.customCollections || []) i && Rb(r, i) } }), Zb = [a0, p0, m0, b0, v0, w0, _0, k0, T0, P0, zy, Ky, Jb], Qb = "" + new URL("images.png", import.meta.url).href, en = (e, t) => { const n = e.__vccOpts || e; for (const [r, o] of t) n[r] = o; return n }, Yb = {}; function Xb(e, t) { return se(), Fe("img", { src: Qb, width: "221px", height: "61px", alt: "Logo", class: "logo", onClick: t[0] || (t[0] = (...n) => e.goToHome && e.goToHome(...n)) }) } const ev = en(Yb, [["render", Xb]]), tv = Object.freeze({ left: 0, top: 0, width: 16, height: 16 }), Of = Object.freeze({ rotate: 0, vFlip: !1, hFlip: !1 }), tl = Object.freeze({ ...tv, ...Of }); Object.freeze({ ...tl, body: "", hidden: !1 }); function nv(e, t) { let n = e.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"'; for (const r in t) n += " " + r + '="' + t[r] + '"'; return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + e + "</svg>" } const rv = /(-?[0-9.]*[0-9]+[0-9.]*)/g, ov = /^-?[0-9.]*[0-9]+[0-9.]*$/g; function fi(e, t, n) { if (t === 1) return e; if (n = n || 100, typeof e == "number") return Math.ceil(e * t * n) / n; if (typeof e != "string") return e; const r = e.split(rv); if (r === null || !r.length) return e; const o = []; let s = r.shift(), i = ov.test(s); for (; ;) { if (i) { const l = parseFloat(s); isNaN(l) ? o.push(s) : o.push(Math.ceil(l * t * n) / n) } else o.push(s); if (s = r.shift(), s === void 0) return o.join(""); i = !i } } function sv(e) { return e.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ") } function iv(e) { return "data:image/svg+xml," + sv(e) } function lv(e) { return 'url("' + iv(e) + '")' } function av(e) { const [t, n, r, o] = e; if (r !== o) { const s = Math.max(r, o); return [t - (s - r) / 2, n - (s - o) / 2, s, s] } return e } const cv = Object.freeze({ width: null, height: null }), uv = Object.freeze({ ...cv, ...Of }); function fv(e, t = "defs") { let n = ""; const r = e.indexOf("<" + t); for (; r >= 0;) { const o = e.indexOf(">", r), s = e.indexOf("</" + t); if (o === -1 || s === -1) break; const i = e.indexOf(">", s); if (i === -1) break; n += e.slice(o + 1, s).trim(), e = e.slice(0, r).trim() + e.slice(i + 1) } return { defs: n, content: e } } function dv(e, t) { return e ? "<defs>" + e + "</defs>" + t : t } function pv(e, t, n) { const r = fv(e); return dv(r.defs, t + r.content + n) } const hv = e => e === "unset" || e === "undefined" || e === "none"; function gv(e, t) { const n = { ...tl, ...e }, r = { ...uv, ...t }, o = { left: n.left, top: n.top, width: n.width, height: n.height }; let s = n.body;[n, r].forEach(p => { const b = [], _ = p.hFlip, C = p.vFlip; let y = p.rotate; _ ? C ? y += 2 : (b.push("translate(" + (o.width + o.left).toString() + " " + (0 - o.top).toString() + ")"), b.push("scale(-1 1)"), o.top = o.left = 0) : C && (b.push("translate(" + (0 - o.left).toString() + " " + (o.height + o.top).toString() + ")"), b.push("scale(1 -1)"), o.top = o.left = 0); let w; switch (y < 0 && (y -= Math.floor(y / 4) * 4), y = y % 4, y) { case 1: w = o.height / 2 + o.top, b.unshift("rotate(90 " + w.toString() + " " + w.toString() + ")"); break; case 2: b.unshift("rotate(180 " + (o.width / 2 + o.left).toString() + " " + (o.height / 2 + o.top).toString() + ")"); break; case 3: w = o.width / 2 + o.left, b.unshift("rotate(-90 " + w.toString() + " " + w.toString() + ")"); break }y % 2 === 1 && (o.left !== o.top && (w = o.left, o.left = o.top, o.top = w), o.width !== o.height && (w = o.width, o.width = o.height, o.height = w)), b.length && (s = pv(s, '<g transform="' + b.join(" ") + '">', "</g>")) }); const i = r.width, l = r.height, a = o.width, u = o.height; let c, f; i === null ? (f = l === null ? "1em" : l === "auto" ? u : l, c = fi(f, a / u)) : (c = i === "auto" ? a : i, f = l === null ? fi(c, u / a) : l === "auto" ? u : l); const d = {}, h = (p, b) => { hv(b) || (d[p] = b.toString()) }; h("width", c), h("height", f); const g = [o.left, o.top, a, u]; return d.viewBox = g.join(" "), { attributes: d, viewBox: g, body: s } } function mv(e) { const t = { display: "inline-block", width: "1em", height: "1em" }, n = e.varName; switch (e.pseudoSelector && (t.content = "''"), e.mode) { case "background": n && (t["background-image"] = "var(--" + n + ")"), t["background-repeat"] = "no-repeat", t["background-size"] = "100% 100%"; break; case "mask": t["background-color"] = "currentColor", n && (t["mask-image"] = t["-webkit-mask-image"] = "var(--" + n + ")"), t["mask-repeat"] = t["-webkit-mask-repeat"] = "no-repeat", t["mask-size"] = t["-webkit-mask-size"] = "100% 100%"; break }return t } function yv(e, t) { const n = {}, r = t.varName, o = gv(e); let s = o.viewBox; s[2] !== s[3] && (t.forceSquare ? s = av(s) : n.width = fi("1em", s[2] / s[3])); const i = nv(o.body.replace(/currentColor/g, t.color || "black"), { viewBox: `${s[0]} ${s[1]} ${s[2]} ${s[3]}`, width: `${s[2]}`, height: `${s[3]}` }), l = lv(i); if (r) n["--" + r] = l; else switch (t.mode) { case "background": n["background-image"] = l; break; case "mask": n["mask-image"] = n["-webkit-mask-image"] = l; break }return n } const _s = {
  selectorStart: { compressed: "{", compact: " {", expanded: " {" }, selectorEnd: {
    compressed: "}", compact: `; }
`, expanded: `;
}
`}, rule: {
    compressed: "{key}:", compact: " {key}: ", expanded: `
  {key}: `}
}; function bv(e, t = "expanded") {
  const n = []; for (let r = 0; r < e.length; r++) { const { selector: o, rules: s } = e[r]; let l = (o instanceof Array ? o.join(t === "compressed" ? "," : ", ") : o) + _s.selectorStart[t], a = !0; for (const u in s) a || (l += ";"), l += _s.rule[t].replace("{key}", u) + s[u], a = !1; l += _s.selectorEnd[t], n.push(l) } return n.join(t === "compressed" ? "" : `
`)
} function vv(e, t = {}) { const n = t.customise ? t.customise(e.body) : e.body, r = t.mode || (t.color || !n.includes("currentColor") ? "background" : "mask"); let o = t.varName; o === void 0 && r === "mask" && (o = "svg"); const s = { ...t, mode: r, varName: o }; r === "background" && delete s.varName; const i = { ...t.rules, ...mv(s), ...yv({ ...tl, ...e, body: n }, s) }, l = t.iconSelector || ".icon"; return bv([{ selector: l, rules: i }], s.format) } async function wv(e, t) { if (!e) return null; const n = li(e); return n || (await Mb(e).catch(() => (console.warn(`[Icon] failed to load icon \`${e}\``), null)), li(e)) } function If(e) { const t = wn().icon, n = (t.collections || []).sort((r, o) => o.length - r.length); return R(() => { var i; const r = e(), o = r.startsWith(t.cssSelectorPrefix) ? r.slice(t.cssSelectorPrefix.length) : r, s = ((i = t.aliases) == null ? void 0 : i[o]) || o; if (!s.includes(":")) { const l = n.find(a => s.startsWith(a + "-")); return l ? l + ":" + s.slice(l.length + 1) : s } return s }) } function Lf(e, t) { if (e !== !1) return e === !0 || e === null ? t : e } let Yn; function xv(e) { return e.replace(/([^\w-])/g, "\\$1") } function _v() { if (Yn) return Yn; Yn = new Set; const e = n => { if (n = n.replace(/^:where\((.*)\)$/, "$1").trim(), n.startsWith(".")) return n }, t = n => { if (n != null && n.length) for (const r of n) { r != null && r.cssRules && t(r.cssRules); const o = r == null ? void 0 : r.selectorText; if (typeof o == "string") { const s = e(o); s && Yn.add(s) } } }; if (typeof document < "u") for (const n of document.styleSheets) try { const r = n.cssRules || n.rules; t(r) } catch { } return Yn } const Sv = ce({ name: "NuxtIconCss", props: { name: { type: String, required: !0 }, customize: { type: [Function, Boolean, null], default: null, required: !1 } }, setup(e) { const t = he(), n = wn().icon, r = R(() => e.name ? n.cssSelectorPrefix + e.name : ""); function o(l) { var c, f; if (!l) return; const a = li(l); if (a) return a; const u = (f = (c = t.payload) == null ? void 0 : c.data) == null ? void 0 : f[l]; if (u) return Xi(l, u), u } const s = R(() => "." + xv(r.value)); function i(l, a = !0) { let u = s.value; n.cssWherePseudo && (u = `:where(${u})`); const c = vv(l, { iconSelector: u, format: "compressed", customise: Lf(e.customize, n.customize) }); return n.cssLayer && a ? `@layer ${n.cssLayer} { ${c} }` : c } { const l = _v(); async function a(u) { if (l.has(s.value) || typeof document > "u") return; const c = document.createElement("style"); c.textContent = i(u); const f = document.head.querySelector('style, link[rel="stylesheet"]'); f ? document.head.insertBefore(c, f) : document.head.appendChild(c), l.add(s.value) } We(() => e.name, () => { if (l.has(s.value)) return; const u = o(e.name); u ? a(u) : wv(e.name).then(c => { c && a(c) }).catch(() => null) }, { immediate: !0 }) } return () => xe("span", { class: ["iconify", r.value] }) } }), Cv = ce({ name: "NuxtIconSvg", props: { name: { type: String, required: !0 }, customize: { type: [Function, Boolean, null], default: null, required: !1 } }, setup(e, { slots: t }) { const n = he(), r = wn().icon, o = If(() => e.name), s = "i-" + o.value; if (o.value) { const i = n.payload.data[s]; i && Xi(o.value, i) } return () => xe(Gb, { icon: o.value, ssr: !0, customise: Lf(e.customize, r.customize) }, t) } }), Mf = ce({ name: "NuxtIcon", props: { name: { type: String, required: !0 }, mode: { type: String, required: !1, default: null }, size: { type: [Number, String], required: !1, default: null }, customize: { type: [Function, Boolean, null], default: null, required: !1 } }, setup(e, { slots: t }) { const n = he(), r = wn().icon, o = If(() => e.name), s = R(() => { var l; return ((l = n.vueApp) == null ? void 0 : l.component(o.value)) || ((e.mode || r.mode) === "svg" ? Cv : Sv) }), i = R(() => { const l = e.size || r.size; return l ? { fontSize: Number.isNaN(+l) ? l : l + "px" } : null }); return () => xe(s.value, { ...r.attrs, name: o.value, class: r.class, style: i.value, customize: e.customize }, t) } }), kv = Object.freeze(Object.defineProperty({ __proto__: null, default: Mf }, Symbol.toStringTag, { value: "Module" })), Ev = ce({ props: { name: { type: String, required: !0 }, mode: { type: String, required: !1, default: null }, size: { type: [Number, String], required: !1, default: null }, customize: { type: Function, required: !1, default: null } } }); function Tv(e, t, n, r, o, s) { const i = Mf; return se(), Ce(i, ur(br(e.$props)), null, 16) } const Ko = en(Ev, [["render", Tv]]); async function Rf(e, t = dt()) { const { path: n, matched: r } = t.resolve(e); if (!r.length || (t._routePreloaded || (t._routePreloaded = new Set), t._routePreloaded.has(n))) return; const o = t._preloadPromises || (t._preloadPromises = []); if (o.length > 4) return Promise.all(o).then(() => Rf(e, t)); t._routePreloaded.add(n); const s = r.map(i => { var l; return (l = i.components) == null ? void 0 : l.default }).filter(i => typeof i == "function"); for (const i of s) { const l = Promise.resolve(i()).catch(() => { }).finally(() => o.splice(o.indexOf(l))); o.push(l) } await Promise.all(o) } const Av = (...e) => e.find(t => t !== void 0); function Pv(e) { const t = e.componentName || "NuxtLink"; function n(s) { return typeof s == "string" && s.startsWith("#") } function r(s, i) { if (!s || e.trailingSlash !== "append" && e.trailingSlash !== "remove") return s; if (typeof s == "string") return La(s, e.trailingSlash); const l = "path" in s && s.path !== void 0 ? s.path : i(s).path; return { ...s, name: void 0, path: La(l, e.trailingSlash) } } function o(s) { const i = dt(), l = Zt(), a = R(() => !!s.target && s.target !== "_self"), u = R(() => { const b = s.to || s.href || ""; return typeof b == "string" && _t(b, { acceptRelative: !0 }) }), c = It("RouterLink"), f = c && typeof c != "string" ? c.useLink : void 0, d = R(() => { if (s.external) return !0; const b = s.to || s.href || ""; return typeof b == "object" ? !1 : b === "" || u.value }), h = R(() => { const b = s.to || s.href || ""; return d.value ? b : r(b, i.resolve) }), g = d.value || f == null ? void 0 : f({ ...s, to: h }), p = R(() => { var b; if (!h.value || u.value || n(h.value)) return h.value; if (d.value) { const _ = typeof h.value == "object" && "path" in h.value ? Qs(h.value) : h.value, C = typeof _ == "object" ? i.resolve(_).href : _; return r(C, i.resolve) } return typeof h.value == "object" ? ((b = i.resolve(h.value)) == null ? void 0 : b.href) ?? null : r(Jt(l.app.baseURL, h.value), i.resolve) }); return { to: h, hasTarget: a, isAbsoluteUrl: u, isExternal: d, href: p, isActive: (g == null ? void 0 : g.isActive) ?? R(() => h.value === i.currentRoute.value.path), isExactActive: (g == null ? void 0 : g.isExactActive) ?? R(() => h.value === i.currentRoute.value.path), route: (g == null ? void 0 : g.route) ?? R(() => i.resolve(h.value)), async navigate(b) { await Gu(p.value, { replace: s.replace, external: d.value || a.value }) } } } return ce({ name: t, props: { to: { type: [String, Object], default: void 0, required: !1 }, href: { type: [String, Object], default: void 0, required: !1 }, target: { type: String, default: void 0, required: !1 }, rel: { type: String, default: void 0, required: !1 }, noRel: { type: Boolean, default: void 0, required: !1 }, prefetch: { type: Boolean, default: void 0, required: !1 }, prefetchOn: { type: [String, Object], default: void 0, required: !1 }, noPrefetch: { type: Boolean, default: void 0, required: !1 }, activeClass: { type: String, default: void 0, required: !1 }, exactActiveClass: { type: String, default: void 0, required: !1 }, prefetchedClass: { type: String, default: void 0, required: !1 }, replace: { type: Boolean, default: void 0, required: !1 }, ariaCurrentValue: { type: String, default: void 0, required: !1 }, external: { type: Boolean, default: void 0, required: !1 }, custom: { type: Boolean, default: void 0, required: !1 } }, useLink: o, setup(s, { slots: i }) { const l = dt(), { to: a, href: u, navigate: c, isExternal: f, hasTarget: d, isAbsoluteUrl: h } = o(s), g = G(!1), p = G(null), b = y => { var w; p.value = s.custom ? (w = y == null ? void 0 : y.$el) == null ? void 0 : w.nextElementSibling : y == null ? void 0 : y.$el }; function _(y) { var w, S; return !g.value && (typeof s.prefetchOn == "string" ? s.prefetchOn === y : ((w = s.prefetchOn) == null ? void 0 : w[y]) ?? ((S = e.prefetchOn) == null ? void 0 : S[y])) && (s.prefetch ?? e.prefetch) !== !1 && s.noPrefetch !== !0 && s.target !== "_blank" && !Lv() } async function C(y = he()) { if (g.value) return; g.value = !0; const w = typeof a.value == "string" ? a.value : f.value ? Qs(a.value) : l.resolve(a.value).fullPath, S = f.value ? new URL(w, window.location.href).href : w; await Promise.all([y.hooks.callHook("link:prefetch", S).catch(() => { }), !f.value && !d.value && Rf(a.value, l).catch(() => { })]) } if (_("visibility")) { const y = he(); let w, S = null; Te(() => { const k = Ov(); Wo(() => { w = ri(() => { var M; (M = p == null ? void 0 : p.value) != null && M.tagName && (S = k.observe(p.value, async () => { S == null || S(), S = null, await C(y) })) }) }) }), jo(() => { w && y0(w), S == null || S(), S = null }) } return () => { var S; if (!f.value && !d.value && !n(a.value)) { const k = { ref: b, to: a.value, activeClass: s.activeClass || e.activeClass, exactActiveClass: s.exactActiveClass || e.exactActiveClass, replace: s.replace, ariaCurrentValue: s.ariaCurrentValue, custom: s.custom }; return s.custom || (_("interaction") && (k.onPointerenter = C.bind(null, void 0), k.onFocus = C.bind(null, void 0)), g.value && (k.class = s.prefetchedClass || e.prefetchedClass), k.rel = s.rel || void 0), xe(It("RouterLink"), k, i.default) } const y = s.target || null, w = Av(s.noRel ? "" : s.rel, e.externalRelAttribute, h.value || d.value ? "noopener noreferrer" : "") || null; return s.custom ? i.default ? i.default({ href: u.value, navigate: c, prefetch: C, get route() { if (!u.value) return; const k = new URL(u.value, window.location.href); return { path: k.pathname, fullPath: k.pathname, get query() { return Uo(k.search) }, hash: k.hash, params: {}, name: void 0, matched: [], redirectedFrom: void 0, meta: {}, href: u.value } }, rel: w, target: y, isExternal: f.value || d.value, isActive: !1, isExactActive: !1 }) : null : xe("a", { ref: p, href: u.value || null, rel: w, target: y }, (S = i.default) == null ? void 0 : S.call(i)) } } }) } const $v = Pv(Vg); function La(e, t) { const n = t === "append" ? wo : zo; return _t(e) && !e.startsWith("http") ? e : n(e, !0) } function Ov() { const e = he(); if (e._observer) return e._observer; let t = null; const n = new Map, r = (s, i) => (t || (t = new IntersectionObserver(l => { for (const a of l) { const u = n.get(a.target); (a.isIntersecting || a.intersectionRatio > 0) && u && u() } })), n.set(s, i), t.observe(s), () => { n.delete(s), t == null || t.unobserve(s), n.size === 0 && (t == null || t.disconnect(), t = null) }); return e._observer = { observe: r } } const Iv = /2g/; function Lv() { const e = navigator.connection; return !!(e && (e.saveData || Iv.test(e.effectiveType))) } function di(e) { return typeof e == "string" ? `'${e}'` : new Mv().serialize(e) } const Mv = function () { var t; class e { constructor() { pl(this, t, new Map) } compare(r, o) { const s = typeof r, i = typeof o; return s === "string" && i === "string" ? r.localeCompare(o) : s === "number" && i === "number" ? r - o : String.prototype.localeCompare.call(this.serialize(r, !0), this.serialize(o, !0)) } serialize(r, o) { if (r === null) return "null"; switch (typeof r) { case "string": return o ? r : `'${r}'`; case "bigint": return `${r}n`; case "object": return this.$object(r); case "function": return this.$function(r) }return String(r) } serializeObject(r) { const o = Object.prototype.toString.call(r); if (o !== "[object Object]") return this.serializeBuiltInType(o.length < 10 ? `unknown:${o}` : o.slice(8, -1), r); const s = r.constructor, i = s === Object || s === void 0 ? "" : s.name; if (i !== "" && globalThis[i] === s) return this.serializeBuiltInType(i, r); if (typeof r.toJSON == "function") { const l = r.toJSON(); return i + (l !== null && typeof l == "object" ? this.$object(l) : `(${this.serialize(l)})`) } return this.serializeObjectEntries(i, Object.entries(r)) } serializeBuiltInType(r, o) { const s = this["$" + r]; if (s) return s.call(this, o); if (typeof (o == null ? void 0 : o.entries) == "function") return this.serializeObjectEntries(r, o.entries()); throw new Error(`Cannot serialize ${r}`) } serializeObjectEntries(r, o) { const s = Array.from(o).sort((l, a) => this.compare(l[0], a[0])); let i = `${r}{`; for (let l = 0; l < s.length; l++) { const [a, u] = s[l]; i += `${this.serialize(a, !0)}:${this.serialize(u)}`, l < s.length - 1 && (i += ",") } return i + "}" } $object(r) { let o = zn(this, t).get(r); return o === void 0 && (zn(this, t).set(r, `#${zn(this, t).size}`), o = this.serializeObject(r), zn(this, t).set(r, o)), o } $function(r) { const o = Function.prototype.toString.call(r); return o.slice(-15) === "[native code] }" ? `${r.name || ""}()[native]` : `${r.name}(${r.length})${o.replace(/\s*\n\s*/g, "")}` } $Array(r) { let o = "["; for (let s = 0; s < r.length; s++)o += this.serialize(r[s]), s < r.length - 1 && (o += ","); return o + "]" } $Date(r) { try { return `Date(${r.toISOString()})` } catch { return "Date(null)" } } $ArrayBuffer(r) { return `ArrayBuffer[${new Uint8Array(r).join(",")}]` } $Set(r) { return `Set${this.$Array(Array.from(r).sort((o, s) => this.compare(o, s)))}` } $Map(r) { return this.serializeObjectEntries("Map", r.entries()) } } t = new WeakMap; for (const n of ["Error", "RegExp", "URL"]) e.prototype["$" + n] = function (r) { return `${n}(${r})` }; for (const n of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + n] = function (r) { return `${n}[${r.join(",")}]` }; for (const n of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + n] = function (r) { return `${n}[${r.join("n,")}${r.length > 0 ? "n" : ""}]` }; return e }(); function Ma(e, t) { return e === t || di(e) === di(t) } function Rv(e, t) { const n = pi(e), r = pi(t); return jf(n, r) } function jf(e, t) { var o, s; const n = [], r = new Set([...Object.keys(e.props || {}), ...Object.keys(t.props || {})]); if (e.props && t.props) for (const i of r) { const l = e.props[i], a = t.props[i]; l && a ? n.push(...jf((o = e.props) == null ? void 0 : o[i], (s = t.props) == null ? void 0 : s[i])) : (l || a) && n.push(new Ra((a || l).key, l ? "removed" : "added", a, l)) } return r.size === 0 && e.hash !== t.hash && n.push(new Ra((t || e).key, "changed", t, e)), n } function pi(e, t = "") { if (e && typeof e != "object") return new ja(t, e, di(e)); const n = {}, r = []; for (const o in e) n[o] = pi(e[o], t ? `${t}.${o}` : o), r.push(n[o].hash); return new ja(t, e, `{${r.join(":")}}`, n) } class Ra { constructor(t, n, r, o) { this.key = t, this.type = n, this.newValue = r, this.oldValue = o } toString() { return this.toJSON() } toJSON() { var t; switch (this.type) { case "added": return `Added   \`${this.key}\``; case "removed": return `Removed \`${this.key}\``; case "changed": return `Changed \`${this.key}\` from \`${((t = this.oldValue) == null ? void 0 : t.toString()) || "-"}\` to \`${this.newValue.toString()}\`` } } } class ja { constructor(t, n, r, o) { this.key = t, this.value = n, this.hash = r, this.props = o } toString() { return this.props ? `{${Object.keys(this.props).join(",")}}` : JSON.stringify(this.value) } toJSON() { const t = this.key || "."; return this.props ? `${t}({${Object.keys(this.props).join(",")}})` : `${t}(${this.value})` } } const jv = ce({ inheritAttrs: !1, props: { ...Qi, as: { type: String, default: "button" }, type: { type: String, default: "button" }, disabled: { type: Boolean, default: null }, active: { type: Boolean, default: void 0 }, exact: { type: Boolean, default: !1 }, exactQuery: { type: [Boolean, String], default: !1 }, exactHash: { type: Boolean, default: !1 }, inactiveClass: { type: String, default: void 0 } }, setup(e) { function t(r, o) { const s = Rv(r, o).reduce((a, u) => (u.type === "added" && a.add(u.key), a), new Set), i = Object.fromEntries(Object.entries(r).filter(([a]) => !s.has(a))), l = Object.fromEntries(Object.entries(o).filter(([a]) => !s.has(a))); return Ma(i, l) } function n(r, o, { isActive: s, isExactActive: i }) { if (e.exactQuery === "partial") { if (!t(r.query, o.query)) return e.inactiveClass } else if (e.exactQuery === !0 && !Ma(r.query, o.query)) return e.inactiveClass; return e.exactHash && r.hash !== o.hash ? e.inactiveClass : e.exact && i || !e.exact && s ? e.activeClass : e.inactiveClass } return { resolveLinkClass: n } } }), Nv = ["href", "aria-disabled", "role", "rel", "target", "tabindex", "onClick"]; function Fv(e, t, n, r, o, s) { const i = $v; return e.to ? (se(), Ce(i, ot({ key: 1 }, e.$props, { custom: "" }), { default: X(({ route: l, href: a, target: u, rel: c, navigate: f, isActive: d, isExactActive: h, isExternal: g }) => [m("a", ot(e.$attrs, { href: e.disabled ? void 0 : a, "aria-disabled": e.disabled ? "true" : void 0, role: e.disabled ? "link" : void 0, rel: c, target: u, class: e.active !== void 0 ? e.active ? e.activeClass : e.inactiveClass : e.resolveLinkClass(l, e.$route, { isActive: d, isExactActive: h }), tabindex: e.disabled ? -1 : void 0, onClick: p => !g && !e.disabled && f(p) }), [Xe(e.$slots, "default", ur(br({ isActive: e.active !== void 0 ? e.active : e.exact ? h : d })))], 16, Nv)]), _: 3 }, 16)) : (se(), Ce(zc(e.as), ot({ key: 0, type: e.type, disabled: e.disabled }, e.$attrs, { class: e.active ? e.activeClass : e.inactiveClass }), { default: X(() => [Xe(e.$slots, "default", ur(br({ isActive: e.active })))]), _: 3 }, 16, ["type", "disabled", "class"])) } const Or = en(jv, [["render", Fv]]), nl = (e, t, n, r, o = !1) => { const s = Vc(), i = wn(), l = R(() => { var d; const u = Jr(t), c = Jr(n), f = Jr(r); return Pr((u == null ? void 0 : u.strategy) || ((d = i.ui) == null ? void 0 : d.strategy), f ? { wrapper: f } : {}, u || {}, o ? si(i.ui, e, {}) : {}, c || {}) }), a = R(() => pf(s, ["class"])); return { ui: l, attrs: a } }; function Bv({ ui: e, props: t }) { const n = vn(); if (Me("ButtonGroupContextConsumer", !0), Se("ButtonGroupContextConsumer", !1)) return { size: R(() => t.size), rounded: R(() => e.value.rounded) }; let o = n.parent, s; for (; o && !s;) { if (o.type.name === "ButtonGroup") { s = Se(`group-${o.uid}`); break } o = o.parent } const i = R(() => s == null ? void 0 : s.value.children.indexOf(n)); return Te(() => { s == null || s.value.register(n) }), Ve(() => { s == null || s.value.unregister(n) }), { size: R(() => s != null && s.value ? (s == null ? void 0 : s.value.size) ?? e.value.default.size : t.size), rounded: R(() => !s || i.value === -1 ? e.value.rounded : s.value.children.length === 1 ? s.value.ui.rounded : i.value === 0 ? s.value.rounded.start : i.value === s.value.children.length - 1 ? s.value.rounded.end : "rounded-none") } } const Nf = { base: "focus:outline-none focus-visible:outline-0 disabled:cursor-not-allowed disabled:opacity-75 aria-disabled:cursor-not-allowed aria-disabled:opacity-75 flex-shrink-0", font: "font-medium", rounded: "rounded-md", truncate: "text-left break-all line-clamp-1", block: "w-full flex justify-center items-center", inline: "inline-flex items-center", size: { "2xs": "text-xs", xs: "text-xs", sm: "text-sm", md: "text-sm", lg: "text-sm", xl: "text-base" }, gap: { "2xs": "gap-x-1", xs: "gap-x-1.5", sm: "gap-x-1.5", md: "gap-x-2", lg: "gap-x-2.5", xl: "gap-x-2.5" }, padding: { "2xs": "px-2 py-1", xs: "px-2.5 py-1.5", sm: "px-2.5 py-1.5", md: "px-3 py-2", lg: "px-3.5 py-2.5", xl: "px-3.5 py-2.5" }, square: { "2xs": "p-1", xs: "p-1.5", sm: "p-1.5", md: "p-2", lg: "p-2.5", xl: "p-2.5" }, color: { white: { solid: "shadow-sm ring-1 ring-inset ring-gray-300 dark:ring-gray-700 text-gray-900 dark:text-white bg-white hover:bg-gray-50 disabled:bg-white aria-disabled:bg-white dark:bg-gray-900 dark:hover:bg-gray-800/50 dark:disabled:bg-gray-900 dark:aria-disabled:bg-gray-900 focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400", ghost: "text-gray-900 dark:text-white hover:bg-white dark:hover:bg-gray-900 focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400" }, gray: { solid: "shadow-sm ring-1 ring-inset ring-gray-300 dark:ring-gray-700 text-gray-700 dark:text-gray-200 bg-gray-50 hover:bg-gray-100 disabled:bg-gray-50 aria-disabled:bg-gray-50 dark:bg-gray-800 dark:hover:bg-gray-700/50 dark:disabled:bg-gray-800 dark:aria-disabled:bg-gray-800 focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400", ghost: "text-gray-700 dark:text-gray-200 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-gray-800 focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400", link: "text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 underline-offset-4 hover:underline focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400" }, black: { solid: "shadow-sm text-white dark:text-gray-900 bg-gray-900 hover:bg-gray-800 disabled:bg-gray-900 aria-disabled:bg-gray-900 dark:bg-white dark:hover:bg-gray-100 dark:disabled:bg-white dark:aria-disabled:bg-white focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400", link: "text-gray-900 dark:text-white underline-offset-4 hover:underline focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400" } }, variant: { solid: "shadow-sm text-white dark:text-gray-900 bg-{color}-500 hover:bg-{color}-600 disabled:bg-{color}-500 aria-disabled:bg-{color}-500 dark:bg-{color}-400 dark:hover:bg-{color}-500 dark:disabled:bg-{color}-400 dark:aria-disabled:bg-{color}-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-{color}-500 dark:focus-visible:outline-{color}-400", outline: "ring-1 ring-inset ring-current text-{color}-500 dark:text-{color}-400 hover:bg-{color}-50 disabled:bg-transparent aria-disabled:bg-transparent dark:hover:bg-{color}-950 dark:disabled:bg-transparent dark:aria-disabled:bg-transparent focus-visible:ring-2 focus-visible:ring-{color}-500 dark:focus-visible:ring-{color}-400", soft: "text-{color}-500 dark:text-{color}-400 bg-{color}-50 hover:bg-{color}-100 disabled:bg-{color}-50 aria-disabled:bg-{color}-50 dark:bg-{color}-950 dark:hover:bg-{color}-900 dark:disabled:bg-{color}-950 dark:aria-disabled:bg-{color}-950 focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-{color}-500 dark:focus-visible:ring-{color}-400", ghost: "text-{color}-500 dark:text-{color}-400 hover:bg-{color}-50 disabled:bg-transparent aria-disabled:bg-transparent dark:hover:bg-{color}-950 dark:disabled:bg-transparent dark:aria-disabled:bg-transparent focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-{color}-500 dark:focus-visible:ring-{color}-400", link: "text-{color}-500 hover:text-{color}-600 disabled:text-{color}-500 aria-disabled:text-{color}-500 dark:text-{color}-400 dark:hover:text-{color}-500 dark:disabled:text-{color}-400 dark:aria-disabled:text-{color}-400 underline-offset-4 hover:underline focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-{color}-500 dark:focus-visible:ring-{color}-400" }, icon: { base: "flex-shrink-0", loading: "animate-spin", size: { "2xs": "h-4 w-4", xs: "h-4 w-4", sm: "h-5 w-5", md: "h-5 w-5", lg: "h-5 w-5", xl: "h-6 w-6" } }, default: { size: "sm", variant: "solid", color: "primary", loadingIcon: "i-heroicons-arrow-path-20-solid" } }, Hv = { wrapper: "w-full flex flex-col", container: "w-full flex flex-col", item: { base: "", size: "text-sm", color: "text-gray-500 dark:text-gray-400", padding: "pt-1.5 pb-3", icon: "ms-auto transform transition-transform duration-200 flex-shrink-0" }, transition: { enterActiveClass: "overflow-hidden transition-[height] duration-200 ease-out", leaveActiveClass: "overflow-hidden transition-[height] duration-200 ease-out" }, default: { openIcon: "i-heroicons-chevron-down-20-solid", closeIcon: "", class: "mb-1.5 w-full", variant: "soft", truncate: !0 } }, Dv = { option: { base: "cursor-default select-none relative flex items-center justify-between gap-1", rounded: "rounded-md", padding: "px-1.5 py-1.5", size: "text-sm", color: "text-gray-900 dark:text-white", container: "flex items-center gap-1.5 min-w-0", active: "bg-gray-100 dark:bg-gray-900", inactive: "", selected: "pe-7", disabled: "cursor-not-allowed opacity-50", empty: "text-sm text-gray-400 dark:text-gray-500 px-2 py-1.5", icon: { base: "flex-shrink-0 h-5 w-5", active: "text-gray-900 dark:text-white", inactive: "text-gray-400 dark:text-gray-500" }, selectedIcon: { wrapper: "absolute inset-y-0 end-0 flex items-center", padding: "pe-2", base: "h-5 w-5 text-gray-900 dark:text-white flex-shrink-0" }, avatar: { base: "flex-shrink-0", size: "2xs" }, chip: { base: "flex-shrink-0 w-2 h-2 mx-1 rounded-full" } } }; ({ ...Dv.option }); const Uv = { wrapper: "fixed inset-0 flex z-50", overlay: { base: "fixed inset-0 transition-opacity", background: "bg-gray-200/75 dark:bg-gray-800/75", transition: { enter: "ease-in-out duration-500", enterFrom: "opacity-0", enterTo: "opacity-100", leave: "ease-in-out duration-500", leaveFrom: "opacity-100", leaveTo: "opacity-0" } }, base: "relative flex-1 flex flex-col w-full focus:outline-none", background: "bg-white dark:bg-gray-900", ring: "", rounded: "", padding: "", shadow: "shadow-xl", width: "w-screen max-w-md", height: "h-screen max-h-96", translate: { base: "translate-x-0", left: "-translate-x-full rtl:translate-x-full", right: "translate-x-full rtl:-translate-x-full", top: "-translate-y-full", bottom: "translate-y-full" }, transition: { enter: "transform transition ease-in-out duration-300", leave: "transform transition ease-in-out duration-200" } }, Tt = Pr(pt.ui.strategy, pt.ui.button, Nf), zv = ce({ components: { UIcon: Ko, ULink: Or }, inheritAttrs: !1, props: { ...Qi, type: { type: String, default: "button" }, block: { type: Boolean, default: !1 }, label: { type: String, default: null }, loading: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, padded: { type: Boolean, default: !0 }, size: { type: String, default: () => Tt.default.size, validator(e) { return Object.keys(Tt.size).includes(e) } }, color: { type: String, default: () => Tt.default.color, validator(e) { return [...pt.ui.colors, ...Object.keys(Tt.color)].includes(e) } }, variant: { type: String, default: () => Tt.default.variant, validator(e) { return [...Object.keys(Tt.variant), ...Object.values(Tt.color).flatMap(t => Object.keys(t))].includes(e) } }, icon: { type: String, default: null }, loadingIcon: { type: String, default: () => Tt.default.loadingIcon }, leadingIcon: { type: String, default: null }, trailingIcon: { type: String, default: null }, trailing: { type: Boolean, default: !1 }, leading: { type: Boolean, default: !1 }, square: { type: Boolean, default: !1 }, truncate: { type: Boolean, default: !1 }, class: { type: [String, Object, Array], default: () => "" }, ui: { type: Object, default: () => ({}) } }, setup(e, { slots: t }) { const { ui: n, attrs: r } = nl("button", yn(e, "ui"), Tt), { size: o, rounded: s } = Bv({ ui: n, props: e }), i = R(() => e.icon && e.leading || e.icon && !e.trailing || e.loading && !e.trailing || e.leadingIcon), l = R(() => e.icon && e.trailing || e.loading && e.trailing || e.trailingIcon), a = R(() => e.square || !t.default && !e.label), u = R(() => { var b, _; const p = ((_ = (b = n.value.color) == null ? void 0 : b[e.color]) == null ? void 0 : _[e.variant]) || n.value.variant[e.variant]; return hf(ro(n.value.base, n.value.font, s.value, n.value.size[o.value], n.value.gap[o.value], e.padded && n.value[a.value ? "square" : "padding"][o.value], p == null ? void 0 : p.replaceAll("{color}", e.color), e.block ? n.value.block : n.value.inline), e.class) }), c = R(() => e.loading ? e.loadingIcon : e.leadingIcon || e.icon), f = R(() => e.loading && !i.value ? e.loadingIcon : e.trailingIcon || e.icon), d = R(() => ro(n.value.icon.base, n.value.icon.size[o.value], e.loading && n.value.icon.loading)), h = R(() => ro(n.value.icon.base, n.value.icon.size[o.value], e.loading && !i.value && n.value.icon.loading)), g = R(() => uy(e)); return { ui: n, attrs: r, isLeading: i, isTrailing: l, isSquare: a, buttonClass: u, leadingIconName: c, trailingIconName: f, leadingIconClass: d, trailingIconClass: h, linkProps: g } } }); function qv(e, t, n, r, o, s) { const i = Ko, l = Or; return se(), Ce(l, ot({ type: e.type, disabled: e.disabled || e.loading, class: e.buttonClass }, { ...e.linkProps, ...e.attrs }), { default: X(() => [Xe(e.$slots, "leading", { disabled: e.disabled, loading: e.loading }, () => [e.isLeading && e.leadingIconName ? (se(), Ce(i, { key: 0, name: e.leadingIconName, class: $e(e.leadingIconClass), "aria-hidden": "true" }, null, 8, ["name", "class"])) : Xr("", !0)]), Xe(e.$slots, "default", {}, () => [e.label ? (se(), Fe("span", { key: 0, class: $e([e.truncate ? e.ui.truncate : ""]) }, Ot(e.label), 3)) : Xr("", !0)]), Xe(e.$slots, "trailing", { disabled: e.disabled, loading: e.loading }, () => [e.isTrailing && e.trailingIconName ? (se(), Ce(i, { key: 0, name: e.trailingIconName, class: $e(e.trailingIconClass), "aria-hidden": "true" }, null, 8, ["name", "class"])) : Xr("", !0)])]), _: 3 }, 16, ["type", "disabled", "class"]) } const rl = en(zv, [["render", qv]]), Ff = ce({ __name: "LandingButton", props: { to: {}, variant: {} }, setup(e) { const t = e, n = R(() => [t.variant ?? "solid"].map(r => r === "outline" ? "_outline" : r)); return (r, o) => { const s = Or; return se(), Ce(s, { class: $e(["LandingButton border-primary inline-flex h-[60px] w-[280px] shrink-0 items-center justify-center rounded-[20px] border-2 px-5 text-center font-semibold transition-opacity hover:opacity-70", we(n)]), to: r.to }, { default: X(() => [Xe(r.$slots, "default")]), _: 3 }, 8, ["class", "to"]) } } }), Wv = {}, Vv = { class: "mx-auto max-w-[calc(1180px+(theme(spacing.4)*2))] px-4 sm:max-w-[calc(1180px+(theme(spacing.6)*2))] sm:px-6 lg:max-w-[calc(1180px+(theme(spacing.8)*2))] lg:px-8" }; function Gv(e, t) { return se(), Fe("div", Vv, [Xe(e.$slots, "default")]) } const ol = en(Wv, [["render", Gv]]); function sl(e) { typeof queueMicrotask == "function" ? queueMicrotask(e) : Promise.resolve().then(e).catch(t => setTimeout(() => { throw t })) } function Ir() { let e = [], t = { addEventListener(n, r, o, s) { return n.addEventListener(r, o, s), t.add(() => n.removeEventListener(r, o, s)) }, requestAnimationFrame(...n) { let r = requestAnimationFrame(...n); t.add(() => cancelAnimationFrame(r)) }, nextFrame(...n) { t.requestAnimationFrame(() => { t.requestAnimationFrame(...n) }) }, setTimeout(...n) { let r = setTimeout(...n); t.add(() => clearTimeout(r)) }, microTask(...n) { let r = { current: !0 }; return sl(() => { r.current && n[0]() }), t.add(() => { r.current = !1 }) }, style(n, r, o) { let s = n.style.getPropertyValue(r); return Object.assign(n.style, { [r]: o }), this.add(() => { Object.assign(n.style, { [r]: s }) }) }, group(n) { let r = Ir(); return n(r), this.add(() => r.dispose()) }, add(n) { return e.push(n), () => { let r = e.indexOf(n); if (r >= 0) for (let o of e.splice(r, 1)) o() } }, dispose() { for (let n of e.splice(0)) n() } }; return t } var Na; let Bf = Symbol("headlessui.useid"), Kv = 0; const _r = (Na = Mi) != null ? Na : function () { return Se(Bf, () => `${++Kv}`)() }; function Hf(e) { Me(Bf, e) } function de(e) { var t; if (e == null || e.value == null) return null; let n = (t = e.value.$el) != null ? t : e.value; return n instanceof Node ? n : null } function it(e, t, ...n) { if (e in t) { let o = t[e]; return typeof o == "function" ? o(...n) : o } let r = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map(o => `"${o}"`).join(", ")}.`); throw Error.captureStackTrace && Error.captureStackTrace(r, it), r } var Jv = Object.defineProperty, Zv = (e, t, n) => t in e ? Jv(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Fa = (e, t, n) => (Zv(e, typeof t != "symbol" ? t + "" : t, n), n); let Qv = class { constructor() { Fa(this, "current", this.detect()), Fa(this, "currentId", 0) } set(t) { this.current !== t && (this.currentId = 0, this.current = t) } reset() { this.set(this.detect()) } nextId() { return ++this.currentId } get isServer() { return this.current === "server" } get isClient() { return this.current === "client" } detect() { return typeof window > "u" || typeof document > "u" ? "server" : "client" } }, Lr = new Qv; function Hn(e) { if (Lr.isServer) return null; if (e instanceof Node) return e.ownerDocument; if (e != null && e.hasOwnProperty("value")) { let t = de(e); if (t) return t.ownerDocument } return document } let hi = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(e => `${e}:not([tabindex='-1'])`).join(","); var Wt = (e => (e[e.First = 1] = "First", e[e.Previous = 2] = "Previous", e[e.Next = 4] = "Next", e[e.Last = 8] = "Last", e[e.WrapAround = 16] = "WrapAround", e[e.NoScroll = 32] = "NoScroll", e))(Wt || {}), Df = (e => (e[e.Error = 0] = "Error", e[e.Overflow = 1] = "Overflow", e[e.Success = 2] = "Success", e[e.Underflow = 3] = "Underflow", e))(Df || {}), Yv = (e => (e[e.Previous = -1] = "Previous", e[e.Next = 1] = "Next", e))(Yv || {}); function Xv(e = document.body) { return e == null ? [] : Array.from(e.querySelectorAll(hi)).sort((t, n) => Math.sign((t.tabIndex || Number.MAX_SAFE_INTEGER) - (n.tabIndex || Number.MAX_SAFE_INTEGER))) } var Uf = (e => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(Uf || {}); function e1(e, t = 0) { var n; return e === ((n = Hn(e)) == null ? void 0 : n.body) ? !1 : it(t, { 0() { return e.matches(hi) }, 1() { let r = e; for (; r !== null;) { if (r.matches(hi)) return !0; r = r.parentElement } return !1 } }) } var t1 = (e => (e[e.Keyboard = 0] = "Keyboard", e[e.Mouse = 1] = "Mouse", e))(t1 || {}); typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", e => { e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "") }, !0), document.addEventListener("click", e => { e.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "") }, !0)); function mn(e) { e == null || e.focus({ preventScroll: !0 }) } let n1 = ["textarea", "input"].join(","); function r1(e) { var t, n; return (n = (t = e == null ? void 0 : e.matches) == null ? void 0 : t.call(e, n1)) != null ? n : !1 } function o1(e, t = n => n) { return e.slice().sort((n, r) => { let o = t(n), s = t(r); if (o === null || s === null) return 0; let i = o.compareDocumentPosition(s); return i & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : i & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0 }) } function lo(e, t, { sorted: n = !0, relativeTo: r = null, skipElements: o = [] } = {}) { var s; let i = (s = Array.isArray(e) ? e.length > 0 ? e[0].ownerDocument : document : e == null ? void 0 : e.ownerDocument) != null ? s : document, l = Array.isArray(e) ? n ? o1(e) : e : Xv(e); o.length > 0 && l.length > 1 && (l = l.filter(g => !o.includes(g))), r = r ?? i.activeElement; let a = (() => { if (t & 5) return 1; if (t & 10) return -1; throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), u = (() => { if (t & 1) return 0; if (t & 2) return Math.max(0, l.indexOf(r)) - 1; if (t & 4) return Math.max(0, l.indexOf(r)) + 1; if (t & 8) return l.length - 1; throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), c = t & 32 ? { preventScroll: !0 } : {}, f = 0, d = l.length, h; do { if (f >= d || f + d <= 0) return 0; let g = u + f; if (t & 16) g = (g + d) % d; else { if (g < 0) return 3; if (g >= d) return 1 } h = l[g], h == null || h.focus(c), f += a } while (h !== i.activeElement); return t & 6 && r1(h) && h.select(), 2 } function zf() { return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0 } function s1() { return /Android/gi.test(window.navigator.userAgent) } function i1() { return zf() || s1() } function Vr(e, t, n) { Lr.isServer || Ge(r => { document.addEventListener(e, t, n), r(() => document.removeEventListener(e, t, n)) }) } function qf(e, t, n) { Lr.isServer || Ge(r => { window.addEventListener(e, t, n), r(() => window.removeEventListener(e, t, n)) }) } function l1(e, t, n = R(() => !0)) { function r(s, i) { if (!n.value || s.defaultPrevented) return; let l = i(s); if (l === null || !l.getRootNode().contains(l)) return; let a = function u(c) { return typeof c == "function" ? u(c()) : Array.isArray(c) || c instanceof Set ? c : [c] }(e); for (let u of a) { if (u === null) continue; let c = u instanceof HTMLElement ? u : de(u); if (c != null && c.contains(l) || s.composed && s.composedPath().includes(c)) return } return !e1(l, Uf.Loose) && l.tabIndex !== -1 && s.preventDefault(), t(s, l) } let o = G(null); Vr("pointerdown", s => { var i, l; n.value && (o.value = ((l = (i = s.composedPath) == null ? void 0 : i.call(s)) == null ? void 0 : l[0]) || s.target) }, !0), Vr("mousedown", s => { var i, l; n.value && (o.value = ((l = (i = s.composedPath) == null ? void 0 : i.call(s)) == null ? void 0 : l[0]) || s.target) }, !0), Vr("click", s => { i1() || o.value && (r(s, () => o.value), o.value = null) }, !0), Vr("touchend", s => r(s, () => s.target instanceof HTMLElement ? s.target : null), !0), qf("blur", s => r(s, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0) } function Ba(e, t) { if (e) return e; let n = t ?? "button"; if (typeof n == "string" && n.toLowerCase() === "button") return "button" } function a1(e, t) { let n = G(Ba(e.value.type, e.value.as)); return Te(() => { n.value = Ba(e.value.type, e.value.as) }), Ge(() => { var r; n.value || de(t) && de(t) instanceof HTMLButtonElement && !((r = de(t)) != null && r.hasAttribute("type")) && (n.value = "button") }), n } var jn = (e => (e[e.None = 0] = "None", e[e.RenderStrategy = 1] = "RenderStrategy", e[e.Static = 2] = "Static", e))(jn || {}), Vt = (e => (e[e.Unmount = 0] = "Unmount", e[e.Hidden = 1] = "Hidden", e))(Vt || {}); function lt({ visible: e = !0, features: t = 0, ourProps: n, theirProps: r, ...o }) { var s; let i = Vf(r, n), l = Object.assign(o, { props: i }); if (e || t & 2 && i.static) return Ss(l); if (t & 1) { let a = (s = i.unmount) == null || s ? 0 : 1; return it(a, { 0() { return null }, 1() { return Ss({ ...o, props: { ...i, hidden: !0, style: { display: "none" } } }) } }) } return Ss(l) } function Ss({ props: e, attrs: t, slots: n, slot: r, name: o }) {
  var s, i; let { as: l, ...a } = Gf(e, ["unmount", "static"]), u = (s = n.default) == null ? void 0 : s.call(n, r), c = {}; if (r) { let f = !1, d = []; for (let [h, g] of Object.entries(r)) typeof g == "boolean" && (f = !0), g === !0 && d.push(h); f && (c["data-headlessui-state"] = d.join(" ")) } if (l === "template") {
    if (u = Wf(u ?? []), Object.keys(a).length > 0 || Object.keys(t).length > 0) {
      let [f, ...d] = u ?? []; if (!c1(f) || d.length > 0) throw new Error(['Passing props on "template"!', "", `The current component <${o} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(a).concat(Object.keys(t)).map(p => p.trim()).filter((p, b, _) => _.indexOf(p) === b).sort((p, b) => p.localeCompare(b)).map(p => `  - ${p}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map(p => `  - ${p}`).join(`
`)].join(`
`)); let h = Vf((i = f.props) != null ? i : {}, a, c), g = Mt(f, h, !0); for (let p in h) p.startsWith("on") && (g.props || (g.props = {}), g.props[p] = h[p]); return g
    } return Array.isArray(u) && u.length === 1 ? u[0] : u
  } return xe(l, Object.assign({}, a, c), { default: () => u })
} function Wf(e) { return e.flatMap(t => t.type === ke ? Wf(t.children) : [t]) } function Vf(...e) { if (e.length === 0) return {}; if (e.length === 1) return e[0]; let t = {}, n = {}; for (let r of e) for (let o in r) o.startsWith("on") && typeof r[o] == "function" ? (n[o] != null || (n[o] = []), n[o].push(r[o])) : t[o] = r[o]; if (t.disabled || t["aria-disabled"]) return Object.assign(t, Object.fromEntries(Object.keys(n).map(r => [r, void 0]))); for (let r in n) Object.assign(t, { [r](o, ...s) { let i = n[r]; for (let l of i) { if (o instanceof Event && o.defaultPrevented) return; l(o, ...s) } } }); return t } function Gf(e, t = []) { let n = Object.assign({}, e); for (let r of t) r in n && delete n[r]; return n } function c1(e) { return e == null ? !1 : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function" } var Ao = (e => (e[e.None = 1] = "None", e[e.Focusable = 2] = "Focusable", e[e.Hidden = 4] = "Hidden", e))(Ao || {}); let gi = ce({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(e, { slots: t, attrs: n }) { return () => { var r; let { features: o, ...s } = e, i = { "aria-hidden": (o & 2) === 2 ? !0 : (r = s["aria-hidden"]) != null ? r : void 0, hidden: (o & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(o & 4) === 4 && (o & 2) !== 2 && { display: "none" } } }; return lt({ ourProps: i, theirProps: s, slot: {}, attrs: n, slots: t, name: "Hidden" }) } } }), Kf = Symbol("Context"); var Le = (e => (e[e.Open = 1] = "Open", e[e.Closed = 2] = "Closed", e[e.Closing = 4] = "Closing", e[e.Opening = 8] = "Opening", e))(Le || {}); function u1() { return Jo() !== null } function Jo() { return Se(Kf, null) } function Jf(e) { Me(Kf, e) } var an = (e => (e.Space = " ", e.Enter = "Enter", e.Escape = "Escape", e.Backspace = "Backspace", e.Delete = "Delete", e.ArrowLeft = "ArrowLeft", e.ArrowUp = "ArrowUp", e.ArrowRight = "ArrowRight", e.ArrowDown = "ArrowDown", e.Home = "Home", e.End = "End", e.PageUp = "PageUp", e.PageDown = "PageDown", e.Tab = "Tab", e))(an || {}); function f1(e) { function t() { document.readyState !== "loading" && (e(), document.removeEventListener("DOMContentLoaded", t)) } typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", t), t()) } let cn = []; f1(() => { function e(t) { t.target instanceof HTMLElement && t.target !== document.body && cn[0] !== t.target && (cn.unshift(t.target), cn = cn.filter(n => n != null && n.isConnected), cn.splice(10)) } window.addEventListener("click", e, { capture: !0 }), window.addEventListener("mousedown", e, { capture: !0 }), window.addEventListener("focus", e, { capture: !0 }), document.body.addEventListener("click", e, { capture: !0 }), document.body.addEventListener("mousedown", e, { capture: !0 }), document.body.addEventListener("focus", e, { capture: !0 }) }); function Zf(e, t, n, r) { Lr.isServer || Ge(o => { e = e ?? window, e.addEventListener(t, n, r), o(() => e.removeEventListener(t, n, r)) }) } var rr = (e => (e[e.Forwards = 0] = "Forwards", e[e.Backwards = 1] = "Backwards", e))(rr || {}); function d1() { let e = G(0); return qf("keydown", t => { t.key === "Tab" && (e.value = t.shiftKey ? 1 : 0) }), e } function Qf(e) { if (!e) return new Set; if (typeof e == "function") return new Set(e()); let t = new Set; for (let n of e.value) { let r = de(n); r instanceof HTMLElement && t.add(r) } return t } var Yf = (e => (e[e.None = 1] = "None", e[e.InitialFocus = 2] = "InitialFocus", e[e.TabLock = 4] = "TabLock", e[e.FocusLock = 8] = "FocusLock", e[e.RestoreFocus = 16] = "RestoreFocus", e[e.All = 30] = "All", e))(Yf || {}); let Xn = Object.assign(ce({ name: "FocusTrap", props: { as: { type: [Object, String], default: "div" }, initialFocus: { type: Object, default: null }, features: { type: Number, default: 30 }, containers: { type: [Object, Function], default: G(new Set) } }, inheritAttrs: !1, setup(e, { attrs: t, slots: n, expose: r }) { let o = G(null); r({ el: o, $el: o }); let s = R(() => Hn(o)), i = G(!1); Te(() => i.value = !0), Ve(() => i.value = !1), h1({ ownerDocument: s }, R(() => i.value && !!(e.features & 16))); let l = g1({ ownerDocument: s, container: o, initialFocus: R(() => e.initialFocus) }, R(() => i.value && !!(e.features & 2))); m1({ ownerDocument: s, container: o, containers: e.containers, previousActiveElement: l }, R(() => i.value && !!(e.features & 8))); let a = d1(); function u(h) { let g = de(o); g && (p => p())(() => { it(a.value, { [rr.Forwards]: () => { lo(g, Wt.First, { skipElements: [h.relatedTarget] }) }, [rr.Backwards]: () => { lo(g, Wt.Last, { skipElements: [h.relatedTarget] }) } }) }) } let c = G(!1); function f(h) { h.key === "Tab" && (c.value = !0, requestAnimationFrame(() => { c.value = !1 })) } function d(h) { if (!i.value) return; let g = Qf(e.containers); de(o) instanceof HTMLElement && g.add(de(o)); let p = h.relatedTarget; p instanceof HTMLElement && p.dataset.headlessuiFocusGuard !== "true" && (Xf(g, p) || (c.value ? lo(de(o), it(a.value, { [rr.Forwards]: () => Wt.Next, [rr.Backwards]: () => Wt.Previous }) | Wt.WrapAround, { relativeTo: h.target }) : h.target instanceof HTMLElement && mn(h.target))) } return () => { let h = {}, g = { ref: o, onKeydown: f, onFocusout: d }, { features: p, initialFocus: b, containers: _, ...C } = e; return xe(ke, [!!(p & 4) && xe(gi, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: u, features: Ao.Focusable }), lt({ ourProps: g, theirProps: { ...t, ...C }, slot: h, attrs: t, slots: n, name: "FocusTrap" }), !!(p & 4) && xe(gi, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: u, features: Ao.Focusable })]) } } }), { features: Yf }); function p1(e) { let t = G(cn.slice()); return We([e], ([n], [r]) => { r === !0 && n === !1 ? sl(() => { t.value.splice(0) }) : r === !1 && n === !0 && (t.value = cn.slice()) }, { flush: "post" }), () => { var n; return (n = t.value.find(r => r != null && r.isConnected)) != null ? n : null } } function h1({ ownerDocument: e }, t) { let n = p1(t); Te(() => { Ge(() => { var r, o; t.value || ((r = e.value) == null ? void 0 : r.activeElement) === ((o = e.value) == null ? void 0 : o.body) && mn(n()) }, { flush: "post" }) }), Ve(() => { t.value && mn(n()) }) } function g1({ ownerDocument: e, container: t, initialFocus: n }, r) { let o = G(null), s = G(!1); return Te(() => s.value = !0), Ve(() => s.value = !1), Te(() => { We([t, n, r], (i, l) => { if (i.every((u, c) => (l == null ? void 0 : l[c]) === u) || !r.value) return; let a = de(t); a && sl(() => { var u, c; if (!s.value) return; let f = de(n), d = (u = e.value) == null ? void 0 : u.activeElement; if (f) { if (f === d) { o.value = d; return } } else if (a.contains(d)) { o.value = d; return } f ? mn(f) : lo(a, Wt.First | Wt.NoScroll) === Df.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), o.value = (c = e.value) == null ? void 0 : c.activeElement }) }, { immediate: !0, flush: "post" }) }), o } function m1({ ownerDocument: e, container: t, containers: n, previousActiveElement: r }, o) { var s; Zf((s = e.value) == null ? void 0 : s.defaultView, "focus", i => { if (!o.value) return; let l = Qf(n); de(t) instanceof HTMLElement && l.add(de(t)); let a = r.value; if (!a) return; let u = i.target; u && u instanceof HTMLElement ? Xf(l, u) ? (r.value = u, mn(u)) : (i.preventDefault(), i.stopPropagation(), mn(a)) : mn(r.value) }, !0) } function Xf(e, t) { for (let n of e) if (n.contains(t)) return !0; return !1 } function y1(e) { let t = pr(e.getSnapshot()); return Ve(e.subscribe(() => { t.value = e.getSnapshot() })), t } function b1(e, t) { let n = e(), r = new Set; return { getSnapshot() { return n }, subscribe(o) { return r.add(o), () => r.delete(o) }, dispatch(o, ...s) { let i = t[o].call(n, ...s); i && (n = i, r.forEach(l => l())) } } } function v1() { let e; return { before({ doc: t }) { var n; let r = t.documentElement; e = ((n = t.defaultView) != null ? n : window).innerWidth - r.clientWidth }, after({ doc: t, d: n }) { let r = t.documentElement, o = r.clientWidth - r.offsetWidth, s = e - o; n.style(r, "paddingRight", `${s}px`) } } } function w1() { return zf() ? { before({ doc: e, d: t, meta: n }) { function r(o) { return n.containers.flatMap(s => s()).some(s => s.contains(o)) } t.microTask(() => { var o; if (window.getComputedStyle(e.documentElement).scrollBehavior !== "auto") { let l = Ir(); l.style(e.documentElement, "scrollBehavior", "auto"), t.add(() => t.microTask(() => l.dispose())) } let s = (o = window.scrollY) != null ? o : window.pageYOffset, i = null; t.addEventListener(e, "click", l => { if (l.target instanceof HTMLElement) try { let a = l.target.closest("a"); if (!a) return; let { hash: u } = new URL(a.href), c = e.querySelector(u); c && !r(c) && (i = c) } catch { } }, !0), t.addEventListener(e, "touchstart", l => { if (l.target instanceof HTMLElement) if (r(l.target)) { let a = l.target; for (; a.parentElement && r(a.parentElement);)a = a.parentElement; t.style(a, "overscrollBehavior", "contain") } else t.style(l.target, "touchAction", "none") }), t.addEventListener(e, "touchmove", l => { if (l.target instanceof HTMLElement) { if (l.target.tagName === "INPUT") return; if (r(l.target)) { let a = l.target; for (; a.parentElement && a.dataset.headlessuiPortal !== "" && !(a.scrollHeight > a.clientHeight || a.scrollWidth > a.clientWidth);)a = a.parentElement; a.dataset.headlessuiPortal === "" && l.preventDefault() } else l.preventDefault() } }, { passive: !1 }), t.add(() => { var l; let a = (l = window.scrollY) != null ? l : window.pageYOffset; s !== a && window.scrollTo(0, s), i && i.isConnected && (i.scrollIntoView({ block: "nearest" }), i = null) }) }) } } : {} } function x1() { return { before({ doc: e, d: t }) { t.style(e.documentElement, "overflow", "hidden") } } } function _1(e) { let t = {}; for (let n of e) Object.assign(t, n(t)); return t } let un = b1(() => new Map, { PUSH(e, t) { var n; let r = (n = this.get(e)) != null ? n : { doc: e, count: 0, d: Ir(), meta: new Set }; return r.count++, r.meta.add(t), this.set(e, r), this }, POP(e, t) { let n = this.get(e); return n && (n.count--, n.meta.delete(t)), this }, SCROLL_PREVENT({ doc: e, d: t, meta: n }) { let r = { doc: e, d: t, meta: _1(n) }, o = [w1(), v1(), x1()]; o.forEach(({ before: s }) => s == null ? void 0 : s(r)), o.forEach(({ after: s }) => s == null ? void 0 : s(r)) }, SCROLL_ALLOW({ d: e }) { e.dispose() }, TEARDOWN({ doc: e }) { this.delete(e) } }); un.subscribe(() => { let e = un.getSnapshot(), t = new Map; for (let [n] of e) t.set(n, n.documentElement.style.overflow); for (let n of e.values()) { let r = t.get(n.doc) === "hidden", o = n.count !== 0; (o && !r || !o && r) && un.dispatch(n.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", n), n.count === 0 && un.dispatch("TEARDOWN", n) } }); function S1(e, t, n) { let r = y1(un), o = R(() => { let s = e.value ? r.value.get(e.value) : void 0; return s ? s.count > 0 : !1 }); return We([e, t], ([s, i], [l], a) => { if (!s || !i) return; un.dispatch("PUSH", s, n); let u = !1; a(() => { u || (un.dispatch("POP", l ?? s, n), u = !0) }) }, { immediate: !0 }), o } let Cs = new Map, er = new Map; function Ha(e, t = G(!0)) { Ge(n => { var r; if (!t.value) return; let o = de(e); if (!o) return; n(function () { var i; if (!o) return; let l = (i = er.get(o)) != null ? i : 1; if (l === 1 ? er.delete(o) : er.set(o, l - 1), l !== 1) return; let a = Cs.get(o); a && (a["aria-hidden"] === null ? o.removeAttribute("aria-hidden") : o.setAttribute("aria-hidden", a["aria-hidden"]), o.inert = a.inert, Cs.delete(o)) }); let s = (r = er.get(o)) != null ? r : 0; er.set(o, s + 1), s === 0 && (Cs.set(o, { "aria-hidden": o.getAttribute("aria-hidden"), inert: o.inert }), o.setAttribute("aria-hidden", "true"), o.inert = !0) }) } function C1({ defaultContainers: e = [], portals: t, mainTreeNodeRef: n } = {}) { let r = G(null), o = Hn(r); function s() { var i, l, a; let u = []; for (let c of e) c !== null && (c instanceof HTMLElement ? u.push(c) : "value" in c && c.value instanceof HTMLElement && u.push(c.value)); if (t != null && t.value) for (let c of t.value) u.push(c); for (let c of (i = o == null ? void 0 : o.querySelectorAll("html > *, body > *")) != null ? i : []) c !== document.body && c !== document.head && c instanceof HTMLElement && c.id !== "headlessui-portal-root" && (c.contains(de(r)) || c.contains((a = (l = de(r)) == null ? void 0 : l.getRootNode()) == null ? void 0 : a.host) || u.some(f => c.contains(f)) || u.push(c)); return u } return { resolveContainers: s, contains(i) { return s().some(l => l.contains(i)) }, mainTreeNodeRef: r, MainTreeNode() { return n != null ? null : xe(gi, { features: Ao.Hidden, ref: r }) } } } let ed = Symbol("ForcePortalRootContext"); function k1() { return Se(ed, !1) } let Da = ce({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: !1 } }, setup(e, { slots: t, attrs: n }) { return Me(ed, e.force), () => { let { force: r, ...o } = e; return lt({ theirProps: o, ourProps: {}, slot: {}, slots: t, attrs: n, name: "ForcePortalRoot" }) } } }), td = Symbol("StackContext"); var mi = (e => (e[e.Add = 0] = "Add", e[e.Remove = 1] = "Remove", e))(mi || {}); function E1() { return Se(td, () => { }) } function T1({ type: e, enabled: t, element: n, onUpdate: r }) { let o = E1(); function s(...i) { r == null || r(...i), o(...i) } Te(() => { We(t, (i, l) => { i ? s(0, e, n) : l === !0 && s(1, e, n) }, { immediate: !0, flush: "sync" }) }), Ve(() => { t.value && s(1, e, n) }), Me(td, s) } let A1 = Symbol("DescriptionContext"); function P1({ slot: e = G({}), name: t = "Description", props: n = {} } = {}) { let r = G([]); function o(s) { return r.value.push(s), () => { let i = r.value.indexOf(s); i !== -1 && r.value.splice(i, 1) } } return Me(A1, { register: o, slot: e, name: t, props: n }), R(() => r.value.length > 0 ? r.value.join(" ") : void 0) } function $1(e) { let t = Hn(e); if (!t) { if (e === null) return null; throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${e}`) } let n = t.getElementById("headlessui-portal-root"); if (n) return n; let r = t.createElement("div"); return r.setAttribute("id", "headlessui-portal-root"), t.body.appendChild(r) } const yi = new WeakMap; function O1(e) { var t; return (t = yi.get(e)) != null ? t : 0 } function Ua(e, t) { let n = t(O1(e)); return n <= 0 ? yi.delete(e) : yi.set(e, n), n } let I1 = ce({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(e, { slots: t, attrs: n }) { let r = G(null), o = R(() => Hn(r)), s = k1(), i = Se(nd, null), l = G(s === !0 || i == null ? $1(r.value) : i.resolveTarget()); l.value && Ua(l.value, d => d + 1); let a = G(!1); Te(() => { a.value = !0 }), Ge(() => { s || i != null && (l.value = i.resolveTarget()) }); let u = Se(bi, null), c = !1, f = vn(); return We(r, () => { if (c || !u) return; let d = de(r); d && (Ve(u.register(d), f), c = !0) }), Ve(() => { var d, h; let g = (d = o.value) == null ? void 0 : d.getElementById("headlessui-portal-root"); !g || l.value !== g || Ua(l.value, p => p - 1) || l.value.children.length > 0 || (h = l.value.parentElement) == null || h.removeChild(l.value) }), () => { if (!a.value || l.value === null) return null; let d = { ref: r, "data-headlessui-portal": "" }; return xe(ap, { to: l.value }, lt({ ourProps: d, theirProps: e, slot: {}, attrs: n, slots: t, name: "Portal" })) } } }), bi = Symbol("PortalParentContext"); function L1() { let e = Se(bi, null), t = G([]); function n(s) { return t.value.push(s), e && e.register(s), () => r(s) } function r(s) { let i = t.value.indexOf(s); i !== -1 && t.value.splice(i, 1), e && e.unregister(s) } let o = { register: n, unregister: r, portals: t }; return [t, ce({ name: "PortalWrapper", setup(s, { slots: i }) { return Me(bi, o), () => { var l; return (l = i.default) == null ? void 0 : l.call(i) } } })] } let nd = Symbol("PortalGroupContext"), M1 = ce({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(e, { attrs: t, slots: n }) { let r = ut({ resolveTarget() { return e.target } }); return Me(nd, r), () => { let { target: o, ...s } = e; return lt({ theirProps: s, ourProps: {}, slot: {}, attrs: t, slots: n, name: "PortalGroup" }) } } }); var R1 = (e => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(R1 || {}); let vi = Symbol("DialogContext"); function rd(e) { let t = Se(vi, null); if (t === null) { let n = new Error(`<${e} /> is missing a parent <Dialog /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, rd), n } return t } let Gr = "DC8F892D-2EBD-447C-A4C8-A03058436FF4", j1 = ce({ name: "Dialog", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, open: { type: [Boolean, String], default: Gr }, initialFocus: { type: Object, default: null }, id: { type: String, default: null }, role: { type: String, default: "dialog" } }, emits: { close: e => !0 }, setup(e, { emit: t, attrs: n, slots: r, expose: o }) { var s, i; let l = (s = e.id) != null ? s : `headlessui-dialog-${_r()}`, a = G(!1); Te(() => { a.value = !0 }); let u = !1, c = R(() => e.role === "dialog" || e.role === "alertdialog" ? e.role : (u || (u = !0, console.warn(`Invalid role [${c}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog")), f = G(0), d = Jo(), h = R(() => e.open === Gr && d !== null ? (d.value & Le.Open) === Le.Open : e.open), g = G(null), p = R(() => Hn(g)); if (o({ el: g, $el: g }), !(e.open !== Gr || d !== null)) throw new Error("You forgot to provide an `open` prop to the `Dialog`."); if (typeof h.value != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${h.value === Gr ? void 0 : e.open}`); let b = R(() => a.value && h.value ? 0 : 1), _ = R(() => b.value === 0), C = R(() => f.value > 1), y = Se(vi, null) !== null, [w, S] = L1(), { resolveContainers: k, mainTreeNodeRef: M, MainTreeNode: D } = C1({ portals: w, defaultContainers: [R(() => { var ee; return (ee = Z.panelRef.value) != null ? ee : g.value })] }), A = R(() => C.value ? "parent" : "leaf"), P = R(() => d !== null ? (d.value & Le.Closing) === Le.Closing : !1), W = R(() => y || P.value ? !1 : _.value), T = R(() => { var ee, le, Be; return (Be = Array.from((le = (ee = p.value) == null ? void 0 : ee.querySelectorAll("body > *")) != null ? le : []).find(ze => ze.id === "headlessui-portal-root" ? !1 : ze.contains(de(M)) && ze instanceof HTMLElement)) != null ? Be : null }); Ha(T, W); let U = R(() => C.value ? !0 : _.value), te = R(() => { var ee, le, Be; return (Be = Array.from((le = (ee = p.value) == null ? void 0 : ee.querySelectorAll("[data-headlessui-portal]")) != null ? le : []).find(ze => ze.contains(de(M)) && ze instanceof HTMLElement)) != null ? Be : null }); Ha(te, U), T1({ type: "Dialog", enabled: R(() => b.value === 0), element: g, onUpdate: (ee, le) => { if (le === "Dialog") return it(ee, { [mi.Add]: () => f.value += 1, [mi.Remove]: () => f.value -= 1 }) } }); let oe = P1({ name: "DialogDescription", slot: R(() => ({ open: h.value })) }), F = G(null), Z = { titleId: F, panelRef: G(null), dialogState: b, setTitleId(ee) { F.value !== ee && (F.value = ee) }, close() { t("close", !1) } }; Me(vi, Z); let q = R(() => !(!_.value || C.value)); l1(k, (ee, le) => { ee.preventDefault(), Z.close(), Ii(() => le == null ? void 0 : le.focus()) }, q); let ge = R(() => !(C.value || b.value !== 0)); Zf((i = p.value) == null ? void 0 : i.defaultView, "keydown", ee => { ge.value && (ee.defaultPrevented || ee.key === an.Escape && (ee.preventDefault(), ee.stopPropagation(), Z.close())) }); let ht = R(() => !(P.value || b.value !== 0 || y)); return S1(p, ht, ee => { var le; return { containers: [...(le = ee.containers) != null ? le : [], k] } }), Ge(ee => { if (b.value !== 0) return; let le = de(g); if (!le) return; let Be = new ResizeObserver(ze => { for (let Dn of ze) { let gt = Dn.target.getBoundingClientRect(); gt.x === 0 && gt.y === 0 && gt.width === 0 && gt.height === 0 && Z.close() } }); Be.observe(le), ee(() => Be.disconnect()) }), () => { let { open: ee, initialFocus: le, ...Be } = e, ze = { ...n, ref: g, id: l, role: c.value, "aria-modal": b.value === 0 ? !0 : void 0, "aria-labelledby": F.value, "aria-describedby": oe.value }, Dn = { open: b.value === 0 }; return xe(Da, { force: !0 }, () => [xe(I1, () => xe(M1, { target: g.value }, () => xe(Da, { force: !1 }, () => xe(Xn, { initialFocus: le, containers: k, features: _.value ? it(A.value, { parent: Xn.features.RestoreFocus, leaf: Xn.features.All & ~Xn.features.FocusLock }) : Xn.features.None }, () => xe(S, {}, () => lt({ ourProps: ze, theirProps: { ...Be, ...n }, slot: Dn, attrs: n, slots: r, visible: b.value === 0, features: jn.RenderStrategy | jn.Static, name: "Dialog" })))))), xe(D)]) } } }), N1 = ce({ name: "DialogPanel", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: null } }, setup(e, { attrs: t, slots: n, expose: r }) { var o; let s = (o = e.id) != null ? o : `headlessui-dialog-panel-${_r()}`, i = rd("DialogPanel"); r({ el: i.panelRef, $el: i.panelRef }); function l(a) { a.stopPropagation() } return () => { let { ...a } = e, u = { id: s, ref: i.panelRef, onClick: l }; return lt({ ourProps: u, theirProps: a, slot: { open: i.dialogState.value === 0 }, attrs: t, slots: n, name: "DialogPanel" }) } } }); var F1 = (e => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(F1 || {}); let od = Symbol("DisclosureContext"); function il(e) { let t = Se(od, null); if (t === null) { let n = new Error(`<${e} /> is missing a parent <Disclosure /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, il), n } return t } let sd = Symbol("DisclosurePanelContext"); function B1() { return Se(sd, null) } let H1 = ce({ name: "Disclosure", props: { as: { type: [Object, String], default: "template" }, defaultOpen: { type: [Boolean], default: !1 } }, setup(e, { slots: t, attrs: n }) { let r = G(e.defaultOpen ? 0 : 1), o = G(null), s = G(null), i = { buttonId: G(`headlessui-disclosure-button-${_r()}`), panelId: G(`headlessui-disclosure-panel-${_r()}`), disclosureState: r, panel: o, button: s, toggleDisclosure() { r.value = it(r.value, { 0: 1, 1: 0 }) }, closeDisclosure() { r.value !== 1 && (r.value = 1) }, close(l) { i.closeDisclosure(); let a = l ? l instanceof HTMLElement ? l : l.value instanceof HTMLElement ? de(l) : de(i.button) : de(i.button); a == null || a.focus() } }; return Me(od, i), Jf(R(() => it(r.value, { 0: Le.Open, 1: Le.Closed }))), () => { let { defaultOpen: l, ...a } = e, u = { open: r.value === 0, close: i.close }; return lt({ theirProps: a, ourProps: {}, slot: u, slots: t, attrs: n, name: "Disclosure" }) } } }), D1 = ce({ name: "DisclosureButton", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: !1 }, id: { type: String, default: null } }, setup(e, { attrs: t, slots: n, expose: r }) { let o = il("DisclosureButton"), s = B1(), i = R(() => s === null ? !1 : s.value === o.panelId.value); Te(() => { i.value || e.id !== null && (o.buttonId.value = e.id) }), Ve(() => { i.value || (o.buttonId.value = null) }); let l = G(null); r({ el: l, $el: l }), i.value || Ge(() => { o.button.value = l.value }); let a = a1(R(() => ({ as: e.as, type: t.type })), l); function u() { var d; e.disabled || (i.value ? (o.toggleDisclosure(), (d = de(o.button)) == null || d.focus()) : o.toggleDisclosure()) } function c(d) { var h; if (!e.disabled) if (i.value) switch (d.key) { case an.Space: case an.Enter: d.preventDefault(), d.stopPropagation(), o.toggleDisclosure(), (h = de(o.button)) == null || h.focus(); break } else switch (d.key) { case an.Space: case an.Enter: d.preventDefault(), d.stopPropagation(), o.toggleDisclosure(); break } } function f(d) { switch (d.key) { case an.Space: d.preventDefault(); break } } return () => { var d; let h = { open: o.disclosureState.value === 0 }, { id: g, ...p } = e, b = i.value ? { ref: l, type: a.value, onClick: u, onKeydown: c } : { id: (d = o.buttonId.value) != null ? d : g, ref: l, type: a.value, "aria-expanded": o.disclosureState.value === 0, "aria-controls": o.disclosureState.value === 0 || de(o.panel) ? o.panelId.value : void 0, disabled: e.disabled ? !0 : void 0, onClick: u, onKeydown: c, onKeyup: f }; return lt({ ourProps: b, theirProps: p, slot: h, attrs: t, slots: n, name: "DisclosureButton" }) } } }), U1 = ce({ name: "DisclosurePanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: null } }, setup(e, { attrs: t, slots: n, expose: r }) { let o = il("DisclosurePanel"); Te(() => { e.id !== null && (o.panelId.value = e.id) }), Ve(() => { o.panelId.value = null }), r({ el: o.panel, $el: o.panel }), Me(sd, o.panelId); let s = Jo(), i = R(() => s !== null ? (s.value & Le.Open) === Le.Open : o.disclosureState.value === 0); return () => { var l; let a = { open: o.disclosureState.value === 0, close: o.close }, { id: u, ...c } = e, f = { id: (l = o.panelId.value) != null ? l : u, ref: o.panel }; return lt({ ourProps: f, theirProps: c, slot: a, attrs: t, slots: n, features: jn.RenderStrategy | jn.Static, visible: i.value, name: "DisclosurePanel" }) } } }); function z1(e) { let t = { called: !1 }; return (...n) => { if (!t.called) return t.called = !0, e(...n) } } function ks(e, ...t) { e && t.length > 0 && e.classList.add(...t) } function Kr(e, ...t) { e && t.length > 0 && e.classList.remove(...t) } var wi = (e => (e.Finished = "finished", e.Cancelled = "cancelled", e))(wi || {}); function q1(e, t) { let n = Ir(); if (!e) return n.dispose; let { transitionDuration: r, transitionDelay: o } = getComputedStyle(e), [s, i] = [r, o].map(l => { let [a = 0] = l.split(",").filter(Boolean).map(u => u.includes("ms") ? parseFloat(u) : parseFloat(u) * 1e3).sort((u, c) => c - u); return a }); return s !== 0 ? n.setTimeout(() => t("finished"), s + i) : t("finished"), n.add(() => t("cancelled")), n.dispose } function za(e, t, n, r, o, s) { let i = Ir(), l = s !== void 0 ? z1(s) : () => { }; return Kr(e, ...o), ks(e, ...t, ...n), i.nextFrame(() => { Kr(e, ...n), ks(e, ...r), i.add(q1(e, a => (Kr(e, ...r, ...t), ks(e, ...o), l(a)))) }), i.add(() => Kr(e, ...t, ...n, ...r, ...o)), i.add(() => l("cancelled")), i.dispose } function sn(e = "") { return e.split(/\s+/).filter(t => t.length > 1) } let ll = Symbol("TransitionContext"); var W1 = (e => (e.Visible = "visible", e.Hidden = "hidden", e))(W1 || {}); function V1() { return Se(ll, null) !== null } function G1() { let e = Se(ll, null); if (e === null) throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."); return e } function K1() { let e = Se(al, null); if (e === null) throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."); return e } let al = Symbol("NestingContext"); function Zo(e) { return "children" in e ? Zo(e.children) : e.value.filter(({ state: t }) => t === "visible").length > 0 } function id(e) { let t = G([]), n = G(!1); Te(() => n.value = !0), Ve(() => n.value = !1); function r(s, i = Vt.Hidden) { let l = t.value.findIndex(({ id: a }) => a === s); l !== -1 && (it(i, { [Vt.Unmount]() { t.value.splice(l, 1) }, [Vt.Hidden]() { t.value[l].state = "hidden" } }), !Zo(t) && n.value && (e == null || e())) } function o(s) { let i = t.value.find(({ id: l }) => l === s); return i ? i.state !== "visible" && (i.state = "visible") : t.value.push({ id: s, state: "visible" }), () => r(s, Vt.Unmount) } return { children: t, register: o, unregister: r } } let ld = jn.RenderStrategy, ad = ce({ props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: !0 }, appear: { type: [Boolean], default: !1 }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => !0, afterEnter: () => !0, beforeLeave: () => !0, afterLeave: () => !0 }, setup(e, { emit: t, attrs: n, slots: r, expose: o }) { let s = G(0); function i() { s.value |= Le.Opening, t("beforeEnter") } function l() { s.value &= ~Le.Opening, t("afterEnter") } function a() { s.value |= Le.Closing, t("beforeLeave") } function u() { s.value &= ~Le.Closing, t("afterLeave") } if (!V1() && u1()) return () => xe(cd, { ...e, onBeforeEnter: i, onAfterEnter: l, onBeforeLeave: a, onAfterLeave: u }, r); let c = G(null), f = R(() => e.unmount ? Vt.Unmount : Vt.Hidden); o({ el: c, $el: c }); let { show: d, appear: h } = G1(), { register: g, unregister: p } = K1(), b = G(d.value ? "visible" : "hidden"), _ = { value: !0 }, C = _r(), y = { value: !1 }, w = id(() => { !y.value && b.value !== "hidden" && (b.value = "hidden", p(C), u()) }); Te(() => { let U = g(C); Ve(U) }), Ge(() => { if (f.value === Vt.Hidden && C) { if (d.value && b.value !== "visible") { b.value = "visible"; return } it(b.value, { hidden: () => p(C), visible: () => g(C) }) } }); let S = sn(e.enter), k = sn(e.enterFrom), M = sn(e.enterTo), D = sn(e.entered), A = sn(e.leave), P = sn(e.leaveFrom), W = sn(e.leaveTo); Te(() => { Ge(() => { if (b.value === "visible") { let U = de(c); if (U instanceof Comment && U.data === "") throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?") } }) }); function T(U) { let te = _.value && !h.value, oe = de(c); !oe || !(oe instanceof HTMLElement) || te || (y.value = !0, d.value && i(), d.value || a(), U(d.value ? za(oe, S, k, M, D, F => { y.value = !1, F === wi.Finished && l() }) : za(oe, A, P, W, D, F => { y.value = !1, F === wi.Finished && (Zo(w) || (b.value = "hidden", p(C), u())) }))) } return Te(() => { We([d], (U, te, oe) => { T(oe), _.value = !1 }, { immediate: !0 }) }), Me(al, w), Jf(R(() => it(b.value, { visible: Le.Open, hidden: Le.Closed }) | s.value)), () => { let { appear: U, show: te, enter: oe, enterFrom: F, enterTo: Z, entered: q, leave: ge, leaveFrom: ht, leaveTo: ee, ...le } = e, Be = { ref: c }, ze = { ...le, ...h.value && d.value && Lr.isServer ? { class: $e([n.class, le.class, ...S, ...k]) } : {} }; return lt({ theirProps: ze, ourProps: Be, slot: {}, slots: r, attrs: n, features: ld, visible: b.value === "visible", name: "TransitionChild" }) } } }), J1 = ad, cd = ce({ inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: !0 }, appear: { type: [Boolean], default: !1 }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => !0, afterEnter: () => !0, beforeLeave: () => !0, afterLeave: () => !0 }, setup(e, { emit: t, attrs: n, slots: r }) { let o = Jo(), s = R(() => e.show === null && o !== null ? (o.value & Le.Open) === Le.Open : e.show); Ge(() => { if (![!0, !1].includes(s.value)) throw new Error('A <Transition /> is used but it is missing a `:show="true | false"` prop.') }); let i = G(s.value ? "visible" : "hidden"), l = id(() => { i.value = "hidden" }), a = G(!0), u = { show: s, appear: R(() => e.appear || !a.value) }; return Te(() => { Ge(() => { a.value = !1, s.value ? i.value = "visible" : Zo(l) || (i.value = "hidden") }) }), Me(al, l), Me(ll, u), () => { let c = Gf(e, ["show", "appear", "unmount", "onBeforeEnter", "onBeforeLeave", "onAfterEnter", "onAfterLeave"]), f = { unmount: e.unmount }; return lt({ ourProps: { ...f, as: "template" }, theirProps: {}, slot: {}, slots: { ...r, default: () => [xe(J1, { onBeforeEnter: () => t("beforeEnter"), onAfterEnter: () => t("afterEnter"), onBeforeLeave: () => t("beforeLeave"), onAfterLeave: () => t("afterLeave"), ...n, ...f, ...c }, r.default)] }, attrs: {}, features: ld, visible: i.value === "visible", name: "Transition" }) } } }); const Z1 = Pr(pt.ui.strategy, pt.ui.slideover, Uv), Q1 = ce({ components: { HDialog: j1, HDialogPanel: N1, TransitionRoot: cd, TransitionChild: ad }, inheritAttrs: !1, props: { modelValue: { type: Boolean, default: !1 }, appear: { type: Boolean, default: !1 }, side: { type: String, default: "right", validator: e => ["left", "right", "top", "bottom"].includes(e) }, overlay: { type: Boolean, default: !0 }, transition: { type: Boolean, default: !0 }, preventClose: { type: Boolean, default: !1 }, class: { type: [String, Object, Array], default: () => "" }, ui: { type: Object, default: () => ({}) } }, emits: ["update:modelValue", "close", "close-prevented", "after-leave"], setup(e, { emit: t }) { const { ui: n, attrs: r } = nl("slideover", yn(e, "ui"), Z1, yn(e, "class")), o = R({ get() { return e.modelValue }, set(u) { t("update:modelValue", u) } }), s = R(() => { if (!e.transition) return {}; let u, c; switch (e.side) { case "left": u = n.value.translate.left, c = n.value.translate.left; break; case "right": u = n.value.translate.right, c = n.value.translate.right; break; case "top": u = n.value.translate.top, c = n.value.translate.top; break; case "bottom": u = n.value.translate.bottom, c = n.value.translate.bottom; break; default: u = n.value.translate.right, c = n.value.translate.right }return { ...n.value.transition, enterFrom: u, enterTo: n.value.translate.base, leaveFrom: n.value.translate.base, leaveTo: c } }), i = R(() => { switch (e.side) { case "left": return "horizontal"; case "right": return "horizontal"; case "top": return "vertical"; case "bottom": return "vertical"; default: return "right" } }); function l(u) { if (e.preventClose) { t("close-prevented"); return } o.value = u, t("close") } const a = () => { t("after-leave") }; return Hf(() => Mi()), { ui: n, attrs: r, isOpen: o, transitionClass: s, sideType: i, onAfterLeave: a, close: l } } }); function Y1(e, t, n, r, o, s) { const i = It("TransitionChild"), l = It("HDialogPanel"), a = It("HDialog"), u = It("TransitionRoot"); return se(), Ce(u, { as: "template", appear: e.appear, show: e.isOpen, onAfterLeave: e.onAfterLeave }, { default: X(() => [z(a, ot({ class: [e.ui.wrapper, { "justify-end": e.side === "right" }, { "items-end": e.side === "bottom" }] }, e.attrs, { onClose: e.close }), { default: X(() => [e.overlay ? (se(), Ce(i, ot({ key: 0, as: "template", appear: e.appear }, e.ui.overlay.transition, { class: e.ui.overlay.transition.enterFrom }), { default: X(() => [m("div", { class: $e([e.ui.overlay.base, e.ui.overlay.background]) }, null, 2)]), _: 1 }, 16, ["appear", "class"])) : Xr("", !0), z(i, ot({ as: "template", appear: e.appear }, e.transitionClass, { class: e.transitionClass.enterFrom }), { default: X(() => [z(l, { class: $e([e.ui.base, e.sideType === "horizontal" ? [e.ui.width, "h-full"] : [e.ui.height, "w-full"], e.ui.background, e.ui.ring, e.ui.rounded, e.ui.padding, e.ui.shadow]) }, { default: X(() => [Xe(e.$slots, "default")]), _: 3 }, 8, ["class"])]), _: 3 }, 16, ["appear", "class"])]), _: 3 }, 16, ["class", "onClose"])]), _: 3 }, 8, ["appear", "show", "onAfterLeave"]) } const X1 = en(Q1, [["render", Y1]]), ew = { class: "py-6 sm:py-10" }, tw = { class: "h-full py-10" }, nw = { class: "flex items-center justify-between" }, rw = { class: "flex flex-col gap-y-5" }, ow = { class: "hidden gap-x-7 min-[1120px]:flex" }, sw = ce({ __name: "AppHeader", setup(e) { const t = [{ label: "Что такое IDO?", to: "/#chto-takoe-ido" }, { label: "Как это работает", to: "/#kak-eto-rabotaet" }, { label: "Плюсы", to: "/#pochemu-sobirayutsya-puly" }, { label: "Команда", to: "/#nasha-komanda" }, { label: "Заявка на участие", to: "https://t.me/artem_tudorin", featured: !0 }], n = t.filter(s => !s.featured), r = zi(), o = G(!1); return We(() => r, () => o.value = !1, { deep: !0 }), (s, i) => { const l = ev, a = rl, u = Or, c = Ff, f = ol, d = X1; return se(), Fe("header", ew, [z(d, { modelValue: we(o), "onUpdate:modelValue": i[1] || (i[1] = h => Ee(o) ? o.value = h : null) }, { default: X(() => [m("div", tw, [z(f, { class: "flex h-full flex-col gap-y-[60px]" }, { default: X(() => [m("div", nw, [z(a, { class: "focus-visible:ring-0", variant: "link", padded: !1, to: "/" }, { default: X(() => [z(l, { class: "h-14 w-auto sm:h-auto" })]), _: 1 }), z(a, { ui: { rounded: "rounded-[10px]" }, variant: "outline", icon: "i-heroicons-x-mark", onClick: i[0] || (i[0] = h => o.value = !1) })]), m("div", rw, [(se(!0), Fe(ke, null, ho(we(n), h => (se(), Ce(u, { key: h.label, class: "text-lg font-semibold transition-opacity hover:opacity-70", to: h.to }, { default: X(() => [ne(Ot(h.label), 1)]), _: 2 }, 1032, ["to"]))), 128))]), z(c, { class: "mt-auto w-full", to: t[4].to }, { default: X(() => [ne(Ot(t[4].label), 1)]), _: 1 }, 8, ["to"])]), _: 1 })])]), _: 1 }, 8, ["modelValue"]), z(f, { class: "flex items-center justify-between" }, { default: X(() => [z(a, { class: "focus-visible:ring-0", variant: "link", padded: !1, to: "/" }, { default: X(() => [z(l, { class: "h-14 w-auto sm:h-auto" })]), _: 1 }), m("div", ow, [(se(), Fe(ke, null, ho(t, h => z(u, { key: h.label, to: h.to, class: $e(["hover:border-primary mt-0.5 border-b-2 border-transparent transition hover:opacity-70", { "font-bold xl:hidden": h.featured }]) }, { default: X(() => [ne(Ot(h.label), 1)]), _: 2 }, 1032, ["to", "class"])), 64))]), z(a, { class: "xl:hidden", ui: { rounded: "rounded-[10px]" }, icon: "i-heroicons-bars-3", onClick: i[2] || (i[2] = h => o.value = !0) }), z(c, { class: "hidden xl:inline-flex", block: "", to: t[4].to, target: "_blank" }, { default: X(() => [ne(Ot(t[4].label), 1)]), _: 1 }, 8, ["to"])]), _: 1 })]) } } }); async function iw(e, t) { return await lw(t).catch(r => (console.error("Failed to get image meta for " + t, r + ""), { width: 0, height: 0, ratio: 0 })) } async function lw(e) { if (typeof Image > "u") throw new TypeError("Image not supported"); return new Promise((t, n) => { const r = new Image; r.onload = () => { const o = { width: r.width, height: r.height, ratio: r.width / r.height }; t(o) }, r.onerror = o => n(o), r.src = e }) } function qa(e) { return t => t ? e[t] || t : e.missingValue } function aw({ formatter: e, keyMap: t, joinWith: n = "/", valueMap: r } = {}) { e || (e = (s, i) => `${s}=${i}`), t && typeof t != "function" && (t = qa(t)); const o = r || {}; return Object.keys(o).forEach(s => { typeof o[s] != "function" && (o[s] = qa(o[s])) }), (s = {}) => Object.entries(s).filter(([l, a]) => typeof a < "u").map(([l, a]) => { const u = o[l]; return typeof u == "function" && (a = u(s[l])), l = typeof t == "function" ? t(l) : l, e(l, a) }).join(n) } function wt(e = "") { if (typeof e == "number") return e; if (typeof e == "string" && e.replace("px", "").match(/^\d+$/g)) return Number.parseInt(e, 10) } function cw(e = "") { if (e === void 0 || !e.length) return []; const t = new Set; for (const n of e.split(" ")) { const r = Number.parseInt(n.replace("x", "")); r && t.add(r) } return Array.from(t) } function uw(e) { if (e.length === 0) throw new Error("`densities` must not be empty, configure to `1` to render regular size only (DPR 1.0)") } function fw(e) { const t = {}; if (typeof e == "string") for (const n of e.split(/[\s,]+/).filter(r => r)) { const r = n.split(":"); r.length !== 2 ? t["1px"] = r[0].trim() : t[r[0].trim()] = r[1].trim() } else Object.assign(t, e); return t } function dw(e) { const t = { options: e }, n = (o, s = {}) => ud(t, o, s), r = (o, s = {}, i = {}) => n(o, { ...i, modifiers: Ar(s, i.modifiers || {}) }).url; for (const o in e.presets) r[o] = (s, i, l) => r(s, i, { ...e.presets[o], ...l }); return r.options = e, r.getImage = n, r.getMeta = (o, s) => pw(t, o, s), r.getSizes = (o, s) => mw(t, o, s), t.$img = r, r } async function pw(e, t, n) { const r = ud(e, t, { ...n }); return typeof r.getMeta == "function" ? await r.getMeta() : await iw(e, r.url) } function ud(e, t, n) { var u, c; if (t && typeof t != "string") throw new TypeError(`input must be a string (received ${typeof t}: ${JSON.stringify(t)})`); if (!t || t.startsWith("data:")) return { url: t }; const { provider: r, defaults: o } = hw(e, n.provider || e.options.provider), s = gw(e, n.preset); if (t = _t(t) ? t : Ws(t), !r.supportsAlias) { for (const f in e.options.alias) if (t.startsWith(f)) { const d = e.options.alias[f]; d && (t = Jt(d, t.slice(f.length))) } } if (r.validateDomains && _t(t)) { const f = Hi(t).host; if (!e.options.domains.find(d => d === f)) return { url: t } } const i = Ar(n, s, o); i.modifiers = { ...i.modifiers }; const l = i.modifiers.format; (u = i.modifiers) != null && u.width && (i.modifiers.width = wt(i.modifiers.width)), (c = i.modifiers) != null && c.height && (i.modifiers.height = wt(i.modifiers.height)); const a = r.getImage(t, i, e); return a.format = a.format || l || "", a } function hw(e, t) { const n = e.options.providers[t]; if (!n) throw new Error("Unknown provider: " + t); return n } function gw(e, t) { if (!t) return {}; if (!e.options.presets[t]) throw new Error("Unknown preset: " + t); return e.options.presets[t] } function mw(e, t, n) { var g, p, b, _, C; const r = wt((g = n.modifiers) == null ? void 0 : g.width), o = wt((p = n.modifiers) == null ? void 0 : p.height), s = fw(n.sizes), i = (b = n.densities) != null && b.trim() ? cw(n.densities.trim()) : e.options.densities; uw(i); const l = r && o ? o / r : 0, a = [], u = []; if (Object.keys(s).length >= 1) { for (const y in s) { const w = Wa(y, String(s[y]), o, l, e); if (w !== void 0) { a.push({ size: w.size, screenMaxWidth: w.screenMaxWidth, media: `(max-width: ${w.screenMaxWidth}px)` }); for (const S of i) u.push({ width: w._cWidth * S, src: Va(e, t, n, w, S) }) } } yw(a) } else for (const y of i) { const w = Object.keys(s)[0]; let S = w ? Wa(w, String(s[w]), o, l, e) : void 0; S === void 0 && (S = { size: "", screenMaxWidth: 0, _cWidth: (_ = n.modifiers) == null ? void 0 : _.width, _cHeight: (C = n.modifiers) == null ? void 0 : C.height }), u.push({ width: y, src: Va(e, t, n, S, y) }) } bw(u); const c = u[u.length - 1], f = a.length ? a.map(y => `${y.media ? y.media + " " : ""}${y.size}`).join(", ") : void 0, d = f ? "w" : "x", h = u.map(y => `${y.src} ${y.width}${d}`).join(", "); return { sizes: f, srcset: h, src: c == null ? void 0 : c.src } } function Wa(e, t, n, r, o) { const s = o.options.screens && o.options.screens[e] || Number.parseInt(e), i = t.endsWith("vw"); if (!i && /^\d+$/.test(t) && (t = t + "px"), !i && !t.endsWith("px")) return; let l = Number.parseInt(t); if (!s || !l) return; i && (l = Math.round(l / 100 * s)); const a = r ? Math.round(l * r) : n; return { size: t, screenMaxWidth: s, _cWidth: l, _cHeight: a } } function Va(e, t, n, r, o) { return e.$img(t, { ...n.modifiers, width: r._cWidth ? r._cWidth * o : void 0, height: r._cHeight ? r._cHeight * o : void 0 }, n) } function yw(e) { var n; e.sort((r, o) => r.screenMaxWidth - o.screenMaxWidth); let t = null; for (let r = e.length - 1; r >= 0; r--) { const o = e[r]; o.media === t && e.splice(r, 1), t = o.media } for (let r = 0; r < e.length; r++)e[r].media = ((n = e[r + 1]) == null ? void 0 : n.media) || "" } function bw(e) { e.sort((n, r) => n.width - r.width); let t = null; for (let n = e.length - 1; n >= 0; n--) { const r = e[n]; r.width === t && e.splice(n, 1), t = r.width } } const vw = aw({ keyMap: { format: "f", fit: "fit", width: "w", height: "h", resize: "s", quality: "q", background: "b" }, joinWith: "&", formatter: (e, t) => Xl(e) + "_" + Xl(t) }), ww = (e, { modifiers: t = {}, baseURL: n } = {}, r) => { t.width && t.height && (t.resize = `${t.width}x${t.height}`, delete t.width, delete t.height); const o = vw(t) || "_"; return n || (n = Jt(r.options.nuxt.baseURL, "/_ipx")), { url: Jt(n, o, Pu(e)) } }, xw = !0, _w = !0, Sw = Object.freeze(Object.defineProperty({ __proto__: null, getImage: ww, supportsAlias: _w, validateDomains: xw }, Symbol.toStringTag, { value: "Module" })), fd = { screens: { xs: 320, sm: 640, md: 768, lg: 1024, xl: 1280, xxl: 1536, "2xl": 1536 }, presets: {}, provider: "ipxStatic", domains: [], alias: {}, densities: [1, 2], format: ["webp"] }; fd.providers = { ipxStatic: { provider: Sw, defaults: {} } }; const dd = () => { const e = Zt(), t = he(); return t.$img || t._img || (t._img = dw({ ...fd, nuxt: { baseURL: e.app.baseURL }, runtimeConfig: e })) }; function Cw(e) { var t; (t = performance == null ? void 0 : performance.mark) == null || t.call(performance, "mark_feature_usage", { detail: { feature: e } }) } const kw = { src: { type: String, required: !1 }, format: { type: String, required: !1 }, quality: { type: [Number, String], required: !1 }, background: { type: String, required: !1 }, fit: { type: String, required: !1 }, modifiers: { type: Object, required: !1 }, preset: { type: String, required: !1 }, provider: { type: String, required: !1 }, sizes: { type: [Object, String], required: !1 }, densities: { type: String, required: !1 }, preload: { type: [Boolean, Object], required: !1 }, width: { type: [String, Number], required: !1 }, height: { type: [String, Number], required: !1 }, alt: { type: String, required: !1 }, referrerpolicy: { type: String, required: !1 }, usemap: { type: String, required: !1 }, longdesc: { type: String, required: !1 }, ismap: { type: Boolean, required: !1 }, loading: { type: String, required: !1, validator: e => ["lazy", "eager"].includes(e) }, crossorigin: { type: [Boolean, String], required: !1, validator: e => ["anonymous", "use-credentials", "", !0, !1].includes(e) }, decoding: { type: String, required: !1, validator: e => ["async", "auto", "sync"].includes(e) }, nonce: { type: [String], required: !1 } }, Ew = e => { const t = R(() => ({ provider: e.provider, preset: e.preset })), n = R(() => ({ width: wt(e.width), height: wt(e.height), alt: e.alt, referrerpolicy: e.referrerpolicy, usemap: e.usemap, longdesc: e.longdesc, ismap: e.ismap, crossorigin: e.crossorigin === !0 ? "anonymous" : e.crossorigin || void 0, loading: e.loading, decoding: e.decoding, nonce: e.nonce })), r = dd(), o = R(() => ({ ...e.modifiers, width: wt(e.width), height: wt(e.height), format: e.format, quality: e.quality || r.options.quality, background: e.background, fit: e.fit })); return { options: t, attrs: n, modifiers: o } }, Tw = { ...kw, placeholder: { type: [Boolean, String, Number, Array], required: !1 }, placeholderClass: { type: String, required: !1 }, custom: { type: Boolean, required: !1 } }, Aw = ["src"], Pw = ce({ __name: "NuxtImg", props: Tw, emits: ["load", "error"], setup(e, { emit: t }) { const n = e, r = Vc(), o = t, s = !1, i = dd(), l = Ew(n), a = G(!1), u = G(), c = R(() => i.getSizes(n.src, { ...l.options.value, sizes: n.sizes, densities: n.densities, modifiers: { ...l.modifiers.value, width: wt(n.width), height: wt(n.height) } })), f = R(() => { const _ = { ...l.attrs.value, "data-nuxt-img": "" }; return (!n.placeholder || a.value) && (_.sizes = c.value.sizes, _.srcset = c.value.srcset), _ }), d = R(() => { let _ = n.placeholder; if (_ === "" && (_ = !0), !_ || a.value) return !1; if (typeof _ == "string") return _; const C = Array.isArray(_) ? _ : typeof _ == "number" ? [_, _] : [10, 10]; return i(n.src, { ...l.modifiers.value, width: C[0], height: C[1], quality: C[2] || 50, blur: C[3] || 3 }, l.options.value) }), h = R(() => n.sizes ? c.value.src : i(n.src, l.modifiers.value, l.options.value)), g = R(() => d.value ? d.value : h.value), b = he().isHydrating; return Te(() => { if (d.value || n.custom) { const _ = new Image; h.value && (_.src = h.value), n.sizes && (_.sizes = c.value.sizes || "", _.srcset = c.value.srcset), _.onload = C => { a.value = !0, o("load", C) }, _.onerror = C => { o("error", C) }, Cw("nuxt-image"); return } u.value && (u.value.complete && b && (u.value.getAttribute("data-error") ? o("error", new Event("error")) : o("load", new Event("load"))), u.value.onload = _ => { o("load", _) }, u.value.onerror = _ => { o("error", _) }) }), (_, C) => _.custom ? Xe(_.$slots, "default", ur(ot({ key: 1 }, { ...we(s) ? { onerror: "this.setAttribute('data-error', 1)" } : {}, imgAttrs: { ...f.value, ...we(r) }, isLoaded: a.value, src: g.value }))) : (se(), Fe("img", ot({ key: 0, ref_key: "imgEl", ref: u, class: d.value && !a.value ? _.placeholderClass : void 0 }, { ...we(s) ? { onerror: "this.setAttribute('data-error', 1)" } : {}, ...f.value, ...we(r) }, { src: g.value }), null, 16, Aw)) } }), $w = Symbol.for("nuxt:client-only"), Ow = ce({ name: "ClientOnly", inheritAttrs: !1, props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"], setup(e, { slots: t, attrs: n }) { const r = G(!1); return Te(() => { r.value = !0 }), Me($w, !0), o => { var a; if (r.value) return (a = t.default) == null ? void 0 : a.call(t); const s = t.fallback || t.placeholder; if (s) return s(); const i = o.fallback || o.placeholder || "", l = o.fallbackTag || o.placeholderTag || "span"; return Fe(l, n, i) } } }), Es = Pr(pt.ui.strategy, pt.ui.accordion, Hv), Iw = Pr(pt.ui.strategy, pt.ui.button, Nf), Lw = ce({ components: { HDisclosure: H1, HDisclosureButton: D1, HDisclosurePanel: U1, UIcon: Ko, UButton: rl }, inheritAttrs: !1, props: { items: { type: Array, default: () => [] }, defaultOpen: { type: Boolean, default: !1 }, openIcon: { type: String, default: () => Es.default.openIcon }, unmount: { type: Boolean, default: !1 }, closeIcon: { type: String, default: () => Es.default.closeIcon }, multiple: { type: Boolean, default: !1 }, class: { type: [String, Object, Array], default: () => "" }, ui: { type: Object, default: () => ({}) } }, emits: ["open", "close"], setup(e, { emit: t }) { const { ui: n, attrs: r } = nl("accordion", yn(e, "ui"), Es, yn(e, "class")), o = R(() => Iw), s = G([]), i = R(() => s.value.map(({ open: d }) => d)); We(i, (d, h) => { for (const g in d) { const p = h[g], b = d[g]; !p && b ? t("open", g) : p && !b && t("close", g) } }, { immediate: !0 }); function l(d, h) { !e.items[d].closeOthers && e.multiple || s.value.forEach(g => { g.open && g.close(h.target) }) } function a(d, h) { const g = d; g.style.height = "0", g.offsetHeight, g.style.height = g.scrollHeight + "px", g.addEventListener("transitionend", h, { once: !0 }) } function u(d) { const h = d; h.style.height = h.scrollHeight + "px", h.offsetHeight } function c(d) { const h = d; h.style.height = "auto" } function f(d, h) { const g = d; g.style.height = "0", g.addEventListener("transitionend", h, { once: !0 }) } return Hf(() => Mi()), { ui: n, uiButton: o, attrs: r, buttonRefs: s, closeOthers: l, omit: pf, onEnter: a, onBeforeLeave: u, onAfterEnter: c, onLeave: f } } }), Mw = { key: 1 }; function Rw(e, t, n, r, o, s) { const i = Ko, l = rl, a = It("HDisclosureButton"), u = It("HDisclosurePanel"), c = It("HDisclosure"); return se(), Fe("div", { class: $e(e.ui.wrapper) }, [(se(!0), Fe(ke, null, ho(e.items, (f, d) => (se(), Ce(c, { key: d, as: "div", class: $e(e.ui.container), "default-open": e.defaultOpen || f.defaultOpen }, { default: X(({ open: h, close: g }) => [z(a, { ref_for: !0, ref: () => e.buttonRefs[d] = { open: h, close: g }, as: "template", disabled: f.disabled, onClick: p => e.closeOthers(d, p), onKeydown: [Ql(p => e.closeOthers(d, p), ["enter"]), Ql(p => e.closeOthers(d, p), ["space"])] }, { default: X(() => [Xe(e.$slots, "default", { item: f, index: d, open: h, close: g }, () => [z(l, ot({ ref_for: !0 }, { ...e.omit(e.ui.default, ["openIcon", "closeIcon"]), ...e.attrs, ...e.omit(f, ["slot", "disabled", "content", "defaultOpen"]) }), { trailing: X(() => [z(i, { name: h && e.closeIcon ? e.closeIcon : e.openIcon, class: $e([h && !e.closeIcon ? "-rotate-180" : "", e.uiButton.icon.size[f.size || e.uiButton.default.size], e.ui.item.icon]) }, null, 8, ["name", "class"])]), _: 2 }, 1040)])]), _: 2 }, 1032, ["disabled", "onClick", "onKeydown"]), z(vh, ot({ ref_for: !0 }, e.ui.transition, { onEnter: e.onEnter, onAfterEnter: e.onAfterEnter, onBeforeLeave: e.onBeforeLeave, onLeave: e.onLeave }), { default: X(() => [e.unmount ? (se(), Ce(u, { key: 0, class: $e([e.ui.item.base, e.ui.item.size, e.ui.item.color, e.ui.item.padding]), unmount: "" }, { default: X(() => [Xe(e.$slots, f.slot || "item", { item: f, index: d, open: h, close: g }, () => [ne(Ot(f.content), 1)])]), _: 2 }, 1032, ["class"])) : ip((se(), Fe("div", Mw, [z(u, { class: $e([e.ui.item.base, e.ui.item.size, e.ui.item.color, e.ui.item.padding]), static: "" }, { default: X(() => [Xe(e.$slots, f.slot || "item", { item: f, index: d, open: h, close: g }, () => [ne(Ot(f.content), 1)])]), _: 2 }, 1032, ["class"])], 512)), [[kh, h]])]), _: 2 }, 1040, ["onEnter", "onAfterEnter", "onBeforeLeave", "onLeave"])]), _: 2 }, 1032, ["class", "default-open"]))), 128))], 2) } const jw = en(Lw, [["render", Rw]]), Nw = ce({ __name: "IconButton", props: { to: {} }, setup(e) { return (t, n) => { const r = Or; return se(), Ce(r, { class: "bg-primary flex h-[40px] w-[40px] shrink-0 items-center justify-center rounded-[10px] transition-opacity hover:opacity-70", to: t.to }, { default: X(() => [Xe(t.$slots, "default")]), _: 3 }, 8, ["to"]) } } }), Fw = {}, Bw = { class: "bg-[#2e2e2e] py-10 sm:py-8" }, Hw = { class: "flex gap-x-5" }; function Dw(e, t) { const n = Nw, r = ol; return se(), Fe("footer", Bw, [z(r, { class: "flex flex-col items-center justify-between gap-y-5 text-center sm:flex-row" }, { default: X(() => [t[2] || (t[2] = m("p", null, "© 2021 Launch Club. Все права защищены.", -1)), m("div", Hw, [z(n, { to: "https://www.instagram.com/artem_tudorov?igsh=bjcwczZsYzdtb2pq&utm_source=qr", target: "_blank" }, { default: X(() => t[0] || (t[0] = [m("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M15.3293 5.85177C14.6671 5.85306 14.1286 5.31684 14.1273 4.65457C14.126 3.9923 14.6622 3.45381 15.3248 3.45251C15.9874 3.45122 16.5259 3.98776 16.5272 4.65003C16.5281 5.3123 15.9919 5.85047 15.3293 5.85177Z", fill: "white" }), m("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M10.0096 15.1342C7.17424 15.1397 4.87092 12.8457 4.86542 10.0097C4.8599 7.17436 7.15446 4.87068 9.98981 4.86517C12.8258 4.85966 15.1294 7.15492 15.1349 9.98996C15.1404 12.826 12.8452 15.1287 10.0096 15.1342ZM9.99337 6.66696C8.15304 6.6702 6.66328 8.16548 6.66652 10.0062C6.67009 11.8472 8.16568 13.3366 10.006 13.333C11.847 13.3295 13.3367 11.8345 13.3332 9.99352C13.3296 8.15252 11.834 6.6634 9.99337 6.66696Z", fill: "white" }), m("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M3.43267 0.538732C4.06772 0.289896 4.79445 0.119468 5.85846 0.0692485C6.92509 0.0180605 7.2656 0.00639252 9.98073 0.00121052C12.6965 -0.00397148 13.037 0.00639051 14.1036 0.0536945C15.168 0.0997025 15.895 0.267541 16.5314 0.513786C17.1897 0.767478 17.7483 1.10898 18.305 1.66336C18.8616 2.21837 19.2044 2.77502 19.4613 3.43242C19.7098 4.06812 19.8802 4.79421 19.9308 5.8589C19.9813 6.92519 19.9936 7.26539 19.9988 9.98088C20.004 12.696 19.993 13.0369 19.9463 14.1042C19.9 15.1679 19.7325 15.8953 19.4863 16.5313C19.2319 17.1897 18.8911 17.7482 18.3367 18.3049C17.7823 18.8619 17.2251 19.2043 16.5677 19.4616C15.932 19.7098 15.2059 19.8802 14.1419 19.9311C13.0753 19.9816 12.7347 19.9936 10.0186 19.9988C7.30383 20.004 6.96332 19.9936 5.89671 19.9466C4.83235 19.9 4.10498 19.7325 3.46896 19.4865C2.8106 19.2319 2.25202 18.8913 1.69538 18.3366C1.13843 17.7819 0.795321 17.225 0.538715 16.5676C0.289881 15.9322 0.120089 15.2058 0.0692272 14.1421C0.0183632 13.0751 0.00637922 12.7343 0.00119922 10.0191C-0.00400078 7.30363 0.00669722 6.96343 0.0533472 5.8968C0.100333 4.83212 0.267197 4.10505 0.513441 3.46838C0.767773 2.81033 1.10862 2.25207 1.66364 1.69511C2.218 1.13847 2.77527 0.795015 3.43267 0.538732ZM4.11795 17.8066C4.47078 17.9423 5.00019 18.1043 5.97512 18.1468C7.03006 18.1925 7.34595 18.2025 10.0154 18.1973C12.6858 18.1924 13.0017 18.1811 14.0563 18.1315C15.0303 18.0852 15.5597 17.9213 15.9116 17.7839C16.3785 17.6015 16.7109 17.3834 17.0601 17.0338C17.4094 16.6829 17.6255 16.3495 17.8063 15.8826C17.9424 15.5295 18.1041 14.9997 18.1465 14.0248C18.1928 12.9705 18.2026 12.6542 18.1974 9.98412C18.1925 7.31464 18.1812 6.99842 18.131 5.94378C18.0849 4.96949 17.9213 4.44007 17.7836 4.08853C17.6012 3.62099 17.3838 3.28921 17.0333 2.93961C16.6827 2.59 16.3493 2.37454 15.8818 2.19375C15.5295 2.05734 14.9995 1.89598 14.0252 1.85355C12.9703 1.80721 12.654 1.79781 9.98397 1.803C7.31452 1.80818 6.99863 1.81887 5.94401 1.86877C4.96942 1.9151 4.44064 2.07872 4.08812 2.21643C3.62156 2.39884 3.28914 2.6156 2.93955 2.9665C2.59059 3.31739 2.37448 3.65015 2.1937 4.11801C2.05827 4.47053 1.89529 5.0006 1.8535 5.97489C1.80748 7.02984 1.79777 7.34608 1.80296 10.0155C1.80782 12.6857 1.81915 13.0019 1.86873 14.0559C1.91441 15.0308 2.07932 15.5596 2.21638 15.9124C2.39879 16.3787 2.6162 16.7111 2.96644 17.0607C3.31734 17.409 3.65073 17.6258 4.11795 17.8066Z", fill: "white" })], -1)])), _: 1 }), z(n, { to: "https://t.me/artem_tudorov", target: "_blank" }, { default: X(() => t[1] || (t[1] = [m("svg", { width: "18", height: "15", viewBox: "0 0 18 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M1.23741 6.42177C6.06923 4.31661 9.29121 2.92875 10.9033 2.25821C15.5063 0.343674 16.4627 0.0110989 17.0861 0.000117091C17.2232 -0.00229824 17.5298 0.0316822 17.7284 0.19282C17.8961 0.328882 17.9422 0.512682 17.9643 0.641684C17.9864 0.770686 18.0139 1.06455 17.992 1.29418C17.7426 3.91503 16.6633 10.2751 16.1142 13.2105C15.8818 14.4526 15.4244 14.8691 14.9815 14.9098C14.0189 14.9984 13.288 14.2737 12.3558 13.6626C10.897 12.7064 10.0729 12.1111 8.65691 11.178C7.02048 10.0996 8.08131 9.50689 9.0139 8.53825C9.25797 8.28475 13.4988 4.42732 13.5809 4.07739C13.5912 4.03363 13.6007 3.87049 13.5038 3.78435C13.4069 3.69821 13.2639 3.72767 13.1606 3.75109C13.0143 3.7843 10.6839 5.32463 6.16938 8.37209C5.5079 8.82632 4.90875 9.04763 4.37193 9.03603C3.78013 9.02325 2.64175 8.70142 1.79548 8.42633C0.757494 8.08892 -0.0674757 7.91053 0.00436067 7.3375C0.0417775 7.03903 0.452793 6.73379 1.23741 6.42177Z", fill: "white" })], -1)])), _: 1 })])]), _: 1 })]) } const Uw = en(Fw, [["render", Dw]]), zw = Tr("/static/images/landing/team/man.png"), qw = Tr("/static/images/landing/team/2.png"), Ww = Tr("/static/images/landing/team/3.png"), Vw = { class: "flex flex-col" }, Gw = { class: "py-6 sm:py-20" }, Kw = { class: "grid items-center gap-x-5 gap-y-[60px] lg:grid-cols-12" }, Jw = { class: "mx-auto flex flex-col items-center gap-y-10 text-center sm:gap-y-[60px] lg:col-span-4 lg:items-stretch lg:text-left" }, Zw = { class: "flex flex-col gap-5 sm:flex-row lg:flex-col" }, Qw = { class: "pointer-events-none relative mx-auto flex w-[90%] select-none sm:w-[70%] lg:col-span-8 lg:mx-0 lg:w-auto lg:justify-self-end" }, Yw = { class: "overflow-hidden pb-14 pt-12", id: "chto-takoe-ido" }, Xw = { class: "relative flex flex-col gap-y-10 sm:gap-y-[60px] lg:gap-y-24" }, ex = { class: "flex flex-col gap-y-20" }, tx = { class: "grid items-center gap-x-5 gap-y-20 md:grid-cols-12" }, nx = { class: "pointer-events-none relative mx-auto w-[60%] select-none md:w-auto md:justify-self-end md:[grid-area:1/8/2/13] lg:mx-0" }, rx = { class: "overflow-hidden pb-14 pt-12" }, ox = { class: "relative flex flex-col gap-y-10 sm:gap-y-[60px] lg:gap-y-24" }, sx = { class: "grid items-center gap-x-5 gap-y-20 md:grid-cols-12" }, ix = { class: "pointer-events-none relative mx-auto w-[60%] select-none md:col-span-5 md:w-auto md:justify-self-end lg:mx-0" }, lx = { class: "overflow-hidden pb-14 pt-12", id: "kak-eto-rabotaet" }, ax = { class: "overflow-hidden pb-14 pt-12", id: "pochemu-sobirayutsya-puly" }, cx = { class: "relative flex flex-col gap-y-10 sm:gap-y-[60px] lg:gap-y-24" }, ux = { class: "flex flex-col gap-y-20" }, fx = { class: "grid items-center gap-x-5 gap-y-20 md:grid-cols-12" }, dx = { class: "pointer-events-none relative mx-auto w-[60%] select-none md:w-auto md:justify-self-end md:[grid-area:1/8/2/13] lg:mx-0" }, px = { class: "overflow-hidden pb-14 pt-12" }, hx = { class: "overflow-hidden pb-14 pt-12", id: "nasha-komanda" }, gx = { class: "pb-14 pt-12" }, mx = { class: "grid gap-x-5 gap-y-8 lg:grid-cols-12" }, yx = { class: "flex flex-col gap-y-8 lg:[grid-area:1/6/2/13]" }, bx = { class: "overflow-hidden pb-14 pt-12" }, vx = { class: "last:border-b [&>*]:border-t [&>*]:border-white [&>*]:py-6" }, wx = { class: "flex items-center justify-between gap-x-5 truncate text-lg font-semibold transition-opacity hover:opacity-70 sm:text-xl lg:text-2xl" }, xx = { class: "truncate" }, _x = { class: "flex h-10 w-10 shrink-0 items-center justify-center rounded-[10px] bg-[#2e2e2e]" }, Sx = ["innerHTML"], Cx = ce({ __name: "app", setup(e) { const t = [{ label: "Как происходит процесс участия в общем пуле?", content: "Участие в пуле начинается с резервирования места через администратора, после чего формируется список участников. За один час до начала токенсейла создается отдельный чат, куда добавляются все участники пула. Затем за 15-20 минут до начала запускается трансляция, которая позволяет каждому участнику наблюдать за процессом клейминга (приобретения) токенов и последующей их продажей на этапе листинга." }, { label: "Когда я получу прибыль?", content: "Как быстро мы получаем прибыль?<br><br>В большинстве случаев, мы участвовуем в IDO проектах со 100% разлоками (токены не замораживаются и их можно сразу продать на бирже), в этом случае вы получаете прибыль в течение нескольких часов после продажи токена на бирже.<br>(перед участием, по разлокам уточняйте у  администратора)" }, { label: "Что такое BNB и как его купить?", content: 'BNB — это криптовалюта, которая является одним из самых популярных токенов в мире занимая 4 место после Bitcoin, Ethereum и USDT. Большинство сейлов, в которых мы принимаем участие, находятся в сети Binance Smart Chain, поэтому вход осуществляется в валюте BNB.<br><br>Для покупки BNB, вам необходимо зарегистрироваться на любой бирже и пополнить ее, через систему P2P (с помощью банковской карты, либо любым другим способом).<br><br>Видео инструкция по регистрации популярной биржи Bybit – <a href="https://youtu.be/1LmmNL6xHZE" target="_blank">https://youtu.be/1LmmNL6xHZE</a><br><br>Видео инструкция по пополнению биржи Bybit, через P2P – <a href="https://youtu.be/ctnBB3BC43A" target="_blank">https://youtu.be/ctnBB3BC43A</a>' }, { label: "Какие гарантии мы предоставляем?", content: "От себя мы даем гарантию участия в том или ином сейле, гарантий 100% прибыли мы не даем, что логично. С подробными отчетами по каждому пулу можете ознакомиться в нашей телеграмм группе, в закрепленных сообщениях (там есть история выплат, с хешами транзакций и общая информация по каждому проекту)." }]; return Xm({ title: " Launch Pool - заработок на перспективных криптовалютных проектах", description: " Launch Pool - это современные пулы для приобретения токенов на децентрализованных биржах (DEX)" }), (n, r) => { const o = sw, s = Ff, i = Pw, l = ol, a = Ow, u = jw, c = Uw; return se(), Fe("div", null, [z(o), m("main", Vw, [m("section", Gw, [z(l, null, { default: X(() => [m("div", Kw, [m("div", Jw, [r[2] || (r[2] = m("div", { class: "flex max-w-[280px] flex-col gap-y-10 sm:max-w-lg sm:gap-y-[60px]" }, [m("h1", { class: "text-4xl font-semibold sm:text-6xl lg:text-8xl" }, [m("span", { class: "text-primary" }, "Launch "), ne("Pool ")]), m("p", { class: "sm:text-xl lg:text-2xl" }, [ne(" Заработок на "), m("span", { class: "text-primary" }, "перспективных"), ne(" криптовалютных проектах ")])], -1)), m("div", Zw, [z(s, { variant: "outline", to: "/#kak-eto-rabotaet" }, { default: X(() => r[0] || (r[0] = [ne(" Как это работает? ")])), _: 1 }), z(s, { to: "https://t.me/artem_tudorin", target: "_blank" }, { default: X(() => r[1] || (r[1] = [ne(" Принять участие ")])), _: 1 })])]), m("div", Qw, [r[3] || (r[3] = m("div", { class: "bg-primary/40 absolute left-[30%] top-[-2%] h-0 w-[70%] animate-pulse rounded-full pb-[70%] blur-3xl" }, null, -1)), z(i, { class: "relative", src: "/static/images/landing/hero.png", alt: " Launch Pool", width: "710", height: "599", loading: "lazy", fit: "inside" })])])]), _: 1 })]), m("section", Yw, [z(l, { class: "relative" }, { default: X(() => [r[8] || (r[8] = m("div", { class: "bg-primary/20 absolute left-0 top-[12rem] h-[18rem] w-[18rem] rounded-full blur-3xl" }, null, -1)), m("div", Xw, [r[7] || (r[7] = m("div", null, [m("span", { class: "select-none whitespace-nowrap text-7xl font-semibold text-[#2e2e2e] sm:text-8xl" }, " Что такое IDO "), m("h2", { class: "-mt-10 text-3xl font-semibold leading-tight sm:-mt-12 sm:text-4xl" }, [m("span", { class: "text-primary" }, "Что такое"), ne(" IDO ")])], -1)), m("div", ex, [m("div", tx, [r[5] || (r[5] = m("div", { class: "flex flex-col gap-y-8 md:[grid-area:1/1/2/7]" }, [m("p", { class: "font-semibold sm:text-xl lg:text-2xl" }, [m("span", { class: "text-primary" }, "IDO"), ne(" - это процесс ранней продажи токенов новых криптопроектов на децентралиованных биржах (DEX) ")]), m("p", { class: "sm:text-lg lg:text-xl" }, " Этот метод позволяет купить токен во время запуска проекта, что открывает хорошие перспективы для заработка. Это похоже на первичное размещение акций (IPO), только в сфере криптовалют. "), m("p", { class: "sm:text-lg lg:text-xl" }, " Многие компании, которые хотят масштабироваться, используют метод Initial DEX Offering (IDO). Разработчики проекта заключают сделку с площадками (лаунчпадами), которые проводят публичную продажу их токена. Если IDO проходит успешно, токен проекта начинает расти, и инвесторы зарабатывают на этом. ")], -1)), m("div", nx, [r[4] || (r[4] = m("div", { class: "bg-primary/40 absolute top-[-10%] h-0 w-full animate-pulse rounded-full pb-[100%] blur-3xl" }, null, -1)), z(i, { class: "relative", src: "/static/images/landing/clock.png", alt: "Что такое IDO", width: "412", height: "411", loading: "lazy", fit: "inside" })])]), r[6] || (r[6] = m("div", { class: "border-primary rounded-[30px] border-2 bg-[#2e2e2e] p-8 text-center sm:px-16 sm:text-lg lg:px-24 lg:py-12 lg:text-xl" }, " Например, токен SOLANA был продан на IDO по цене 0.22$. Однако через некоторое время его стоимость выросла в 1100 раз и его можно было продать по цене 250$. Таким образом, вложив 1000$, можно было заработать более 1 млн$. ", -1))])])]), _: 1 })]), m("section", rx, [z(l, { class: "relative" }, { default: X(() => [r[12] || (r[12] = m("div", { class: "bg-primary/30 absolute left-[-6rem] top-[12rem] h-[20rem] w-[20rem] rounded-full blur-3xl" }, null, -1)), m("div", ox, [r[11] || (r[11] = m("div", null, [m("span", { class: "select-none whitespace-nowrap text-7xl font-semibold text-[#2e2e2e] sm:text-8xl" }, " Наша задача "), m("h2", { class: "-mt-10 text-3xl font-semibold leading-tight sm:-mt-12 sm:text-4xl" }, [ne(" Наша "), m("span", { class: "text-primary" }, "задача")])], -1)), m("div", sx, [r[10] || (r[10] = m("div", { class: "flex flex-col gap-y-[60px] md:col-span-7" }, [m("div", { class: "flex flex-col gap-y-8" }, [m("p", { class: "text-lg font-semibold leading-snug sm:text-2xl lg:text-3xl" }, [m("span", { class: "text-primary" }, " Поиск наиболее перспективных токенсейлов, которые могут принести высокую прибыль "), ne(" для участников наших пулов ")]), m("p", { class: "max-w-[534px] sm:text-xl lg:text-2xl" }, " Для этого мы анализируем сотни проектов ежемесячно и выбираем самые лучшие из них ")]), m("div", { class: "flex flex-col gap-y-8" }, [m("p", { class: "text-lg font-semibold leading-snug sm:text-2xl lg:text-3xl" }, [m("span", { class: "text-primary" }, " Мы не покупаем неизвестные или непроверенные токены ")]), m("p", { class: "max-w-[534px] sm:text-xl lg:text-2xl" }, " Все проекты проходят детальный анализ и проверку ")])], -1)), m("div", ix, [r[9] || (r[9] = m("div", { class: "bg-primary/40 absolute left-[5%] top-[-10%] h-0 w-[90%] animate-pulse rounded-full pb-[90%] blur-3xl" }, null, -1)), z(i, { class: "relative", src: "/static/images/landing/list.png", alt: "Наша задача", width: "396", height: "407", loading: "lazy", fit: "inside" })])])])]), _: 1 })]), m("section", lx, [z(l, { class: "relative" }, { default: X(() => r[13] || (r[13] = [m("div", { class: "bg-primary/10 absolute bottom-[10%] left-[40%] h-0 w-[30%] -translate-x-1/2 rounded-full pb-[30%] blur-3xl" }, null, -1), m("div", { class: "relative flex flex-col gap-y-10 sm:gap-y-[60px] lg:gap-y-24" }, [m("div", null, [m("span", { class: "select-none whitespace-nowrap text-7xl font-semibold text-[#2e2e2e] sm:text-8xl" }, " Как это работает "), m("h2", { class: "-mt-10 text-3xl font-semibold leading-tight sm:-mt-12 sm:text-4xl" }, [m("span", { class: "text-primary" }, "Как это"), ne(" работает ")])]), m("div", { class: "grid gap-5 lg:grid-cols-2" }, [m("div", { class: "flex gap-x-6 rounded-[30px] bg-[#2e2e2e] p-6 sm:gap-x-8 sm:p-8" }, [m("div", null, [m("div", { class: "bg-primary flex h-10 w-10 items-center justify-center rounded-[10px] text-xl font-semibold text-[#242424]" }, " 1 ")]), m("p", { class: "sm:text-lg lg:text-xl" }, " Допустим, аллокация проекта, выделенная для нашего сообщества, составляет 50 BNB (~15000$). Мы привлекаем участников, которые вносят в общий пул от 0.5 BNB до 1 BNB. ")]), m("div", { class: "flex gap-x-6 rounded-[30px] bg-[#2e2e2e] p-6 sm:gap-x-8 sm:p-8" }, [m("div", null, [m("div", { class: "bg-primary flex h-10 w-10 items-center justify-center rounded-[10px] text-xl font-semibold text-[#242424]" }, " 2 ")]), m("p", { class: "sm:text-lg lg:text-xl" }, " Таким образом, у каждого из них открывается возможность поучаствовать в проверенном и перспективном токенсейле, при этом соблюсти риск-менеджмент. ")]), m("div", { class: "flex gap-x-6 rounded-[30px] bg-[#2e2e2e] p-6 sm:gap-x-8 sm:p-8" }, [m("div", null, [m("div", { class: "bg-primary flex h-10 w-10 items-center justify-center rounded-[10px] text-xl font-semibold text-[#242424]" }, " 3 ")]), m("p", { class: "sm:text-lg lg:text-xl" }, " После успешного проведения IDO, токен проекта начинает расти, в этот момент мы продаем его и фиксируем основную прибыль. ")]), m("div", { class: "flex gap-x-6 rounded-[30px] bg-[#2e2e2e] p-6 sm:gap-x-8 sm:p-8" }, [m("div", null, [m("div", { class: "bg-primary flex h-10 w-10 items-center justify-center rounded-[10px] text-xl font-semibold text-[#242424]" }, " 4 ")]), m("p", { class: "sm:text-lg lg:text-xl" }, " Итоговая прибыль делится между всеми участниками пула пропорционально их вложениям. ")])])], -1)])), _: 1 })]), m("section", ax, [z(l, { class: "relative" }, { default: X(() => [r[18] || (r[18] = m("div", { class: "bg-primary/30 absolute left-[-10rem] top-[28rem] h-[20rem] w-[20rem] rounded-full blur-3xl" }, null, -1)), m("div", cx, [r[17] || (r[17] = m("div", null, [m("span", { class: "select-none whitespace-nowrap text-7xl font-semibold text-[#2e2e2e] sm:text-8xl" }, " Для чего собираются пулы "), m("h2", { class: "-mt-10 text-3xl font-semibold leading-tight sm:-mt-12 sm:text-4xl" }, [m("span", { class: "text-primary" }, "Для чего"), ne(" собираются пулы ")])], -1)), m("div", ux, [m("div", fx, [r[15] || (r[15] = m("div", { class: "flex flex-col gap-y-8 md:[grid-area:1/1/2/7]" }, [m("p", { class: "sm:text-lg lg:text-xl" }, [m("span", { class: "text-primary font-semibold" }, " Для того, чтобы участвовать в IDO проекта необходимо получить аллокацию (так называемый White List)"), ne(", которая позволяет приобрести токены этого проекта по самой низкой стоимости. Однако, сделать это может быть достаточно трудно, так как для этого нужно выполнить различные задания, направленные на улучшение проекта и увеличение интереса к нему. Кроме того, количество мест в White List ограничено, что создает конкуренцию среди участников. ")]), m("p", { class: "sm:text-lg lg:text-xl" }, " Именно по этой причине создаются пулы, которые позволяют вам приобретать токены проекта вместе с другими участниками. При этом, для каждого пула мы получаем выделенную аллокацию, напрямую от разработчиков, поэтому для участия не обязательно иметь свой собственный White List. ")], -1)), m("div", dx, [r[14] || (r[14] = m("div", { class: "bg-primary/40 absolute left-[15%] top-[-10%] h-0 w-[80%] animate-pulse rounded-full pb-[80%] blur-3xl" }, null, -1)), z(i, { class: "relative", src: "/static/images/landing/chest.png", alt: "Почему собираются пулы", width: "480", height: "368", loading: "lazy", fit: "inside" })])]), r[16] || (r[16] = m("div", { class: "border-primary rounded-[30px] border-2 bg-[#2e2e2e] p-8 text-center sm:px-16 sm:text-lg lg:px-24 lg:py-12 lg:text-xl" }, " Основным преимуществом участия в пуле является распределение рисков между всеми участниками, что позволяет соблюдать риск-менеджмент. Если проект окажется убыточным, то участники пула разделят этот риск, и потери для каждого из них будут не такими значительными, как если бы они инвестировали в проект самостоятельно. ", -1))])])]), _: 1 })]), m("section", px, [z(l, { class: "relative" }, { default: X(() => r[19] || (r[19] = [m("div", { class: "bg-primary/20 absolute left-[13%] top-[20%] h-0 w-[25%] rounded-full pb-[25%] blur-3xl" }, null, -1), m("div", { class: "bg-primary/20 absolute bottom-[5%] right-[-3%] h-0 w-[25%] rounded-full pb-[25%] blur-3xl" }, null, -1), m("div", { class: "relative flex flex-col gap-y-10 sm:gap-y-[60px]" }, [m("div", { class: "grid gap-y-5 xl:grid-cols-12" }, [m("h2", { class: "text-3xl font-semibold leading-tight sm:text-4xl xl:-my-2 xl:[grid-area:1/1/2/7]" }, [m("span", { class: "text-primary" }, "Пример расчета прибыли"), ne(" между участниками пула ")]), m("p", { class: "xl:text-right xl:[grid-area:1/8/2/13]" }, [ne(" Каждый участник получается прибыль "), m("br"), ne(" пропорционально своей доле. "), m("span", { class: "text-primary" }, " Прибыль рассчитана с учетом нашей комиссии - 10% ")])]), m("div", { class: "grid gap-x-5 gap-y-10 xl:grid-cols-12" }, [m("div", { class: "flex flex-col gap-5 lg:flex-row xl:col-span-4 xl:flex-col" }, [m("div", { class: "grid w-full gap-x-5 xl:w-auto xl:grid-cols-4" }, [m("div", { class: "flex items-center justify-center gap-x-8 rounded-[30px] bg-[#2e2e2e] px-5 py-8 xl:col-span-3 xl:justify-start" }, [m("svg", { width: "44", height: "50", viewBox: "0 0 44 50", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M42 47.5C42 40.5964 33.0457 35 22 35C10.9543 35 2 40.5964 2 47.5M22 27.5C15.0964 27.5 9.5 21.9036 9.5 15C9.5 8.09644 15.0964 2.5 22 2.5C28.9036 2.5 34.5 8.09644 34.5 15C34.5 21.9036 28.9036 27.5 22 27.5Z", stroke: "#348F4D", "stroke-width": "4", "stroke-linecap": "round", "stroke-linejoin": "round" })]), m("p", { class: "font-semibold sm:text-lg" }, [ne(" Участник 1 "), m("br"), ne(" вносит "), m("span", { class: "text-primary" }, "0.5 BNB")])]), m("div", { class: "col-span-1 hidden items-center justify-center xl:flex" }, [m("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M21 12L16 7M21 12L16 17M21 12H3", stroke: "white", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })])])]), m("div", { class: "grid w-full gap-x-5 xl:w-auto xl:grid-cols-4" }, [m("div", { class: "flex items-center justify-center gap-x-8 rounded-[30px] bg-[#2e2e2e] px-5 py-8 xl:col-span-3 xl:justify-start" }, [m("svg", { width: "44", height: "50", viewBox: "0 0 44 50", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M42 47.5C42 40.5964 33.0457 35 22 35C10.9543 35 2 40.5964 2 47.5M22 27.5C15.0964 27.5 9.5 21.9036 9.5 15C9.5 8.09644 15.0964 2.5 22 2.5C28.9036 2.5 34.5 8.09644 34.5 15C34.5 21.9036 28.9036 27.5 22 27.5Z", stroke: "#348F4D", "stroke-width": "4", "stroke-linecap": "round", "stroke-linejoin": "round" })]), m("p", { class: "font-semibold sm:text-lg" }, [ne(" Участник 2"), m("br"), ne("вносит "), m("span", { class: "text-primary" }, "1 BNB")])]), m("div", { class: "col-span-1 hidden items-center justify-center xl:flex" }, [m("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M21 12L16 7M21 12L16 17M21 12H3", stroke: "white", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })])])]), m("div", { class: "grid w-full gap-x-5 xl:w-auto xl:grid-cols-4" }, [m("div", { class: "flex items-center justify-center gap-x-8 rounded-[30px] bg-[#2e2e2e] px-5 py-8 xl:col-span-3 xl:justify-start" }, [m("svg", { width: "44", height: "50", viewBox: "0 0 44 50", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M42 47.5C42 40.5964 33.0457 35 22 35C10.9543 35 2 40.5964 2 47.5M22 27.5C15.0964 27.5 9.5 21.9036 9.5 15C9.5 8.09644 15.0964 2.5 22 2.5C28.9036 2.5 34.5 8.09644 34.5 15C34.5 21.9036 28.9036 27.5 22 27.5Z", stroke: "#348F4D", "stroke-width": "4", "stroke-linecap": "round", "stroke-linejoin": "round" })]), m("p", { class: "font-semibold sm:text-lg" }, [ne(" Участник 3"), m("br"), ne("вносит "), m("span", { class: "text-primary" }, "0.85 BNB")])]), m("div", { class: "col-span-1 hidden items-center justify-center xl:flex" }, [m("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M21 12L16 7M21 12L16 17M21 12H3", stroke: "white", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })])])])]), m("svg", { class: "mx-auto rotate-90 xl:hidden", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M21 12L16 7M21 12L16 17M21 12H3", stroke: "white", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })]), m("div", { class: "grid gap-x-5 xl:col-span-3 xl:grid-cols-3" }, [m("div", { class: "col-span-2 flex flex-col items-center justify-center gap-y-5 rounded-[30px] bg-[#2e2e2e] px-6 py-8" }, [m("svg", { width: "60", height: "60", viewBox: "0 0 60 60", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M42.5 50C42.5 45.8579 36.9036 42.5 30 42.5C23.0964 42.5 17.5 45.8579 17.5 50M52.5 42.5009C52.5 39.4255 49.4148 36.7823 45 35.625M7.5 42.5009C7.5 39.4255 10.5852 36.7823 15 35.625M45 25.5903C46.5344 24.217 47.5 22.2212 47.5 20C47.5 15.8579 44.1421 12.5 40 12.5C38.0791 12.5 36.3269 13.2221 35 14.4097M15 25.5903C13.4656 24.217 12.5 22.2212 12.5 20C12.5 15.8579 15.8579 12.5 20 12.5C21.9209 12.5 23.6731 13.2221 25 14.4097M30 35C25.8579 35 22.5 31.6421 22.5 27.5C22.5 23.3579 25.8579 20 30 20C34.1421 20 37.5 23.3579 37.5 27.5C37.5 31.6421 34.1421 35 30 35Z", stroke: "#348F4D", "stroke-width": "4", "stroke-linecap": "round", "stroke-linejoin": "round" })]), m("p", { class: "text-center font-semibold sm:text-lg" }, [ne(" Общий взнос в пул"), m("br"), m("span", { class: "text-primary text-lg sm:text-xl lg:text-2xl" }, " 2.35 BNB ")])]), m("div", { class: "col-span-1 hidden items-center justify-center xl:flex" }, [m("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M21 12L16 7M21 12L16 17M21 12H3", stroke: "white", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })])])]), m("svg", { class: "mx-auto rotate-90 xl:hidden", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M21 12L16 7M21 12L16 17M21 12H3", stroke: "white", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })]), m("div", { class: "flex flex-col items-center gap-y-12 rounded-[30px] bg-[#2e2e2e] px-5 py-8 xl:col-span-5 xl:items-stretch" }, [m("div", { class: "flex flex-col gap-y-5 text-center sm:text-lg xl:text-left" }, [m("p", null, [m("span", { class: "text-primary font-semibold" }, "Прибыль"), ne(" с продажи токенов: "), m("span", { class: "text-primary font-semibold" }, "х3.6 (360%)")]), m("p", null, [m("span", { class: "text-primary font-semibold" }, "Пул"), ne(" после продажи токена: "), m("span", { class: "text-primary font-semibold" }, "8.46 BNB")])]), m("div", { class: "flex h-full flex-col justify-between gap-y-10 xl:gap-y-0" }, [m("div", { class: "flex items-center gap-x-5" }, [m("svg", { class: "shrink-0", width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M33.3327 35C33.3327 30.3976 27.3631 26.6667 19.9993 26.6667C12.6356 26.6667 6.66602 30.3976 6.66602 35M19.9993 21.6667C15.397 21.6667 11.666 17.9357 11.666 13.3333C11.666 8.73096 15.397 5 19.9993 5C24.6017 5 28.3327 8.73096 28.3327 13.3333C28.3327 17.9357 24.6017 21.6667 19.9993 21.6667Z", stroke: "#348F4D", "stroke-width": "4", "stroke-linecap": "round", "stroke-linejoin": "round" })]), m("div", { class: "flex flex-col !leading-tight sm:text-lg" }, [m("p", { class: "font-semibold" }, "Участник 1"), m("p", null, [ne(" Доля участия 21.28%. "), m("span", { class: "text-primary font-semibold" }, " Прибыль 1.67 BNB ")])])]), m("div", { class: "flex items-center gap-x-5" }, [m("svg", { class: "shrink-0", width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M33.3327 35C33.3327 30.3976 27.3631 26.6667 19.9993 26.6667C12.6356 26.6667 6.66602 30.3976 6.66602 35M19.9993 21.6667C15.397 21.6667 11.666 17.9357 11.666 13.3333C11.666 8.73096 15.397 5 19.9993 5C24.6017 5 28.3327 8.73096 28.3327 13.3333C28.3327 17.9357 24.6017 21.6667 19.9993 21.6667Z", stroke: "#348F4D", "stroke-width": "4", "stroke-linecap": "round", "stroke-linejoin": "round" })]), m("div", { class: "flex flex-col !leading-tight sm:text-lg" }, [m("p", { class: "font-semibold" }, "Участник 2"), m("p", null, [ne(" Доля участия 42.55%. "), m("span", { class: "text-primary font-semibold" }, " Прибыль 3.34 BNB ")])])]), m("div", { class: "flex items-center gap-x-5" }, [m("svg", { class: "shrink-0", width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M33.3327 35C33.3327 30.3976 27.3631 26.6667 19.9993 26.6667C12.6356 26.6667 6.66602 30.3976 6.66602 35M19.9993 21.6667C15.397 21.6667 11.666 17.9357 11.666 13.3333C11.666 8.73096 15.397 5 19.9993 5C24.6017 5 28.3327 8.73096 28.3327 13.3333C28.3327 17.9357 24.6017 21.6667 19.9993 21.6667Z", stroke: "#348F4D", "stroke-width": "4", "stroke-linecap": "round", "stroke-linejoin": "round" })]), m("div", { class: "flex flex-col !leading-tight sm:text-lg" }, [m("p", { class: "font-semibold" }, "Участник 3"), m("p", null, [ne(" Доля участия 36.17%. "), m("span", { class: "text-primary font-semibold" }, " Прибыль 2.84 BNB ")])])])])])])], -1)])), _: 1 })]), m("section", hx, [z(l, { class: "relative" }, { default: X(() => r[20] || (r[20] = [m("div", { class: "bg-primary/40 absolute bottom-[20%] left-[-3%] h-0 w-[30%] rounded-full pb-[30%] blur-3xl" }, null, -1), m("div", { class: "bg-primary/40 absolute right-[-7%] top-[20%] h-0 w-[30%] animate-pulse rounded-full pb-[30%] blur-3xl" }, null, -1), m("div", { class: "relative flex flex-col gap-y-10 sm:gap-y-[60px] lg:gap-y-24" }, [m("div", null, [m("span", { class: "select-none whitespace-nowrap text-7xl font-semibold text-[#2e2e2e] sm:text-8xl" }, " Наша команда "), m("h2", { class: "-mt-10 text-3xl font-semibold leading-tight sm:-mt-12 sm:text-4xl" }, [ne(" Наша "), m("span", { class: "text-primary" }, "команда")])]), m("div", { class: "grid gap-x-5 gap-y-10 sm:grid-cols-2 lg:grid-cols-3" }, [m("div", null, [m("div", { class: "h-0 w-full images overflow-hidden rounded-[30px] pb-[100%] lg:h-auto lg:w-auto lg:pb-0" }, [m("img", { class: "min-h-full w-full", src: zw, alt: "Артём", width: "380", height: "420", loading: "lazy" })]), m("div", { class: "mt-6 leading-tight lg:mt-8" }, [m("div", { class: "text-lg font-semibold sm:text-2xl lg:text-3xl" }, " Артём Тудоров "), m("div", { class: "text-primary font-semibold sm:text-xl lg:text-2xl" }, " Founder ")]), m("p", { class: "mt-6 sm:text-lg lg:mt-10 lg:text-xl" }, [ne(" Основатель Launch Pool "), m("br"), ne(" Эксперт в области токенсейлов в различных областях, включая финансы, медиа и блокчейн-технологии ")])]), m("div", null, [m("div", { class: "h-0 w-full overflow-hidden rounded-[30px] pb-[100%] lg:h-auto lg:w-auto lg:pb-0" }, [m("img", { class: "min-h-full w-full", src: qw, alt: "Денис", width: "380", height: "420", loading: "lazy" })]), m("div", { class: "mt-6 leading-tight lg:mt-8" }, [m("div", { class: "text-lg font-semibold sm:text-2xl lg:text-3xl" }, " Денис Поляков "), m("div", { class: "text-primary font-semibold sm:text-xl lg:text-2xl" }, " Co-founder ")]), m("p", { class: "mt-6 sm:text-lg lg:mt-10 lg:text-xl" }, " Консультант по вопросам привлечения частных (крупных) инвестиций ")]), m("div", null, [m("div", { class: "h-0 w-full overflow-hidden rounded-[30px] pb-[100%] lg:h-auto lg:w-auto lg:pb-0" }, [m("img", { class: "min-h-full w-full", src: Ww, alt: "Марат", width: "380", height: "420", loading: "lazy" })]), m("div", { class: "mt-6 leading-tight lg:mt-8" }, [m("div", { class: "text-lg font-semibold sm:text-2xl lg:text-3xl" }, " Марат Алачев "), m("div", { class: "text-primary font-semibold sm:text-xl lg:text-2xl" }, " CEO ")]), m("p", { class: "mt-6 sm:text-lg lg:mt-10 lg:text-xl" }, " Предварительная аналитическая проверка и оценка персепективности проектов ")])])], -1)])), _: 1 })]), m("section", gx, [z(l, { class: "flex flex-col gap-y-10 sm:gap-y-[60px]" }, { default: X(() => [r[24] || (r[24] = m("h2", { class: "text-3xl font-semibold leading-tight sm:text-4xl" }, [m("span", { class: "text-primary" }, "Как пополнить"), ne(" баланс ")], -1)), m("div", mx, [r[23] || (r[23] = m("div", { class: "flex flex-col gap-y-8 lg:[grid-area:1/1/2/5]" }, [m("p", { class: "sm:text-lg lg:text-xl" }, " BNB — это криптовалюта, которая является одним из самых популярных токенов в мире занимая 4 место после Bitcoin, Ethereum и USDT. Большинство сейлов, в которых мы принимаем участие, находятся в сети Binance Smart Chain, поэтому вход осуществляется в валюте BNB. "), m("p", { class: "sm:text-lg lg:text-xl" }, " Для покупки BNB, вам необходимо зарегистрироваться на любой бирже и пополнить ее, через систему P2P (с помощью банковской карты, либо любым другим способом). "), m("p", { class: "sm:text-lg lg:text-xl" }, [ne(" Видео инструкция по регистрации популярной биржи Bybit – "), m("a", { class: "font-semibold transition-opacity hover:opacity-70", href: "https://youtu.be/1LmmNL6xHZE", target: "_blank" }, " https://youtu.be/1LmmNL6xHZE ")]), m("p", { class: "sm:text-lg lg:hidden lg:text-xl" }, [ne(" Видео инструкция по пополнению биржи Bybit, через P2P – "), m("a", { class: "font-semibold transition-opacity hover:opacity-70", href: "https://youtu.be/ctnBB3BC43A", target: "_blank" }, " https://youtu.be/ctnBB3BC43A ")])], -1)), m("div", yx, [z(a, null, { default: X(() => r[21] || (r[21] = [m("iframe", { class: "h-96 w-full rounded-[30px] lg:h-full", width: "560", height: "315", src: "https://www.youtube.com/embed/1LmmNL6xHZE", title: "YouTube video player", frameborder: "0", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share", allowfullscreen: "" }, null, -1)])), _: 1 }), z(s, { class: "w-full", to: "https://youtu.be/ctnBB3BC43A", target: "_blank" }, { default: X(() => r[22] || (r[22] = [ne(" Видео инструкция "), m("span", { class: "hidden sm:inline" }, " по пополнению биржи", -1)])), _: 1 })])])]), _: 1 })]), m("section", bx, [z(l, { class: "flex flex-col gap-y-10 sm:gap-y-[60px]" }, { default: X(() => [r[26] || (r[26] = m("div", null, [m("span", { class: "select-none whitespace-nowrap text-7xl font-semibold text-[#2e2e2e] sm:text-8xl" }, " Частые вопросы "), m("h2", { class: "-mt-10 text-3xl font-semibold leading-tight sm:-mt-12 sm:text-4xl" }, [ne(" Частые "), m("span", { class: "text-primary" }, "вопросы")])], -1)), m("div", vx, [(se(), Fe(ke, null, ho(t, f => z(u, { key: f.label, ui: { item: { size: "leading-tight sm:text-lg lg:text-xl", color: "dark:text-white", padding: "pb-0 pt-8" } }, multiple: "", "default-open": "", items: [f] }, { default: X(({ item: d, open: h }) => [m("button", wx, [m("span", xx, Ot(d.label), 1), m("div", _x, [(se(), Fe("svg", { class: $e(["transition-transform", { "rotate-180": !h }]), width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r[25] || (r[25] = [m("path", { d: "M5 15L12 8L19 15", stroke: "#348F4D", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]), 2))])])]), item: X(({ item: d }) => [m("p", { class: "[&>a]:font-semibold [&>a]:transition-opacity hover:[&>a]:opacity-70", innerHTML: d.content }, null, 8, Sx)]), _: 2 }, 1032, ["items"])), 64))])]), _: 1 })])]), z(c)]) } } }), kx = {
  __name: "nuxt-error-page", props: { error: Object }, setup(e) {
    const n = e.error; n.stack && n.stack.split(`
`).splice(1).map(f => ({ text: f.replace("webpack:/", "").replace(".vue", ".js").trim(), internal: f.includes("node_modules") && !f.includes(".cache") || f.includes("internal") || f.includes("new Promise") })).map(f => `<span class="stack${f.internal ? " internal" : ""}">${f.text}</span>`).join(`
`); const r = Number(n.statusCode || 500), o = r === 404, s = n.statusMessage ?? (o ? "Page Not Found" : "Internal Server Error"), i = n.message || n.toString(), l = void 0, c = o ? Ms(() => ni(() => import("./DD5dnlZh.js"), __vite__mapDeps([0, 1]), import.meta.url)) : Ms(() => ni(() => import("./R63OqrMl.js"), __vite__mapDeps([2, 3]), import.meta.url)); return (f, d) => (se(), Ce(we(c), ur(br({ statusCode: we(r), statusMessage: we(s), description: we(i), stack: we(l) })), null, 16))
  }
}, Ex = { key: 0 }, Ga = { __name: "nuxt-root", setup(e) { const t = () => null, n = he(), r = n.deferHydration(); if (n.isHydrating) { const a = n.hooks.hookOnce("app:error", r); dt().beforeEach(a) } const o = !1; Me(Vu, zi()), n.hooks.callHookWith(a => a.map(u => u()), "vue:setup"); const s = qi(), i = !1; Hc((a, u, c) => { if (n.hooks.callHook("vue:error", a, u, c).catch(f => console.error("[nuxt] Error in `vue:error` hook", f)), fm(a) && (a.fatal || a.unhandled)) return n.runWithContext(() => cm(a)), !1 }); const l = !1; return (a, u) => (se(), Ce(Yp, { onResolve: we(r) }, { default: X(() => [we(i) ? (se(), Fe("div", Ex)) : we(s) ? (se(), Ce(we(kx), { key: 1, error: we(s) }, null, 8, ["error"])) : we(l) ? (se(), Ce(we(t), { key: 2, context: we(l) }, null, 8, ["context"])) : we(o) ? (se(), Ce(zc(we(o)), { key: 3 })) : (se(), Ce(we(Cx), { key: 4 }))]), _: 1 }, 8, ["onResolve"])) } }; let Ka; { let e; Ka = async function () { var i, l; if (e) return e; const r = !!(((i = window.__NUXT__) == null ? void 0 : i.serverRendered) ?? ((l = document.getElementById("__NUXT_DATA__")) == null ? void 0 : l.dataset.ssr) === "true") ? qh(Ga) : zh(Ga), o = Qg({ vueApp: r }); async function s(a) { var u; await o.callHook("app:error", a), (u = o.payload).error || (u.error = Wi(a)) } r.config.errorHandler = s, o.hook("app:suspense:resolve", () => { r.config.errorHandler === s && (r.config.errorHandler = void 0) }); try { await em(o, Zb) } catch (a) { s(a) } try { await o.hooks.callHook("app:created", r), await o.hooks.callHook("app:beforeMount", r), r.mount(Kg), await o.hooks.callHook("app:mounted", r), await Ii() } catch (a) { s(a) } return r }, e = Ka().catch(t => { throw console.error("Error while mounting app:", t), t }) } export { en as _, m as a, z as b, Fe as c, ne as d, $v as e, se as o, Ot as t, Ym as u, X as w };
